## CollectionsLite

[1. Что такое "коллекция".](#1-что-такое-коллекция)

[2. Перечислите основные методы из интерфейса Collection.](#2-Перечислите-основные-методы-из-интерфейса-Collection)

[3. Назовите преимущества использования коллекций по сравнению с массивами.](#3-Назовите-преимущества-использования-коллекций-по-сравнению-с-массивами)

[4. Какие данные могут хранить коллекции?](#4-Какие-данные-могут-хранить-коллекции)

[5. Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций.](#5-Какие-есть-типы-коллекций-Как-они-характеризуются-Расскажите-про-иерархию-коллекций)

[6. Назовите основные классы, которые реализуют интерфейсы List Set Map](#6-Назовите-основные-классы-которые-реализуют-интерфейсы-List-Set-Map)

[7. В чем отличие ArrayList от LinkedList?](#7-В-чем-отличие-ArrayList-от-LinkedList)

[8. В чем отличие HashSet от TreeSet?](#8-В-чем-отличие-HashSet-от-TreeSet)

[9. В чем отличие Set от Map?](#9-В-чем-отличие-Set-от-Map)

[10. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?](#10-Как-задается-порядок-следования-объектов-в-коллекции-как-отсортировать-коллекцию)

[11. Чем отличается Comparable от Comparator?](#11-Чем-отличается-Comparable-от-Comparator)

[12. Что такое сортировка по принципу Natural Order?](#12-Что-такое-сортировка-по-принципу-Natural-Order)

[13. Что такое equals и hashcode?](#13-Что-такое-equals-и-hashcode)

[14. Какие есть способы перебора всех элементов List?](#14-Какие-есть-способы-перебора-всех-элементов-List)

[15. Расскажите о методах Map.](#15-Расскажите-о-методах-Map)

[16. Расскажите, какие классы реализовывают интерфейс Map?](#16-Расскажите-какие-классы-реализовывают-интерфейс-Map)

[17. Расскажите о методах map.keySet и map.entrySet? Что такое Entry?](#17-Расскажите-о-методах-keySet-и-entrySet-Что-такое-Entry)

[18. Что будет если вызвать метод put несколько раз с одинаковым ключом?](#18-Что-будет-если-вызвать-метод-put-несколько-раз-с-одинаковым-ключом)

[19. Как реализован цикл foreach?](#19-Как-реализован-цикл-foreach)

[20. В чем разница между Iterator и Iterable?](#20-В-чем-разница-между-Iterator-и-Iterable)

[21. Как происходит удаление элементов из ArrayList?](#21-Как-происходит-удаление-элементов-из-ArrayList)

[22. Как происходит удаление элементов из LinkedList?](#22-Как-происходит-удаление-элементов-из-LinkedList)

[23. Что такое авто упаковка и распаковка? Зачем они нужны?](#23-Что-такое-авто-упаковка-и-распаковка-Зачем-они-нужны)

[24. В каком случае при работе с упакованными значениями может возникнуть проблема с производительностью?](#24-В-каком-случае-при-работе-с-упакованными-значениями-может-возникнуть-проблема-с-производительностью)

[25. Опишите недостатки и преимущества в использовании примитивных типов и классов-оберток.](#25-Опишите-недостатки-и-преимущества-в-использовании-примитивных-типов-и-классов-оберток)

[26. Что такое очередь? Расскажите принцип работы и для чего она используется.](#26-Что-такое-очередь-Расскажите-принцип-работы-и-для-чего-она-используется)

[27. Расскажите про интерфейсы Queue, Deque и их иерархию.](#27-Расскажите-про-интерфейсы-Queue-Deque-и-их-иерархию)

[28. В чем отличие метода poll() от remove()?](#28-В-чем-отличие-метода-poll-от-remove)

[29. В чем отличие метода element() от peek()?](#29-В-чем-отличие-метода-element-от-peek)

[30. В чем отличие метода element() от poll()?](#30-В-чем-отличие-метода-element-от-poll)

[31. Перечислите наиболее часто используемые реализации интерфейса Queue.](#31-Перечислите-наиболее-часто-используемые-реализации-интерфейса-Queue)

[32. Что такое ограниченные и неограниченные очереди?](#32-Что-такое-ограниченные-и-неограниченные-очереди)

[33. Что такое односторонние и двусторонние очереди?](#33-Что-такое-односторонние-и-двусторонние-очереди)

[34. В чем отличие Deque от Queue?](#34-В-чем-отличие-Deque-от-Queue)

[35. В чем отличие методов removeLast() и pollLast()?](#35-В-чем-отличие-методов-removeLast-и-pollLast)

[36. Назовите самую распространенную реализацию Deque.](#36-Назовите-самую-распространенную-реализацию-Deque)

# 1. Что такое "коллекция".

Коллекции в Java — это специализированные структуры данных, которые позволяют эффективно хранить и обрабатывать
множество объектов. Это иерархия интерфейсов и реализаций, которая является частью JDK и позволяет программистам
пользоваться большим
количеством структур для хранения набора данных. Java предоставляет различные реализации коллекций, такие как ArrayList,
LinkedList, HashMap, TreeSet и другие. Выбор конкретной коллекции зависит от требований приложения и того, как данные
будут использоваться.

[К оглавлению](#CollectionsLite)

# 2. Перечислите основные методы из интерфейса Collection.

Главным набором методов, который важен при рассмотрении любой коллекции является набор CRUD-операций (create, read,
update, delete). На уровне Collection не существует способа обновить запись в коллекции

- add(Object o) - добавляет элемент в коллекцию.
- iterator() - возвращает итератор для перебора элементов коллекции.
- remove(Object o) - удаляет элемент из коллекции.
- contains(Object o) - проверяет, есть ли элемент в коллекции.
- size() - возвращает количество элементов в коллекции.
- clear() - очищает коллекцию (удаляет все элементы).
- toArray() - возвращает массив, содержащий все элементы коллекции

[К оглавлению](#CollectionsLite)

# 3. Назовите преимущества использования коллекций по сравнению с массивами.

- отсутствует необходимость следить за размерами коллекции (в отличие от массива).
- позволяют сократить количество кода и требуют меньше усилий для реализации, т.к. в коллекциях реализовано много
  методов по добавлению, удалению, сортировке элементов и т.п.
- если правильно подобрать коллекцию, то можно увеличить производительность программы.

[К оглавлению](#CollectionsLite)

# 4. Какие данные могут хранить коллекции?

Любые ссылочные типы данных.

[К оглавлению](#CollectionsLite)

# 5. Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций.

![img](https://github.com/itlazykin/answers_to_exam_questions/blob/main/main/resources/Collections.png)

+ List - список.
+ Set - множество
+ Queue - очередь
+ Map - пара "ключ - значение"

**Реализации List:**

+ ***ArrayList*** - это список, который реализован как массив. Это означает, что элементы в ArrayList хранятся в
  последовательном порядке и могут быть доступны по индексу. Основные характеристики ArrayList включают динамическое
  увеличение размера, высокую производительность при доступе к элементам по индексу и возможность изменения элементов.
  Применяется, когда в процессе работы предполагается частое обращение к элементам по индексу. Следует избегать, если
  предполагается частое добавление/удаление элементов в середину списка. Позволяет хранить любые значения, в том числе
  null. Не потокобезопасен.
+ ***LinkedList*** - это двусвязный список (можно использовать как стэк или очередь), в котором каждый элемент содержит
  ссылки на предыдущий и следующий элементы. Это означает, что вставка и удаление элементов в середине списка
  выполняются быстрее, чем в ArrayList. Однако доступ к элементам по индексу в LinkedList более медленный. Позволяет
  хранить любые значения, в том числе null. Не потокобезопасен.
+ ***Vector*** - похож на ArrayList. Синхронизирован. Содержит много устаревших методов, которые не являются частью
  структуры коллекций. Не рекомендуется использовать, если не требуется потокобезопасность.
+ ***Stack*** - это реализация стека, который представляет собой упорядоченный список элементов, где добавление и
  удаление элементов происходит в конце списка (LIFO - last in, first out). После добавления интерфейса Queue не
  рекомендуется к использованию.

Все эти коллекции реализуют интерфейс List, что означает, что они поддерживают операции добавления, удаления и доступа к
элементам по индексу.

**Реализации Queue:**

+ ***PriorityQueue*** - это класс, который реализует очередь с приоритетом. Он характеризуется тем, что элементы
  добавляются в очередь с учетом их приоритета и извлекаются в порядке возрастания или убывания приоритета.
  PriorityQueue может быть использована для реализации алгоритмов, таких как алгоритм Дейкстры или алгоритм сортировки
  слиянием. Не работает с null и non-comparable элементами. По умолчанию сортировка по принципу naturalOrder. Порядок
  сортировки задается c использованием Comparator. Не потокобезопасен.
+ ***LinkedList*** - это двусвязный список (можно использовать как стэк или очередь), в котором каждый элемент содержит
  ссылки на предыдущий и следующий элементы. Это означает, что вставка и удаление элементов в середине списка
  выполняются быстрее, чем в ArrayList. Однако доступ к элементам по индексу в LinkedList более медленный. Позволяет
  хранить любые значения, в том числе null. Не потокобезопасен.
+ ***ArrayDeque*** - это класс, который реализует двустороннюю очередь. Он характеризуется тем, что позволяет добавлять
  и удалять элементы как в начало, так и в конец очереди за O(1) времени. Также ArrayDeque имеет фиксированный размер и
  может быть использован как стек. Реализован с использованием массивов, однако не позволяет обращаться к элементам по
  индексу и хранить null.

В целом, все эти коллекции позволяют добавлять, извлекать и просматривать элементы в порядке их добавления или в
соответствии с определенным приоритетом.

**Реализации Set:**

+ ***HashSet*** - это наиболее распространенная реализация Set, основанная на хэш-таблице (что позволяет постоянство по
  времени на поиск, удаление и добавление элементов). Он не гарантирует порядок элементов при их добавлении. Не
  допускает дубликатов. Хранит только объекты (примитивы заворачивает в обертки). Не потокобезопасен.
+ ***LinkedHashSet*** - это реализация Set, которая поддерживает порядок элементов в том порядке, в котором они были
  добавлены (именно порядок вставки, а не значения элементов). Как и HashSet, она не допускает дублирования элементов.
  Постоянное время добавления, поиска и удаления элементов. Не потокобезопасен.
+ ***TreeSet*** - это реализация Set, которая хранит элементы в отсортированном порядке. Он использует красно-черное
  дерево для хранения элементов и гарантирует, что они будут отсортированы в естественном порядке (например, числа в
  возрастающем порядке, строки в алфавитном порядке). Не работает с null и non-comparable элементами. По умолчанию
  сортировка по принципу naturalOrder. Порядок сортировки задается c использованием Comparator.

**Реализации Map:**

+ ***HashMap*** - основанный на хэш-таблице класс, который обеспечивает постоянное время выполнения операций добавления,
  удаления и поиска элементов. Однако порядок элементов в HashMap не определен. При попытке вставить элемент по уже
  имеющемуся ключу - заменит значение на новое. Допускает значение ключа null. Не потокобезопасен. Содержит только
  уникальные ключи.
+ ***LinkedHashMap*** - класс, который расширяет HashMap и хранит элементы в порядке их вставки. Поиск элементов в
  LinkedHashMap происходит чуть медленнее, чем в HashMap, но можно обеспечить итерацию элементов в порядке, в котором
  они были добавлены. Не потокобезопасен.
+ ***TreeMap*** - класс, основанный на структуре красно-черного дерева, который хранит элементы в отсортированном
  порядке по ключу. По умолчанию сортировка по принципу naturalOrder. Порядок сортировки задается c использованием
  Comparator. Поиск элементов в TreeMap выполняется за время log(n).
+ ***ConcurrentHashMap*** - класс, аналогичный HashMap, но с многопоточной поддержкой. Он обеспечивает безопасную работу
  с коллекцией в многопоточной среде.

На вершине иерархии Java Collection Framework находятся 2 интерфейса: Collection и Map. Они разделяют все коллекции,
входящие в фреймворк, на 2 части по типу хранения данных: простые последовательные наборы элементов, и набор пар
«ключ-значение».
Интерфейс Collection является базовым для всех коллекций, он расширяет интерфейс Iterable поэтому все объекты коллекций
можно перебирать в улучшенном цикле for. У интерфейса Iterable определен только один метод iterator(). Таким образом все
наследники Collection обязаны вернуть итератор. Итератор – это объект, который абстрагирует
за единым интерфейсом доступ к элементам коллекции. К тому же итератор – это паттерн, который позволяет получить доступ
к элементам любой коллекции без необходимости вникать в суть его реализации.

[К оглавлению](#CollectionsLite)

# 6. Назовите основные классы, которые реализуют интерфейсы List Set Map.

- ArrayList, LinkedList, Vector - классы для хранения элементов в виде массива. Они реализуют интерфейс List.
- HashSet, LinkedHashSet, TreeSet - классы для хранения уникальных элементов. Они реализуют интерфейсы Set и SortedSet.
- HashMap, LinkedHashMap, TreeMap, ConcurrentHashMap - классы для хранения пар ключ-значение. Они реализуют интерфейс
  Map и его наследников.
- 
[К оглавлению](#CollectionsLite)

# 7. В чем отличие ArrayList от LinkedList?

- ArrayList использует массив для хранения элементов, и когда требуется добавить новый элемент, он увеличивает размер
  массива. Это делает добавление элементов быстрым, но удаление элементов из середины списка может быть медленным, так
  как
  необходимо переместить все элементы после удаляемого.

- LinkedList использует связные списки для хранения элементов. Каждый элемент содержит ссылку на следующий и предыдущий
  элементы, что позволяет добавлять и удалять элементы из любого места списка быстро. Однако, поиск элементов может быть
  медленнее, так как требуется пройти по всему списку до нужного элемента.

[К оглавлению](#CollectionsLite)

# 8. В чем отличие HashSet от TreeSet?

TreeSet обеспечивает упорядоченно хранение элементов в виде красно-черного дерева. Сложность выполнения основных
операций в TreeSet lg N. HashSet использует для хранения элементов такой же подход, что и HashMap, за тем отличием, что
в HashSet в качестве ключа выступает сам элемент, кроме того HashSet (как и HashMap) не поддерживает упорядоченное
хранение элементов и обеспечивает временную сложность выполнения операций аналогично HashMap.

[К оглавлению](#CollectionsLite)

# 9. В чем отличие Set от Map?

Set - расширяет интерфейс Collection, Map - не входит в иерархию. Set используется для хранения неупорядоченных
коллекций уникальных элементов, в то время как Map хранит пары
ключ-значение и позволяет быстро извлекать значение по ключу.

[К оглавлению](#CollectionsLite)

# 10. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?

Порядок задается либо естественным следованием элементов (natural order), либо объектом, реализующим интерфейс сравнения
Comparator. Если объекты коллекции поддерживают интерфейс Comparable, то через Collections.sort(collection).
Если нет, то у коллекции вызвать метод sort() и передать ему Comparator в качестве аргумента collection.sort(new
MyComparator()). Либо использовать метод Collections.sort(collection, new MyComparator()).

[К оглавлению](#CollectionsLite)

# 11. Чем отличается Comparable от Comparator?

Comparable - используется только для сравнения объектов класса, в котором данный интерфейс реализован. Т.е. интерфейс
Comparable определяет логику сравнения объектов определенного ссылочного типа внутри своей реализации (по правилам
разработчика). Collections.sort(collection);

Comparator - представляет отдельную реализацию и ее можно использовать многократно и с различными классами. Т.е.
интерфейс Comparator позволяет создавать объекты, которые будут управлять процессом сравнения:

- при сортировках в методах Collections.sort(collection, new MyComparator()), Arrays.sort(array, new MyComparator()) или
  collection.sort(new MyComparator())
- при управлении порядком в отсортированных множествах TreeSet или отсортированных картах TreeMap, например new
  TreeSet<T> (new MyComparator()).

Отличия: Comparable определяет логику сравнения объектов определенного ссылочного типа внутри своей реализации и, если
нет
доступа к исходникам, ее невозможно изменить.
Comparator позволяет определить логику сравнения объектов определенного ссылочного типа вне реализации этого типа и эту
логику можно в любой момент изменить.
Comparable используется для сортировки по возрастанию, а Comparator для сортировки по убыванию.

[К оглавлению](#CollectionsLite)

# 12. Что такое сортировка по принципу Natural Order?

Значения располагаются от меньшего к большему.

[К оглавлению](#CollectionsLite)

# 13. Что такое equals и hashcode?

Методы, необходимые для определения равенства объектов. Метод equals сравнивает два объекта на равенство. Если результат
сравнения равен true, это означает, что два объекта равны.
Метод hashcode используется для определения местоположения объекта в хэш-таблице. Если два объекта имеют одинаковый
хэш-код, то вызывается метод equals для сравнения двух объектов.
Если не переопределить метод equals, он будет сравнивать ссылки на объекты. Если вы переопределите этот
метод, вы должны также переопределить метод hashCode, чтобы обеспечить корректную работу хэш-таблицы.

[К оглавлению](#CollectionsLite)

# 14. Какие есть способы перебора всех элементов List?

- через index (fori, while)
```java
        for(int i=0;i<countries.size();i++){
        System.out.println(countries.get(i));
        }
```

```java
        int i=0;
        while(i<countries.size()){
        System.out.println(countries.get(i++));
        }
```

- через iterator (while)
```java
Iterator<String> countriesIterator=countries.iterator();
        while(countriesIterator.hasNext()){
        System.out.println(countriesIterator.next());
        }
```

```java
ListIterator<String> listIterator=countries.listIterator();
//в прямом порядке
        while(listIterator.hasNext()){
        System.out.println(listIterator.next());
        }
//в обратном порядке
        while(listIterator.hasPrevious()){
        System.out.println(listIterator.previous());
        }    
```

- foreach
```java
        for(String country:countries){
        System.out.println(country);
        }    
```

[К оглавлению](#CollectionsLite)

# 15. Расскажите о методах Map.
V put(K key, V value); - вставит данные в карту.

V get(K key); - получить значение по ключу.

Пару можно обновить тем же методом, что и вставить.
Ключ пары должен быть уникальный. Если в Map уже есть такой key,
то ячейка value будет заменена на новое значение.

remove(key) — удаляет элемент с указанным ключом из карты. Если ключ отсутствует, исключение не выбрасывается.

keySet(), values() и entrySet() — возвращают соответственно набор ключей, значений и пар ключ-значение в карте.

containsKey(key) и containsValue(value) — проверяют, содержит ли карта указанный ключ или значение.

clear() — удаляет все элементы из карты.

size() — возвращает количество элементов в карте.

isEmpty() — проверяет, пуста ли карта.

[К оглавлению](#CollectionsLite)

# 16. Расскажите, какие классы реализовывают интерфейс Map?
Наиболее часто используемые реализации интерфейса Map в Java включают HashMap, LinkedHashMap, TreeMap,
ConcurrentHashMap, Hashtable и WeakHashMap.

- HashMap - это хэш-карта, которая использует алгоритм хеширования для быстрого доступа к элементам.
- LinkedHashMap обеспечивает дополнительный порядок элементов, сохраняя ссылки на предыдущие и последующие элементы.
- TreeMap упорядочивает элементы по их ключам, используя красно-черное дерево для хранения элементов.
- ConcurrentHashMap является потокобезопасной версией HashMap, оптимизированной для многопоточных приложений.
- Hashtable - это устаревшая реализация Map, которая все еще используется в некоторых старых приложениях.
- WeakHashMap использует слабые ссылки для хранения элементов, что может быть полезно для приложений, где необходим
  сбор мусора.

[К оглавлению](#CollectionsLite)

# 17. Расскажите о методах keySet и entrySet? Что такое Entry?
Методы необходимые для итерации по элементам.

- keySet(), возвращает коллекцию java.util.Set состоящую только из ключей.
- entrySet(), вернет коллекцию java.util.Set состоящую из объекта Map.Entry, которая сразу содержит и ключ и значение.
- Entry - это класс в Java, который представляет пару ключ-значение. Он используется для работы с картами и коллекциями.
  Entry имеет методы getKey() и getValue() для получения ключа и значения соответственно.

[К оглавлению](#CollectionsLite)

# 18. Что будет если вызвать метод put несколько раз с одинаковым ключом?
В этом случае будет сохраняться последний добавленный элемент с данным ключом.

[К оглавлению](#CollectionsLite)

# 19. Как реализован цикл foreach?
Цикл for-each внутри использует механизм итератора. Все
коллекции реализуют шаблон проектирования - итератор. Этот
шаблон позволяет получить все элементы из любой коллекции. Шаблон итератор основан на интерфейсе java.util.Iterable.
Он имеет три основных метода:

- boolean hasNext() - проверяет на наличие следующего элемента в списке.
- T next() - возвращает элемент из коллекции и переводит указатель на следующий элемент.
- void remove() - удаляет элемент из коллекции и переводит указатель назад.

Указатель - это механизм позволяющий извлечь одиночный элемент из коллекции. Например: для массива указатель будет
индекс
элемента.
Цикл foreach в Java не является настоящим циклом, он всего лишь синтаксический сахар для итераторов. Каждый раз, когда
вы используете foreach, Java создает итератор для коллекции и выполняет блок кода для каждого элемента в коллекции.

[К оглавлению](#CollectionsLite)

# 20. В чем разница между Iterator и Iterable?
Interface Iterable находится в пакете java.lang и реализация этого интерфейса позволяет объекту быть итерируемым с
помощью for-each. Из под реализации Iterable можно вызвать метод iterator(). И не один. И даже в нескольких потоках. А
может и не использовать итератор вовсе.

Interface Iterator находится в пакете java.util. В его имплементации задаются правила обхода коллекции.

Iterable (какое) - итерируемое. То по чему можно итерироваться. Реализуется классом, по которому нужно будет
итерироваться.
Iterator (кто/что) - инструмент итерирования по коллекции. Итератор это отдельный класс, как правило, вложенный в
итерируемый класс, который задает логику итерации по итерируемому. И, естественно, реализует интерфейс Iterator.
[К оглавлению](#CollectionsLite)

# 21. Как происходит удаление элементов из ArrayList?
Находится заданный элемент. Далее сдвигаются влево на один элемент все последующие (с большим индексом) элементы, а
значение size уменьшается на 1.

```java
        System.arraycopy(es,i+1,es,i,newSize-i)
        es[size=newSize]=null;
```

[К оглавлению](#CollectionsLite)

# 22. Как происходит удаление элементов из LinkedList?
Заменяются ссылки previous и next у соседних элементов.

[К оглавлению](#CollectionsLite)

# 23. Что такое авто упаковка и распаковка? Зачем они нужны?
Автоупаковка - это автоматическая инкапсуляция примитивного типа в эквивалентную ему класс-обёртку всякий раз, когда
требуется объект данного типа. Происходит:

- при присвоении значения примитивного типа переменной соответствующего класса-обёртки.
- при передаче примитивного типа в параметр метода, ожидающего соответствующий ему класс-обёртку.

Автораспаковка - это преобразование класса-обёртки в соответствующий ему примитивный тип. Если при распаковке
класс-обёртка был равен null, произойдет исключение java.lang.NullPointerException. Происходит:

- при присвоении экземпляра класса-обёртки переменной соответствующего примитивного типа.
- в выражениях, в которых один или оба аргумента являются экземплярами классов-обёрток (кроме операции == и !=).
- при передаче объекта класса-обёртки в метод, ожидающий соответствующий примитивный тип.

Автоупаковка и распаковка очень часто происходит при работе с коллекциями, так как они не могут хранить примитивные типы
данных.

[К оглавлению](#CollectionsLite)

# 24. В каком случае при работе с упакованными значениями может возникнуть проблема с производительностью?
Появление классов-обёрток обусловлено тем, что Java - это объектно-ориентированный язык, и все сущности в идеале должны
быть объектами. Но отказавшись от примитивных типов, упала бы производительность, поэтому к существующим примитивным
типам добавили соответствующие классы-обертки, тем самым обеспечив гибкость работы с примитивными значениями.
Классы-обертки являются неизменяемыми, поэтому упакованное значение невозможно изменить. Для очень трудоёмких
вычислений, где производительность критически важна, следует использовать примитивные типы.

[К оглавлению](#CollectionsLite)

# 25. Опишите недостатки и преимущества в использовании примитивных типов и классов-оберток.
- при работе с примитивными типами повышается производительность, так как на упаковку значения в обёртку уходит
  дополнительное время.
- примитивные типы занимают меньше места в памяти.
- если в программе работа идет с объектами, а не со значениями, то работать с примитивными типами будет нельзя,
  понадобится упаковка.
- обёртки - это такие же классы со своими методами, как и любые остальные, которые мы рассматривали. Поэтому работа
  со значением в виде объекта даёт преимущества в виде возможности применения методов этих классов. (Например, для
  Integer это parseInt(), valueOf(), compareTo() и т.д.).

[К оглавлению](#CollectionsLite)

# 26. Что такое очередь? Расскажите принцип работы и для чего она используется.
Очередь используется для вставки элементов в конец очереди и удаления из начала очереди. Такой способ организации
хранения
данных называется FIFO(First-In-First-Out). Очередь – очень удобный инструмент, который используется для моделирования
реальных ситуаций ожидания клиентов в банке,
вылета самолетов или передачи данных по Интернету.

[К оглавлению](#CollectionsLite)

# 27. Расскажите про интерфейсы Queue, Deque и их иерархию.
Queue - это интерфейс, который представляет собой очередь, то есть структуру данных, где элементы добавляются в один
конец и удаляются из другого конца. Он реализует методы add() и remove(), а также contains(Object),
iterator() и size().

Deque (Double-ended queue) - это двунаправленная очередь, которая позволяет добавлять и удалять элементы с обоих концов.
Он расширяет интерфейс Queue и добавляет дополнительные методы, такие как addFirst(), removeFirst(), addLast() и
removeLast().
Иерархия этих интерфейсов выглядит следующим образом:`Collection -> Queue -> Deque`Т.е. Queue является
подклассом интерфейса Collection, а Deque - подклассом Queue.

[К оглавлению](#CollectionsLite)

# 28. В чем отличие метода poll() от remove()?
Оба метода позволяют удалить верхний элемент из очереди. Отличия в них видны, когда мы применяем эти методы на пустой очереди.
poll() - возвращает null.
remove() - генерирует исключение NoSuchElementException.

[К оглавлению](#CollectionsLite)

# 29. В чем отличие метода element() от peek()?
Оба метода позволяют вернуть первый элемент из очереди без его удаления.
Отличия в них видны, когда мы применяем эти методы на пустой очереди.
element() - генерирует исключение NoSuchElementException.
peek() - возвращает null.

[К оглавлению](#CollectionsLite)

# 30. В чем отличие метода element() от poll()?
element() возвращает (но не удаляет) первый элемент очереди. Если очередь пуста, выбрасывает исключение NoSuchElementException.
poll() возвращает и удаляет первый элемент очереди. Возвращает null, если очередь пуста.

[К оглавлению](#CollectionsLite)

# 31. Перечислите наиболее часто используемые реализации интерфейса Queue.
LinkedList, ArrayBlockingQueue и PriorityQueue —
наиболее часто используемые реализации интерфейса Queue.

[К оглавлению](#CollectionsLite)

# 32. Что такое ограниченные и неограниченные очереди?

Очереди, доступные в пакете java.util, являются неограниченными очередями - это те очереди, которые не имеют
фиксированного размера.Они могут увеличиваться по мере необходимости до тех пор, пока позволяет память.(LinkedList,
ConcurrentLinkedQueue)

Очереди, доступные в пакете java.util.concurrent, являются ограниченными очередями -это очереди, которые имеют
фиксированный размер. Когда размер очереди достигает своего предела, попытки добавить новые элементы могут блокироваться
или приводить к исключениям в зависимости от реализации.(ArrayBlockingQueue, LinkedBlockingQueue)

[К оглавлению](#CollectionsLite)

# 33. Что такое односторонние и двусторонние очереди?
Односторонняя очередь, это такая очередь, в которую элементы могут быть добавлены\удалены только в одном направлении.
Двухсторонняя очередь, это такая очередь, в которую элементы могут быть добавлены\удалены в двух направлениях.

[К оглавлению](#CollectionsLite)

# 34. В чем отличие Deque от Queue?
Queue реализует одностороннюю очередь,
такая очередь позволяет поместить элементы в один конец очереди,
а извлекать их – из другого.

Deque расширяет интерфейс Queue.
Этот интерфейс также является очередью, но ее отличительной особенностью то,
что эта очередь является двухсторонней, т.е. она поддерживает удаление
и добавление элементов с обоих концов очереди.

Таким образом, в отличие от Queue, здесь также можно организовать способ
хранения элементов по принципу LIFO (сокращение по первой букве
от описания этого принципа на английском языке Last In First Out
– последний пришел, первый вышел
Такую структуру данных в программировании называют стеком.

Пример аналогии из жизни – стопка тетрадей на проверку у учителя,
учитель проверяет их по порядку и та тетрадь, которая была положена
в эту стопку первой будет проверена последней.
(или стопка тарелок)

[К оглавлению](#CollectionsLite)

# 35. В чем отличие методов removeLast() и pollLast()?
Методы удаляют первый элемент из очереди с его возвратом. Первый сгенерирует исключение при пустой очереди, второй –
вернет null.

[К оглавлению](#CollectionsLite)

# 36. Назовите самую распространенную реализацию Deque.
Наиболее часто используемой реализацией интерфейса Deque является класс LinkedList.
LinkedList реализует интерфейс Deque, Deque наследует интерфейс Queue со всеми его методами. Следовательно,
при создании объекта LinkedList можно использовать оба базовых типа указанных интерфейсов 
следующие обе строки кода будут работать без проблем:

Queue<String> queue = new LinkedList<>();

Deque<String> deque = new LinkedList<>();

В этом и есть одно из самых ярких проявлений полиморфизма – вместо того,
чтобы слева от знака присваивания ставить конкретный класс,
мы используем интерфейс и, следовательно, можем использовать методы,
определенные в нем, а также всех вышестоящих по иерархии интерфейсов.
Таким образом, разница в этих записях в том, что для первой строки будут
доступны только методы интерфейса Queue и всех вышестоящих интерфейсов
(Collection и Iterable). Для второй строки – будут добавлены все методы,
которые определены в интерфейсе Deque.

[К оглавлению](#CollectionsLite)