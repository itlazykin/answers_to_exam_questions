## CollectionsLite

[1. Что такое "коллекция".](#1-что-такое-коллекция)

[2. Перечислите основные методы из интерфейса Collection.](#2-Перечислите-основные-методы-из-интерфейса-Collection)

[3. Назовите преимущества использования коллекций по сравнению с массивами.](#3-Назовите-преимущества-использования-коллекций-по-сравнению-с-массивами)

[4. Какие данные могут хранить коллекции?](#4-Какие-данные-могут-хранить-коллекции)

[5. Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций.](#5-Какие-есть-типы-коллекций-Как-они-характеризуются-Расскажите-про-иерархию-коллекций)

[6. Назовите основные классы, которые реализуют интерфейсы List Set Map](#6-Назовите-основные-классы-которые-реализуют-интерфейсы-List-Set-Map)

[7. В чем отличие ArrayList от LinkedList?](#7-В-чем-отличие-ArrayList-от-LinkedList)

[8. В чем отличие HashSet от TreeSet?](#8-В-чем-отличие-HashSet-от-TreeSet)

[9. В чем отличие Set от Map?](#9-В-чем-отличие-Set-от-Map)

[10. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?](#10-Как-задается-порядок-следования-объектов-в-коллекции-как-отсортировать-коллекцию)

[11. Чем отличается Comparable от Comparator?](#11-Чем-отличается-Comparable-от-Comparator)

[12. Что такое сортировка по принципу Natural Order?](#12-Что-такое-сортировка-по-принципу-Natural-Order)

[13. Что такое equals и hashcode?](#13-Что-такое-equals-и-hashcode)

[14. Какие есть способы перебора всех элементов List?](#14-Какие-есть-способы-перебора-всех-элементов-List)

[15. Расскажите о методах Map.](#15-Расскажите-о-методах-Map)

[16. Расскажите, какие классы реализовывают интерфейс Map?](#16-Расскажите-какие-классы-реализовывают-интерфейс-Map)

[17. Расскажите о методах map.keySet и map.entrySet? Что такое Entry?](#17-Расскажите-о-методах-keySet-и-entrySet-Что-такое-Entry)

[18. Что будет если вызвать метод put несколько раз с одинаковым ключом?](#18-Что-будет-если-вызвать-метод-put-несколько-раз-с-одинаковым-ключом)

[19. Как реализован цикл foreach?](#19-Как-реализован-цикл-foreach)

[20. В чем разница между Iterator и Iterable?](#20-В-чем-разница-между-Iterator-и-Iterable)

[21. Как происходит удаление элементов из ArrayList?](#21-Как-происходит-удаление-элементов-из-ArrayList)

[22. Как происходит удаление элементов из LinkedList?](#22-Как-происходит-удаление-элементов-из-LinkedList)

[23. Что такое авто упаковка и распаковка? Зачем они нужны?](#23-Что-такое-авто-упаковка-и-распаковка-Зачем-они-нужны)

[24. В каком случае при работе с упакованными значениями может возникнуть проблема с производительностью?](#24-В-каком-случае-при-работе-с-упакованными-значениями-может-возникнуть-проблема-с-производительностью)

[25. Опишите недостатки и преимущества в использовании примитивных типов и классов-оберток.](#25-Опишите-недостатки-и-преимущества-в-использовании-примитивных-типов-и-классов-оберток)

[26. Что такое очередь? Расскажите принцип работы и для чего она используется.](#26-Что-такое-очередь-Расскажите-принцип-работы-и-для-чего-она-используется)

[27. Расскажите про интерфейсы Queue, Deque и их иерархию.](#27-Расскажите-про-интерфейсы-Queue-Deque-и-их-иерархию)

[28. В чем отличие метода poll() от remove()?](#28-В-чем-отличие-метода-poll-от-remove)

[29. В чем отличие метода element() от peek()?](#29-В-чем-отличие-метода-element-от-peek)

[30. В чем отличие метода element() от poll()?](#30-В-чем-отличие-метода-element-от-poll)

[31. Перечислите наиболее часто используемые реализации интерфейса Queue.](#31-Перечислите-наиболее-часто-используемые-реализации-интерфейса-Queue)

[32. Что такое ограниченные и неограниченные очереди?](#32-Что-такое-ограниченные-и-неограниченные-очереди)

[33. Что такое односторонние и двусторонние очереди?](#33-Что-такое-односторонние-и-двусторонние-очереди)

[34. В чем отличие Deque от Queue?](#34-В-чем-отличие-Deque-от-Queue)

[35. В чем отличие методов removeLast() и pollLast()?](#35-В-чем-отличие-методов-removeLast-и-pollLast)

[36. Назовите самую распространенную реализацию Deque.](#36-Назовите-самую-распространенную-реализацию-Deque)

# 1. Что такое "коллекция".

Коллекции в Java — это специализированные структуры данных, которые позволяют эффективно хранить и обрабатывать
множество объектов. Это иерархия интерфейсов и реализаций, которая является частью JDK и позволяет программистам
пользоваться большим
количеством структур для хранения набора данных. Java предоставляет различные реализации коллекций, такие как ArrayList,
LinkedList, HashMap, TreeSet и другие. Выбор конкретной коллекции зависит от требований приложения и того, как данные
будут использоваться.

[К оглавлению](#CollectionsLite)

# 2. Перечислите основные методы из интерфейса Collection.

Главным набором методов, который важен при рассмотрении любой коллекции является набор CRUD-операций (create, read,
update, delete). На уровне Collection не существует способа обновить запись в коллекции

- add(Object o) - добавляет элемент в коллекцию.
- iterator() - возвращает итератор для перебора элементов коллекции.
- remove(Object o) - удаляет элемент из коллекции.
- contains(Object o) - проверяет, есть ли элемент в коллекции.
- size() - возвращает количество элементов в коллекции.
- clear() - очищает коллекцию (удаляет все элементы).
- toArray() - возвращает массив, содержащий все элементы коллекции

[К оглавлению](#CollectionsLite)

# 3. Назовите преимущества использования коллекций по сравнению с массивами.

- отсутствует необходимость следить за размерами коллекции (в отличие от массива).
- позволяют сократить количество кода и требуют меньше усилий для реализации, т.к. в коллекциях реализовано много
  методов по добавлению, удалению, сортировке элементов и т.п.
- если правильно подобрать коллекцию, то можно увеличить производительность программы.

[К оглавлению](#CollectionsLite)

# 4. Какие данные могут хранить коллекции?

Любые ссылочные типы данных.

[К оглавлению](#CollectionsLite)

# 5. Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций.

![img](https://github.com/itlazykin/answers_to_exam_questions/blob/main/main/resources/Collections.png)

+ List - список.
+ Set - множество уникальных элементов.
+ Queue - очередь.
+ Map - пара "ключ - значение"

**Реализации List:**

+ ***ArrayList*** - это список, который реализован как массив. Это означает, что элементы в ArrayList хранятся в
  последовательном порядке и могут быть доступны по индексу. Основные характеристики ArrayList включают динамическое
  увеличение размера, высокую производительность при доступе к элементам по индексу и возможность изменения элементов.
  Применяется, когда в процессе работы предполагается частое обращение к элементам по индексу. Следует избегать, если
  предполагается частое добавление/удаление элементов в середину списка. Позволяет хранить любые значения, в том числе
  null. Не потокобезопасен.
+ ***LinkedList*** - это двусвязный список (можно использовать как стэк или очередь), в котором каждый элемент содержит
  ссылки на предыдущий и следующий элементы. Это означает, что вставка и удаление элементов в середине списка
  выполняются быстрее, чем в ArrayList. Однако доступ к элементам по индексу в LinkedList более медленный. Позволяет
  хранить любые значения, в том числе null. Не потокобезопасен.
+ ***Vector*** - похож на ArrayList. Синхронизирован. Содержит много устаревших методов, которые не являются частью
  структуры коллекций. Не рекомендуется использовать, если не требуется потокобезопасность.
+ ***Stack*** - это реализация стека, который представляет собой упорядоченный список элементов, где добавление и
  удаление элементов происходит в конце списка (LIFO - last in, first out). После добавления интерфейса Queue не
  рекомендуется к использованию.

Все эти коллекции реализуют интерфейс List, что означает, что они поддерживают операции добавления, удаления и доступа к
элементам по индексу.

**Реализации Queue:**

+ ***PriorityQueue*** - это класс, который реализует очередь с приоритетом. Он характеризуется тем, что элементы
  добавляются в очередь с учетом их приоритета и извлекаются в порядке возрастания или убывания приоритета.
  PriorityQueue может быть использована для реализации алгоритмов, таких как алгоритм Дейкстры или алгоритм сортировки
  слиянием. Не работает с null и non-comparable элементами. По умолчанию сортировка по принципу naturalOrder. Порядок
  сортировки задается c использованием Comparator. Не потокобезопасен.
+ ***LinkedList*** - это двусвязный список (можно использовать как стэк или очередь), в котором каждый элемент содержит
  ссылки на предыдущий и следующий элементы. Это означает, что вставка и удаление элементов в середине списка
  выполняются быстрее, чем в ArrayList. Однако доступ к элементам по индексу в LinkedList более медленный. Позволяет
  хранить любые значения, в том числе null. Не потокобезопасен.
+ ***ArrayDeque*** - это класс, который реализует двустороннюю очередь. Он характеризуется тем, что позволяет добавлять
  и удалять элементы как в начало, так и в конец очереди за O(1) времени. Также ArrayDeque имеет фиксированный размер и
  может быть использован как стек. Реализован с использованием массивов, однако не позволяет обращаться к элементам по
  индексу и хранить null.

В целом, все эти коллекции позволяют добавлять, извлекать и просматривать элементы в порядке их добавления или в
соответствии с определенным приоритетом.

**Реализации Set:**

+ ***HashSet*** - это наиболее распространенная реализация Set, основанная на хэш-таблице (что позволяет постоянство по
  времени на поиск, удаление и добавление элементов). Он не гарантирует порядок элементов при их добавлении. Не
  допускает дубликатов. Хранит только объекты (примитивы заворачивает в обертки). Не потокобезопасен.
+ ***LinkedHashSet*** - это реализация Set, которая поддерживает порядок элементов в том порядке, в котором они были
  добавлены (именно порядок вставки, а не значения элементов). Как и HashSet, она не допускает дублирования элементов.
  Постоянное время добавления, поиска и удаления элементов. Не потокобезопасен.
+ ***TreeSet*** - это реализация Set, которая хранит элементы в отсортированном порядке. Он использует красно-черное
  дерево для хранения элементов и гарантирует, что они будут отсортированы в естественном порядке (например, числа в
  возрастающем порядке, строки в алфавитном порядке). Не работает с null и non-comparable элементами. По умолчанию
  сортировка по принципу naturalOrder. Порядок сортировки задается c использованием Comparator.

**Реализации Map:**

+ ***HashMap*** - основанный на хэш-таблице класс, который обеспечивает постоянное время выполнения операций добавления,
  удаления и поиска элементов. Однако порядок элементов в HashMap не определен. При попытке вставить элемент по уже
  имеющемуся ключу - заменит значение на новое. Допускает значение ключа null. Не потокобезопасен. Содержит только
  уникальные ключи.
+ ***LinkedHashMap*** - класс, который расширяет HashMap и хранит элементы в порядке их вставки. Поиск элементов в
  LinkedHashMap происходит чуть медленнее, чем в HashMap, но можно обеспечить итерацию элементов в порядке, в котором
  они были добавлены. Не потокобезопасен.
+ ***TreeMap*** - класс, основанный на структуре красно-черного дерева, который хранит элементы в отсортированном
  порядке по ключу. По умолчанию сортировка по принципу naturalOrder. Порядок сортировки задается c использованием
  Comparator. Поиск элементов в TreeMap выполняется за время log(n).
+ ***ConcurrentHashMap*** - класс, аналогичный HashMap, но с многопоточной поддержкой. Он обеспечивает безопасную работу
  с коллекцией в многопоточной среде.

На вершине иерархии Java Collection Framework находятся 2 интерфейса: Collection и Map. Они разделяют все коллекции,
входящие в фреймворк, на 2 части по типу хранения данных: простые последовательные наборы элементов, и набор пар
«ключ-значение».
Интерфейс Collection является базовым для всех коллекций, он расширяет интерфейс Iterable поэтому все объекты коллекций
можно перебирать в улучшенном цикле for. У интерфейса Iterable определен только один метод iterator(). Таким образом все
наследники Collection обязаны вернуть итератор. Итератор – это объект, который абстрагирует
за единым интерфейсом доступ к элементам коллекции. К тому же итератор – это паттерн, который позволяет получить доступ
к элементам любой коллекции без необходимости вникать в суть его реализации.

[К оглавлению](#CollectionsLite)

# 6. Назовите основные классы, которые реализуют интерфейсы List Set Map.

**1) Структура данных:**
+ ArrayList - реализован на динамическом массиве.
+ LinkedList - двусвязный список.

**2) Вставка и удаление элементов**
+ ArrayList - медленная, так как при этом может потребоваться перемещение всех элементов после вставленного или удаленного элемента.
+ LinkedList - быстрее, так как достаточно изменить ссылки на предыдущий и следующий элементы, не требуя перемещения всех элементов.

**3) Итерация по элементам:**
+ При итерации по элементам ArrayList быстрее, так как доступ к элементам по индексу работает быстро.
+ При итерации по элементам LinkedList может быть медленнее из-за линейной сложности доступа к элементам.

**4) Использование памяти:**
+ ArrayList требует больше памяти, так как он выделяет фиксированный кусок памяти для хранения элементов, который может быть увеличен, если размер структуры данных увеличивается.
+ LinkedList требует меньше памяти, так как каждый элемент хранит ссылки только на предыдущий и следующий элементы.

**5) Применение:**
+ ArrayList - для быстрого доступа по индексу в малоизменяемых списках.
+ LinkedList - для частых вставок и удалений элементов и малом числе поиска элементов.

[К оглавлению](#CollectionsLite)

# 8. В чем отличие HashSet от TreeSet?

**1) Структура данных:**
+ HashSet - хэш-таблица.
+ TreeSet - красно-черное дерево.

**2) Упорядоченность элементов:**
+ TreeSet - хранит элементы в отсортированном порядке (в соответствии с их естественным порядком или с использованием Comparator).
+ HashSet - порядок не гарантирован и может меняться.

**3) Производительность операций:**
+ TreeSet обеспечивает логарифмическую производительность для операций добавления, удаления и поиска элемента (O(log n)).
+ HashSet производительность для операций добавления, удаления и поиска элемента в среднем константная (O(1)). Однако, в худшем случае производительность HashSet может быть линейной (O(n)) из-за коллизий.

**4) Использование памяти:**
+ TreeSet требует больше памяти для хранения элементов из-за дополнительных структур данных, необходимых для хранения красно-чёрного дерева.
+ HashSet требует меньше памяти.

**5) Поддержка нулевого значения:**
+ TreeSet не позволяет хранить значения null.
+ HashSet позволяет хранить null элементы.

**6) Использование:**
+ TreeSet - если необходимо хранить элементы в отсортированном порядке и производительность операций не является критической.
+ HashSet - если требуется быстрое добавление, удаление и поиск элементов.


[К оглавлению](#CollectionsLite)

# 9. В чем отличие Set от Map?

**1) Структура данных:**
+ Set - коллекцию уникальных элементов без какого-либо определенного порядка.
+ Map - коллекция "пар ключ-значение", где каждый ключ уникален.

**2) Скорость:**
+ Set - при поиске будет перебирать на соответствие.
+ Map - прямой доступ по ключу.

**3) Добавление дубликатов:**
+ Set - проигнорирует добавление дубликата.
+ Map - перезапишет значение по ключу-дубликату.

**4) Использование:**
+ Set - когда нужно хранить уникальные значения.
+ Map - когда нужно хранить пары "ключ-значение" и получать доступ к значению по ключу.


[К оглавлению](#CollectionsLite)

# 10. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?

Порядок следования объектов в коллекции в Java зависит от типа коллекции. Например, объекты в ArrayList хранятся в порядке их добавления, а объекты в TreeSet хранятся в отсортированном порядке.

[К оглавлению](#CollectionsLite)

# 11. Чем отличается Comparable от Comparator?

Comparable - используется только для сравнения объектов класса, в котором данный интерфейс реализован. Т.е. интерфейс
Comparable определяет логику сравнения объектов определенного ссылочного типа внутри своей реализации (по правилам
разработчика). Collections.sort(collection);

Comparator - представляет отдельную реализацию и ее можно использовать многократно и с различными классами. Т.е.
интерфейс Comparator позволяет создавать объекты, которые будут управлять процессом сравнения:

- при сортировках в методах Collections.sort(collection, new MyComparator()), Arrays.sort(array, new MyComparator()) или
  collection.sort(new MyComparator())
- при управлении порядком в отсортированных множествах TreeSet или отсортированных картах TreeMap, например new
  TreeSet<T> (new MyComparator()).

Отличия: Comparable определяет логику сравнения объектов определенного ссылочного типа внутри своей реализации и, если
нет
доступа к исходникам, ее невозможно изменить.
Comparator позволяет определить логику сравнения объектов определенного ссылочного типа вне реализации этого типа и эту
логику можно в любой момент изменить.
Comparable используется для сортировки по возрастанию, а Comparator для сортировки по убыванию.

[К оглавлению](#CollectionsLite)

# 12. Что такое сортировка по принципу Natural Order?

Значения располагаются от меньшего к большему.

[К оглавлению](#CollectionsLite)

# 13. Что такое equals и hashcode?

Методы, необходимые для определения равенства объектов. Метод equals сравнивает два объекта на равенство. Если результат
сравнения равен true, это означает, что два объекта равны.
Метод hashcode используется для определения местоположения объекта в хэш-таблице. Если два объекта имеют одинаковый
хэш-код, то вызывается метод equals для сравнения двух объектов.
Если не переопределить метод equals, он будет сравнивать ссылки на объекты. Если вы переопределите этот
метод, вы должны также переопределить метод hashCode, чтобы обеспечить корректную работу хэш-таблицы.

[К оглавлению](#CollectionsLite)

# 14. Какие есть способы перебора всех элементов List?

- через index (fori, while)
```java
        for(int i=0;i<countries.size();i++){
        System.out.println(countries.get(i));
        }
```

```java
        int i=0;
        while(i<countries.size()){
        System.out.println(countries.get(i++));
        }
```

- через iterator (while)
```java
Iterator<String> countriesIterator=countries.iterator();
        while(countriesIterator.hasNext()){
        System.out.println(countriesIterator.next());
        }
```

```java
ListIterator<String> listIterator=countries.listIterator();
//в прямом порядке
        while(listIterator.hasNext()){
        System.out.println(listIterator.next());
        }
//в обратном порядке
        while(listIterator.hasPrevious()){
        System.out.println(listIterator.previous());
        }    
```

- foreach
```java
        for(String country:countries){
        System.out.println(country);
        }    
```

[К оглавлению](#CollectionsLite)

# 15. Расскажите о методах Map.
V put(K key, V value); - вставит данные в карту.

V get(K key); - получить значение по ключу.

Пару можно обновить тем же методом, что и вставить.
Ключ пары должен быть уникальный. Если в Map уже есть такой key,
то ячейка value будет заменена на новое значение.

remove(key) — удаляет элемент с указанным ключом из карты. Если ключ отсутствует, исключение не выбрасывается.

keySet(), values() и entrySet() — возвращают соответственно набор ключей, значений и пар ключ-значение в карте.

containsKey(key) и containsValue(value) — проверяют, содержит ли карта указанный ключ или значение.

clear() — удаляет все элементы из карты.

size() — возвращает количество элементов в карте.

isEmpty() — проверяет, пуста ли карта.

[К оглавлению](#CollectionsLite)

# 16. Расскажите, какие классы реализовывают интерфейс Map?
- ***HashMap*** - хэш-таблица, самая распространенная и широко используемая реализация интерфейса Map. Она основана на хэш-таблицах и предоставляет эффективный доступ к элементам по ключу. HashMap позволяет хранить значения в виде пар ключ-значение и обеспечивает доступ к ним за константное время в среднем случае.
- ***LinkedHashMap*** - класс, который расширяет функциональность HashMap, сохраняя порядок добавления элементов. LinkedHashMap предоставляет доступ к элементам в порядке их добавления или последнего доступа. Это может быть полезно, если важен порядок элементов или нужно управлять итерацией по коллекции.
- ***TreeMap*** - класс, реализующий интерфейс Map с использованием красно-черного дерева. TreeMap хранит элементы в отсортированном порядке по ключу. Поиск, добавление и удаление элементов в TreeMap происходит за время O(log n), что делает его эффективным выбором для приложений, требующих отсортированные данные.
- ***HashTable*** - устаревшая версия HashMap, синхронизированная версия.
- ***ConcurrentHashMap*** - реализация интерфейса Map, оптимизированная для многопоточных приложений. ConcurrentHashMap обеспечивает безопасный доступ к элементам коллекции из нескольких потоков, минимизируя блокировки с помощью распределения данных по сегментам. Это делает ConcurrentHashMap подходящим выбором для параллельных вычислений.
- ***EnumMap*** - перечисления в качестве ключей, благодаря чему - высокая производительность.
- ***IdentityMap*** - сравнивает ключи по `==` вместо `equals()`. Полезна в случае, когда требуется точное сравнение объектов по их ссылке.

[К оглавлению](#CollectionsLite)

# 17. Расскажите о методах keySet и entrySet? Что такое Entry?
Интерфейс `Map` в Java предоставляет два ключевых метода для работы с ключами и парами ключ-значение: `keySet()` и `entrySet()`.

1. Метод `keySet()`:

+ Возвращает: `Set` объектов, которые представляют ключи всех записей в `Map`.
+ Использование: Используется, когда нужно получить доступ к ключам `Map` и выполнить операции, не связанные с значениями.

Пример:

```java
Map<String, Integer> ages = new HashMap<>();
ages.put("Alice", 25);
ages.put("Bob", 30);
ages.put("Charlie", 28);

Set<String> keys = ages.keySet();
System.out.println("Keys: " + keys); // Keys: [Bob, Alice, Charlie]

for (String key : keys) {
    System.out.println(key);
}
//Bob
//Alice
//Charlie

```

2. Метод `entrySet()`:

+ Возвращает: `Set` объектов типа `Map.Entry`, который представляет собой пару ключ-значение.
+ Использование: Используется, когда нужно получить доступ как к ключам, так и к значениям `Map` одновременно.

Пример:

```java
Map<String, Integer> ages = new HashMap<>();
ages.put("Alice", 25);
ages.put("Bob", 30);
ages.put("Charlie", 28);

Set<Map.Entry<String, Integer>> entries = ages.entrySet();
System.out.println("Entries: " + entries); //Entries: [Bob=30, Alice=25, Charlie=28]

for (Map.Entry<String, Integer> entry : entries) {
    System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
}
//Key: Bob, Value: 30
//Key: Alice, Value: 25
//Key: Charlie, Value: 28
```

Ключевые моменты:

+ `Set` гарантирует, что ключи (или пары ключ-значение) не будут дублироваться.
+ Методы `keySet()` и `entrySet()` возвращают неизменяемые представления `Map`. Изменения в полученных `Set` не повлияют на исходную `Map`.
+ Используйте `keySet()` для работы только с ключами.
+ Используйте `entrySet()` для работы с ключами и значениями одновременно.

Преимущества:

+ Предоставляют удобный способ получить доступ к ключам и значениям `Map`.
+ Обеспечивают удобную итерацию по элементам `Map`.
+ Упрощают манипуляции с элементами `Map`.

Дополнительная информация:

+ Интерфейс `Map` также предоставляет метод `values()`, который возвращает `Collection` всех значений `Map`.
+ Методы `keySet()`, `entrySet()` и `values()` возвращают только представления `Map`, а не её копии.
+ Операции модификации на полученных `Set` или `Collection` могут привести к непредсказуемому поведению.

Entry в `Map` - это пара "ключ-значение". Ключ - это уникальный идентификатор для элемента в `Map`. Он используется для доступа к соответствующему значению. Значение - это фактическая информация, связанная с ключом.

Пример: представьте, что у вас есть `Map`, которая хранит информацию о студентах. Ключом может быть номер студенческого билета, а значением - имя студента.

```java
Map<Integer, String> студенты = new HashMap<>();

студенты.put(12345, "Иван Иванов");
студенты.put(67890, "Мария Петрова");
```

В этом случае, `(12345, "Иван Иванов")` и `(67890, "Мария Петрова")` - это entries в `Map`.

Методы для работы с entries:

+ `entrySet()`: Возвращает набор всех `entries` в `Map`.
+ `containsKey(Object key)`: Проверяет, существует ли ключ в `Map`.
+ `containsValue(Object value)`: Проверяет, существует ли значение в `Map`.
+ `get(Object key)`: Возвращает значение, соответствующее заданному ключу.
+ `put(K key, V value)`: Добавляет или обновляет `entry` в `Map`.
+ `remove(Object key)`: Удаляет `entry` с заданным ключом из `Map`.

Использование `entries`: `еntries` в `Map` используются для хранения и извлечения данных, где для каждой записи есть уникальный ключ, который позволяет быстро и эффективно найти соответствующее значение.

[К оглавлению](#CollectionsLite)

# 18. Что будет если вызвать метод put несколько раз с одинаковым ключом?
В этом случае будет сохраняться последний добавленный элемент с данным ключом.

[К оглавлению](#CollectionsLite)

# 19. Как реализован цикл foreach?
кл `foreach` в Java не является самостоятельным оператором, а является синтаксическим сахаром для итерации по элементам итерабельных объектов (реализующих интерфейс `Iterable`).

1. Итерабельный объект:

Цикл `foreach` работает с объектами, реализующими интерфейс `Iterable`.  Этот интерфейс определяет единственный метод:

```java
Iterator<T> iterator();
```

Этот метод возвращает объект `Iterator`, который позволяет перебирать элементы итерабельного объекта.

2. Iterator:

Класс `Iterator` предоставляет следующие методы:

+ `hasNext()`: Возвращает `true`, если в итераторе есть следующий элемент.
+ `next()`: Возвращает следующий элемент итерации.
+ `remove()`: Удаляет последний элемент, возвращенный методом `next()`. (Необязательный метод)

3. Реализация цикла `foreach`:

Компилятор Java преобразует цикл `foreach` в код, использующий итератор. Пример:

```java
for (int number : numbers) { 
    System.out.println(number);
}
```

Этот код будет преобразован в:

```java
Iterator<Integer> iterator = numbers.iterator();
while (iterator.hasNext()) {
    int number = iterator.next();
    System.out.println(number);
}
```

4. Процесс итерации:

+ Цикл `foreach` вызывает метод `iterator()` на итерабельном объекте.
+ Он получает объект `Iterator` и использует его для перебора элементов.
+ Метод `hasNext()` используется для проверки, есть ли следующий элемент.
+ Если есть, метод `next()` возвращает следующий элемент.
+ Элемент присваивается переменной в цикле `foreach`.
+ Тело цикла `foreach` выполняется.
+ Процесс повторяется, пока `hasNext()` не вернет `false`.

5.  Преимущества цикла `foreach`:

+ Простой синтаксис: Более простой и читаемый код, чем использование обычных циклов `for`.
+ Безопасность:  Избегает ошибок, связанных с индексами.
+ Универсальность: Работает с любым итерабельным объектом.

6. Ограничения:

+ Невозможность изменения коллекции во время итерации: изменение коллекции (добавление или удаление элементов) во время итерации может привести к ошибкам.
+ Невозможность доступа к индексу элементов:  если вам нужен доступ к индексу элемента, необходимо использовать обычный цикл `for`.

[К оглавлению](#CollectionsLite)

# 20. В чем разница между Iterator и Iterable?
***Iterable:***

Определение: интерфейс, который определяет, что объект может быть итерирован (пройден в цикле). Простыми словами - определяет, что объект можно итерировать

Метод: имеет единственный метод `iterator()`, который возвращает объект `Iterator`.

Пример: класс `ArrayList` реализует интерфейс `Iterable`, что позволяет нам использовать цикл `for-each` для итерации по элементам списка.

***Iterator:***

Определение: интерфейс, который обеспечивает механизм для итерации по элементам коллекции.

Методы:
+ `hasNext()`: Возвращает `true`, если в коллекции есть еще элементы для итерации.
+ `next()`: Возвращает следующий элемент в коллекции.
+ `remove()`: Удаляет последний элемент, возвращенный методом `next()`.

Пример:  мы используем `Iterator` для итерации по коллекции и управления итерацией. Простыми словами - предоставляет механизм для итерации.

```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class Main {

    public static void main(String[] args) {

        List<String> names = new ArrayList<>();
        names.add("Alice");
        names.add("Bob");
        names.add("Charlie");

        // Using Iterable
        for (String name : names) {
            System.out.println(name);
        }

        // Using Iterator
        Iterator<String> iterator = names.iterator();
        while (iterator.hasNext()) {
            String name = iterator.next();
            System.out.println(name);
        }
    }
}
```
[К оглавлению](#CollectionsLite)

# 21. Как происходит удаление элементов из ArrayList?
Находится заданный элемент. Далее сдвигаются влево на один элемент все последующие (с большим индексом) элементы, а
значение size уменьшается на 1.

```java
        System.arraycopy(es,i+1,es,i,newSize-i)
        es[size=newSize]=null;
```

[К оглавлению](#CollectionsLite)

# 22. Как происходит удаление элементов из LinkedList?
Заменяются ссылки previous и next у соседних элементов.

[К оглавлению](#CollectionsLite)

# 23. Что такое авто упаковка и распаковка? Зачем они нужны?
Автоупаковка - это автоматическая инкапсуляция примитивного типа в эквивалентную ему класс-обёртку всякий раз, когда
требуется объект данного типа. Происходит:

- при присвоении значения примитивного типа переменной соответствующего класса-обёртки.
- при передаче примитивного типа в параметр метода, ожидающего соответствующий ему класс-обёртку.

Автораспаковка - это преобразование класса-обёртки в соответствующий ему примитивный тип. Если при распаковке
класс-обёртка был равен null, произойдет исключение java.lang.NullPointerException. Происходит:

- при присвоении экземпляра класса-обёртки переменной соответствующего примитивного типа.
- в выражениях, в которых один или оба аргумента являются экземплярами классов-обёрток (кроме операции == и !=).
- при передаче объекта класса-обёртки в метод, ожидающий соответствующий примитивный тип.

Автоупаковка и распаковка очень часто происходит при работе с коллекциями, так как они не могут хранить примитивные типы
данных.

[К оглавлению](#CollectionsLite)

# 24. В каком случае при работе с упакованными значениями может возникнуть проблема с производительностью?
Появление классов-обёрток обусловлено тем, что Java - это объектно-ориентированный язык, и все сущности в идеале должны
быть объектами. Но отказавшись от примитивных типов, упала бы производительность, поэтому к существующим примитивным
типам добавили соответствующие классы-обертки, тем самым обеспечив гибкость работы с примитивными значениями.
Классы-обертки являются неизменяемыми, поэтому упакованное значение невозможно изменить. Для очень трудоёмких
вычислений, где производительность критически важна, следует использовать примитивные типы.

[К оглавлению](#CollectionsLite)

# 25. Опишите недостатки и преимущества в использовании примитивных типов и классов-оберток.
- при работе с примитивными типами повышается производительность, так как на упаковку значения в обёртку уходит
  дополнительное время.
- примитивные типы занимают меньше места в памяти.
- если в программе работа идет с объектами, а не со значениями, то работать с примитивными типами будет нельзя,
  понадобится упаковка.
- обёртки - это такие же классы со своими методами, как и любые остальные, которые мы рассматривали. Поэтому работа
  со значением в виде объекта даёт преимущества в виде возможности применения методов этих классов. (Например, для
  Integer это parseInt(), valueOf(), compareTo() и т.д.).

[К оглавлению](#CollectionsLite)

# 26. Что такое очередь? Расскажите принцип работы и для чего она используется.
Очередь используется для вставки элементов в конец очереди и удаления из начала очереди. Такой способ организации
хранения
данных называется FIFO(First-In-First-Out). Очередь – очень удобный инструмент, который используется для моделирования
реальных ситуаций ожидания клиентов в банке,
вылета самолетов или передачи данных по Интернету.

[К оглавлению](#CollectionsLite)

# 27. Расскажите про интерфейсы Queue, Deque и их иерархию.
Queue - это интерфейс, который представляет собой очередь, то есть структуру данных, где элементы добавляются в один
конец и удаляются из другого конца. Он реализует методы add() и remove(), а также contains(Object),
iterator() и size().

Deque (Double-ended queue) - это двунаправленная очередь, которая позволяет добавлять и удалять элементы с обоих концов.
Он расширяет интерфейс Queue и добавляет дополнительные методы, такие как addFirst(), removeFirst(), addLast() и
removeLast().
Иерархия этих интерфейсов выглядит следующим образом:`Collection -> Queue -> Deque`Т.е. Queue является
подклассом интерфейса Collection, а Deque - подклассом Queue.

[К оглавлению](#CollectionsLite)

# 28. В чем отличие метода poll() от remove()?
Оба метода позволяют удалить верхний элемент из очереди. Отличия в них видны, когда мы применяем эти методы на пустой очереди.
poll() - возвращает null.
remove() - генерирует исключение NoSuchElementException.

[К оглавлению](#CollectionsLite)

# 29. В чем отличие метода element() от peek()?
Оба метода позволяют вернуть первый элемент из очереди без его удаления.
Отличия в них видны, когда мы применяем эти методы на пустой очереди.
element() - генерирует исключение NoSuchElementException.
peek() - возвращает null.

[К оглавлению](#CollectionsLite)

# 30. В чем отличие метода element() от poll()?
element() возвращает (но не удаляет) первый элемент очереди. Если очередь пуста, выбрасывает исключение NoSuchElementException.
poll() возвращает и удаляет первый элемент очереди. Возвращает null, если очередь пуста.

[К оглавлению](#CollectionsLite)

# 31. Перечислите наиболее часто используемые реализации интерфейса Queue.
LinkedList, ArrayBlockingQueue и PriorityQueue —
наиболее часто используемые реализации интерфейса Queue.

[К оглавлению](#CollectionsLite)

# 32. Что такое ограниченные и неограниченные очереди?

Очереди, доступные в пакете java.util, являются неограниченными очередями - это те очереди, которые не имеют
фиксированного размера.Они могут увеличиваться по мере необходимости до тех пор, пока позволяет память.(LinkedList,
ConcurrentLinkedQueue)

Очереди, доступные в пакете java.util.concurrent, являются ограниченными очередями -это очереди, которые имеют
фиксированный размер. Когда размер очереди достигает своего предела, попытки добавить новые элементы могут блокироваться
или приводить к исключениям в зависимости от реализации.(ArrayBlockingQueue, LinkedBlockingQueue)

[К оглавлению](#CollectionsLite)

# 33. Что такое односторонние и двусторонние очереди?
Односторонняя очередь, это такая очередь, в которую элементы могут быть добавлены\удалены только в одном направлении.
Двухсторонняя очередь, это такая очередь, в которую элементы могут быть добавлены\удалены в двух направлениях.

[К оглавлению](#CollectionsLite)

# 34. В чем отличие Deque от Queue?
Queue реализует одностороннюю очередь,
такая очередь позволяет поместить элементы в один конец очереди,
а извлекать их – из другого.

Deque расширяет интерфейс Queue.
Этот интерфейс также является очередью, но ее отличительной особенностью то,
что эта очередь является двухсторонней, т.е. она поддерживает удаление
и добавление элементов с обоих концов очереди.

Таким образом, в отличие от Queue, здесь также можно организовать способ
хранения элементов по принципу LIFO (сокращение по первой букве
от описания этого принципа на английском языке Last In First Out
– последний пришел, первый вышел
Такую структуру данных в программировании называют стеком.

Пример аналогии из жизни – стопка тетрадей на проверку у учителя,
учитель проверяет их по порядку и та тетрадь, которая была положена
в эту стопку первой будет проверена последней.
(или стопка тарелок)

[К оглавлению](#CollectionsLite)

# 35. В чем отличие методов removeLast() и pollLast()?
Методы удаляют первый элемент из очереди с его возвратом. Первый сгенерирует исключение при пустой очереди, второй –
вернет null.

[К оглавлению](#CollectionsLite)

# 36. Назовите самую распространенную реализацию Deque.
Наиболее часто используемой реализацией интерфейса Deque является класс LinkedList.
LinkedList реализует интерфейс Deque, Deque наследует интерфейс Queue со всеми его методами. Следовательно,
при создании объекта LinkedList можно использовать оба базовых типа указанных интерфейсов 
следующие обе строки кода будут работать без проблем:

Queue<String> queue = new LinkedList<>();

Deque<String> deque = new LinkedList<>();

В этом и есть одно из самых ярких проявлений полиморфизма – вместо того,
чтобы слева от знака присваивания ставить конкретный класс,
мы используем интерфейс и, следовательно, можем использовать методы,
определенные в нем, а также всех вышестоящих по иерархии интерфейсов.
Таким образом, разница в этих записях в том, что для первой строки будут
доступны только методы интерфейса Queue и всех вышестоящих интерфейсов
(Collection и Iterable). Для второй строки – будут добавлены все методы,
которые определены в интерфейсе Deque.

[К оглавлению](#CollectionsLite)