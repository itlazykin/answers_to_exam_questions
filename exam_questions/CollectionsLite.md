## CollectionsLite

[1. Что такое "коллекция".](#1-что-такое-коллекция)

[2. Перечислите основные методы из интерфейса Collection.](#2-Перечислите-основные-методы-из-интерфейса-Collection)

[3. Назовите преимущества использования коллекций по сравнению с массивами.](#3-Назовите-преимущества-использования-коллекций-по-сравнению-с-массивами)

[4. Какие данные могут хранить коллекции?](#4-Какие-данные-могут-хранить-коллекции)

[5. Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций.](#5-Какие-есть-типы-коллекций-Как-они-характеризуются-Расскажите-про-иерархию-коллекций)

[6. Назовите основные классы, которые реализуют интерфейсы List Set Map](#6-Назовите-основные-классы-которые-реализуют-интерфейсы-List-Set-Map)

[7. В чем отличие ArrayList от LinkedList?](#7-В-чем-отличие-ArrayList-от-LinkedList)

[8. В чем отличие HashSet от TreeSet?](#8-В-чем-отличие-HashSet-от-TreeSet)

[9. В чем отличие Set от Map?](#9-В-чем-отличие-Set-от-Map)

[10. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?](#10-Как-задается-порядок-следования-объектов-в-коллекции-как-отсортировать-коллекцию)

[11. Чем отличается Comparable от Comparator?](#11-Чем-отличается-Comparable-от-Comparator)

[12. Что такое сортировка по принципу Natural Order?](#12-Что-такое-сортировка-по-принципу-Natural-Order)

[13. Что такое equals и hashcode?](#13-Что-такое-equals-и-hashcode)

[14. Какие есть способы перебора всех элементов List?](#14-Какие-есть-способы-перебора-всех-элементов-List)

[15. Расскажите о методах Map.](#15-Расскажите-о-методах-Map)

[16. Расскажите, какие классы реализовывают интерфейс Map?](#16-Расскажите-какие-классы-реализовывают-интерфейс-Map)

[17. Расскажите о методах map.keySet и map.entrySet? Что такое Entry?](#17-Расскажите-о-методах-keySet-и-entrySet-Что-такое-Entry)

[18. Что будет если вызвать метод put несколько раз с одинаковым ключом?](#18-Что-будет-если-вызвать-метод-put-несколько-раз-с-одинаковым-ключом)

[19. Как реализован цикл foreach?](#19-Как-реализован-цикл-foreach)

[20. В чем разница между Iterator и Iterable?](#20-В-чем-разница-между-Iterator-и-Iterable)

[21. Как происходит удаление элементов из ArrayList?](#21-Как-происходит-удаление-элементов-из-ArrayList)

[22. Как происходит удаление элементов из LinkedList?](#22-Как-происходит-удаление-элементов-из-LinkedList)

[23. Что такое авто упаковка и распаковка? Зачем они нужны?](#23-Что-такое-авто-упаковка-и-распаковка-Зачем-они-нужны)

[24. В каком случае при работе с упакованными значениями может возникнуть проблема с производительностью?](#24-В-каком-случае-при-работе-с-упакованными-значениями-может-возникнуть-проблема-с-производительностью)

[25. Опишите недостатки и преимущества в использовании примитивных типов и классов-оберток.](#25-Опишите-недостатки-и-преимущества-в-использовании-примитивных-типов-и-классов-оберток)

[26. Что такое очередь? Расскажите принцип работы и для чего она используется.](#26-Что-такое-очередь-Расскажите-принцип-работы-и-для-чего-она-используется)

[27. Расскажите про интерфейсы Queue, Deque и их иерархию.](#27-Расскажите-про-интерфейсы-Queue-Deque-и-их-иерархию)

[28. В чем отличие метода poll() от remove()?](#28-В-чем-отличие-метода-poll-от-remove)

[29. В чем отличие метода element() от peek()?](#29-В-чем-отличие-метода-element-от-peek)

[30. В чем отличие метода element() от poll()?](#30-В-чем-отличие-метода-element-от-poll)

[31. Перечислите наиболее часто используемые реализации интерфейса Queue.](#31-Перечислите-наиболее-часто-используемые-реализации-интерфейса-Queue)

[32. Что такое ограниченные и неограниченные очереди?](#32-Что-такое-ограниченные-и-неограниченные-очереди)

[33. Что такое односторонние и двусторонние очереди?](#33-Что-такое-односторонние-и-двусторонние-очереди)

[34. В чем отличие Deque от Queue?](#34-В-чем-отличие-Deque-от-Queue)

[35. В чем отличие методов removeLast() и pollLast()?](#35-В-чем-отличие-методов-removeLast-и-pollLast)

[36. Назовите самую распространенную реализацию Deque.](#36-Назовите-самую-распространенную-реализацию-Deque)

# 1. Что такое "коллекция".

Это иерархия интерфейсов и реализаций, которая является частью JDK и позволяет программистам пользоваться большим
количеством структур для хранения набора данных. Java предоставляет различные реализации коллекций, такие как ArrayList,
LinkedList, HashMap, TreeSet и другие. Выбор конкретной коллекции зависит от требований приложения и того, как данные
будут использоваться.

[К оглавлению](#CollectionsLite)

# 2. Перечислите основные методы из интерфейса Collection.

Главным набором методов, который важен при рассмотрении любой коллекции является набор CRUD-операций (create, read,
update, delete). На уровне Collection не существует способа обновить запись в коллекции

- add(Object o) - добавляет элемент в коллекцию.
- iterator() - возвращает итератор для перебора элементов коллекции.
- remove(Object o) - удаляет элемент из коллекции.
- contains(Object o) - проверяет, есть ли элемент в коллекции.
- size() - возвращает количество элементов в коллекции.
- clear() - очищает коллекцию (удаляет все элементы).
- toArray() - возвращает массив, содержащий все элементы коллекции
- 
  [К оглавлению](#CollectionsLite)

# 3. Назовите преимущества использования коллекций по сравнению с массивами.

- отсутствует необходимость следить за размерами коллекции (в отличие от массива).
- позволяют сократить количество кода и требуют меньше усилий для реализации, т.к. в коллекциях реализовано много
  методов по добавлению, удалению, сортировке элементов и т.п.
- если правильно подобрать коллекцию, то можно увеличить производительность программы.
- 
  [К оглавлению](#CollectionsLite)

# 4. Какие данные могут хранить коллекции?

Любые ссылочные типы данных.

[К оглавлению](#CollectionsLite)

# 5. Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций.

На вершине иерархии Java Collection Framework находятся 2 интерфейса: Collection и Map. Они разделяют все коллекции,
входящие в фреймворк, на 2 части по типу хранения данных: простые последовательные наборы элементов, и набор пар
«ключ-значение».
Интерфейс Collection является базовым для всех коллекций, он расширяет интерфейс Iterable поэтому все объекты коллекций
можно перебирать в улучшенном цикле for. У интерфейса Iterable определен только один метод iterator(). Таким образом все
наследники Collection обязаны вернуть итератор. Итератор – это объект, который абстрагирует
за единым интерфейсом доступ к элементам коллекции. К тому же итератор – это паттерн, который позволяет получить доступ
к элементам любой коллекции без необходимости вникать в суть его реализации.

- List - реализации этого интерфейса представляют собой упорядоченные коллекции. Кроме того, разработчику
  предоставляется возможность доступа к элементам коллекции по индексу и по значению (так как реализации позволяют
  хранить дубликаты, результатом поиска по значению будет первое найденное вхождение).
- Set - множество. Set не допускает хранение двух одинаковых элементов.
- Map - карта, ассоциативный массив (значения хранятся в виде пар ключ-значение. Каждому элементу из множества ключей
  соответствует множество значений. Ключи уникальные. По ключу получаем значение. У мапы нет итератора. Мап не
  наследуется от Collection. У Map есть метод entrySet(), который возвращает Set с Entry-объектами (ключ и
  значение). Можно итерироваться по этому набору и получить доступ к ключу и значению каждой пары.)
- Queue (Deque) - интерфейс описывает коллекции с предопределённым способом вставки и извлечения элементов, а именно —
  очереди FIFO (first-in-first-out).

  [К оглавлению](#CollectionsLite)

# 6. Назовите основные классы, которые реализуют интерфейсы List Set Map.

- ArrayList, LinkedList, Vector - классы для хранения элементов в виде массива. Они реализуют интерфейс List.
- HashSet, LinkedHashSet, TreeSet - классы для хранения уникальных элементов. Они реализуют интерфейсы Set и SortedSet.
- HashMap, LinkedHashMap, TreeMap, ConcurrentHashMap - классы для хранения пар ключ-значение. Они реализуют интерфейс
  Map и его наследников.
- 
  [К оглавлению](#CollectionsLite)

# 7. В чем отличие ArrayList от LinkedList?

- ArrayList использует массив для хранения элементов, и когда требуется добавить новый элемент, он увеличивает размер
  массива. Это делает добавление элементов быстрым, но удаление элементов из середины списка может быть медленным, так
  как
  необходимо переместить все элементы после удаляемого.

- LinkedList использует связные списки для хранения элементов. Каждый элемент содержит ссылку на следующий и предыдущий
  элементы, что позволяет добавлять и удалять элементы из любого места списка быстро. Однако, поиск элементов может быть
  медленнее, так как требуется пройти по всему списку до нужного элемента.
- [К оглавлению](#CollectionsLite)

# 8. В чем отличие HashSet от TreeSet?

TreeSet обеспечивает упорядоченно хранение элементов в виде красно-черного дерева. Сложность выполнения основных
операций в TreeSet lg N. HashSet использует для хранения элементов такой же подход, что и HashMap, за тем отличием, что
в HashSet в качестве ключа выступает сам элемент, кроме того HashSet (как и HashMap) не поддерживает упорядоченное
хранение элементов и обеспечивает временную сложность выполнения операций аналогично HashMap.

[К оглавлению](#CollectionsLite)

# 9. В чем отличие Set от Map?

Set - расширяет интерфейс Collection, Map - не входит в иерархию. Set используется для хранения неупорядоченных
коллекций уникальных элементов, в то время как Map хранит пары
ключ-значение и позволяет быстро извлекать значение по ключу.

[К оглавлению](#CollectionsLite)

# 10. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?

Порядок задается либо естественным следованием элементов (natural order), либо объектом, реализующим интерфейс сравнения
Comparator. Если объекты коллекции поддерживают интерфейс Comparable, то через Collections.sort(collection).
Если нет, то у коллекции вызвать метод sort() и передать ему Comparator в качестве аргумента collection.sort(new
MyComparator()). Либо использовать метод Collections.sort(collection, new MyComparator()).

[К оглавлению](#CollectionsLite)

# 11. Чем отличается Comparable от Comparator?

Comparable - используется только для сравнения объектов класса, в котором данный интерфейс реализован. Т.е. интерфейс
Comparable определяет логику сравнения объектов определенного ссылочного типа внутри своей реализации (по правилам
разработчика). Collections.sort(collection);

Comparator - представляет отдельную реализацию и ее можно использовать многократно и с различными классами. Т.е.
интерфейс Comparator позволяет создавать объекты, которые будут управлять процессом сравнения:

- при сортировках в методах Collections.sort(collection, new MyComparator()), Arrays.sort(array, new MyComparator()) или
  collection.sort(new MyComparator())
- при управлении порядком в отсортированных множествах TreeSet или отсортированных картах TreeMap, например new
  TreeSet<T> (new MyComparator()).

Отличия: Comparable определяет логику сравнения объектов определенного ссылочного типа внутри своей реализации и, если
нет
доступа к исходникам, ее невозможно изменить.
Comparator позволяет определить логику сравнения объектов определенного ссылочного типа вне реализации этого типа и эту
логику можно в любой момент изменить.
Comparable используется для сортировки по возрастанию, а Comparator для сортировки по убыванию.

[К оглавлению](#CollectionsLite)

# 12. Что такое сортировка по принципу Natural Order?

Значения располагаются от меньшего к большему.

[К оглавлению](#CollectionsLite)

# 13. Что такое equals и hashcode?

Методы, необходимые для определения равенства объектов. Метод equals сравнивает два объекта на равенство. Если результат
сравнения равен true, это означает, что два объекта равны.
Метод hashcode используется для определения местоположения объекта в хэш-таблице. Если два объекта имеют одинаковый
хэш-код, то вызывается метод equals для сравнения двух объектов.
Если не переопределить метод equals, он будет сравнивать ссылки на объекты. Если вы переопределите этот
метод, вы должны также переопределить метод hashCode, чтобы обеспечить корректную работу хэш-таблицы.

[К оглавлению](#CollectionsLite)

# 14. Какие есть способы перебора всех элементов List?

- через index (fori, while)
```java
        for(int i=0;i<countries.size();i++){
        System.out.println(countries.get(i));
        }
```

```java
        int i=0;
        while(i<countries.size()){
        System.out.println(countries.get(i++));
        }
```

- через iterator (while)
```java
Iterator<String> countriesIterator=countries.iterator();
        while(countriesIterator.hasNext()){
        System.out.println(countriesIterator.next());
        }
```

```java
ListIterator<String> listIterator=countries.listIterator();
//в прямом порядке
        while(listIterator.hasNext()){
        System.out.println(listIterator.next());
        }
//в обратном порядке
        while(listIterator.hasPrevious()){
        System.out.println(listIterator.previous());
        }    
```

- foreach
```java
for(String country:countries){
        System.out.println(country);
        }    
```


[К оглавлению](#CollectionsLite)

# 15. Расскажите о методах Map.

[К оглавлению](#CollectionsLite)

# 16. Расскажите, какие классы реализовывают интерфейс Map?

[К оглавлению](#CollectionsLite)

# 17. Расскажите о методах keySet и entrySet? Что такое Entry?

[К оглавлению](#CollectionsLite)

# 18. Что будет если вызвать метод put несколько раз с одинаковым ключом?

[К оглавлению](#CollectionsLite)

# 19. Как реализован цикл foreach?

[К оглавлению](#CollectionsLite)

# 20. В чем разница между Iterator и Iterable?

[К оглавлению](#CollectionsLite)

# 21. Как происходит удаление элементов из ArrayList?

[К оглавлению](#CollectionsLite)

# 22. Как происходит удаление элементов из LinkedList?

[К оглавлению](#CollectionsLite)

# 23. Что такое авто упаковка и распаковка? Зачем они нужны?

[К оглавлению](#CollectionsLite)

# 24. В каком случае при работе с упакованными значениями может возникнуть проблема с производительностью?

[К оглавлению](#CollectionsLite)

# 25. Опишите недостатки и преимущества в использовании примитивных типов и классов-оберток.

[К оглавлению](#CollectionsLite)

# 26. Что такое очередь? Расскажите принцип работы и для чего она используется.

[К оглавлению](#CollectionsLite)

# 27. Расскажите про интерфейсы Queue, Deque и их иерархию.

[К оглавлению](#CollectionsLite)

# 28. В чем отличие метода poll() от remove()?

[К оглавлению](#CollectionsLite)

# 29. В чем отличие метода element() от peek()?

[К оглавлению](#CollectionsLite)

# 30. В чем отличие метода element() от poll()?

[К оглавлению](#CollectionsLite)

# 31. Перечислите наиболее часто используемые реализации интерфейса Queue.

[К оглавлению](#CollectionsLite)

# 32. Что такое ограниченные и неограниченные очереди?

Очереди, доступные в пакете java.util, являются неограниченными очередями - это те очереди, которые не имеют
фиксированного размера.Они могут увеличиваться по мере необходимости до тех пор, пока позволяет память.(LinkedList,
ConcurrentLinkedQueue)

Очереди, доступные в пакете java.util.concurrent, являются ограниченными очередями -это очереди, которые имеют
фиксированный размер. Когда размер очереди достигает своего предела, попытки добавить новые элементы могут блокироваться
или приводить к исключениям в зависимости от реализации.(ArrayBlockingQueue, LinkedBlockingQueue)

[К оглавлению](#CollectionsLite)

# 33. Что такое односторонние и двусторонние очереди?

[К оглавлению](#CollectionsLite)

# 34. В чем отличие Deque от Queue?

[К оглавлению](#CollectionsLite)

# 35. В чем отличие методов removeLast() и pollLast()?

[К оглавлению](#CollectionsLite)

# 36. Назовите самую распространенную реализацию Deque.

[К оглавлению](#CollectionsLite)