## CollectionsLite

[1. Что такое "коллекция".](#1-что-такое-коллекция)

[2. Перечислите основные методы из интерфейса Collection.](#2-Перечислите-основные-методы-из-интерфейса-Collection)

[3. Назовите преимущества использования коллекций по сравнению с массивами.](#3-Назовите-преимущества-использования-коллекций-по-сравнению-с-массивами)

[4. Какие данные могут хранить коллекции?](#4-Какие-данные-могут-хранить-коллекции)

[5. Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций.](#5-Какие-есть-типы-коллекций-Как-они-характеризуются-Расскажите-про-иерархию-коллекций)

[6. Назовите основные классы, которые реализуют интерфейсы List Set Map](#6-Назовите-основные-классы-которые-реализуют-интерфейсы-List-Set-Map)

[7. В чем отличие ArrayList от LinkedList?](#7-В-чем-отличие-ArrayList-от-LinkedList)

[8. В чем отличие HashSet от TreeSet?](#8-В-чем-отличие-HashSet-от-TreeSet)

[9. В чем отличие Set от Map?](#9-В-чем-отличие-Set-от-Map)

[10. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?](#10-Как-задается-порядок-следования-объектов-в-коллекции-как-отсортировать-коллекцию)

[11. Чем отличается Comparable от Comparator?](#11-Чем-отличается-Comparable-от-Comparator)

[12. Что такое сортировка по принципу Natural Order?](#12-Что-такое-сортировка-по-принципу-Natural-Order)

[13. Что такое equals и hashcode?](#13-Что-такое-equals-и-hashcode)

[14. Какие есть способы перебора всех элементов List?](#14-Какие-есть-способы-перебора-всех-элементов-List)

[15. Расскажите о методах Map.](#15-Расскажите-о-методах-Map)

[16. Расскажите, какие классы реализовывают интерфейс Map?](#16-Расскажите-какие-классы-реализовывают-интерфейс-Map)

[17. Расскажите о методах map.keySet и map.entrySet? Что такое Entry?](#17-Расскажите-о-методах-keySet-и-entrySet-Что-такое-Entry)

[18. Что будет если вызвать метод put несколько раз с одинаковым ключом?](#18-Что-будет-если-вызвать-метод-put-несколько-раз-с-одинаковым-ключом)

[19. Как реализован цикл foreach?](#19-Как-реализован-цикл-foreach)

[20. В чем разница между Iterator и Iterable?](#20-В-чем-разница-между-Iterator-и-Iterable)

[21. Как происходит удаление элементов из ArrayList?](#21-Как-происходит-удаление-элементов-из-ArrayList)

[22. Как происходит удаление элементов из LinkedList?](#22-Как-происходит-удаление-элементов-из-LinkedList)

[23. Что такое авто упаковка и распаковка? Зачем они нужны?](#23-Что-такое-авто-упаковка-и-распаковка-Зачем-они-нужны)

[24. В каком случае при работе с упакованными значениями может возникнуть проблема с производительностью?](#24-В-каком-случае-при-работе-с-упакованными-значениями-может-возникнуть-проблема-с-производительностью)

[25. Опишите недостатки и преимущества в использовании примитивных типов и классов-оберток.](#25-Опишите-недостатки-и-преимущества-в-использовании-примитивных-типов-и-классов-оберток)

[26. Что такое очередь? Расскажите принцип работы и для чего она используется.](#26-Что-такое-очередь-Расскажите-принцип-работы-и-для-чего-она-используется)

[27. Расскажите про интерфейсы Queue, Deque и их иерархию.](#27-Расскажите-про-интерфейсы-Queue-Deque-и-их-иерархию)

[28. В чем отличие метода poll() от remove()?](#28-В-чем-отличие-метода-poll-от-remove)

[29. В чем отличие метода element() от peek()?](#29-В-чем-отличие-метода-element-от-peek)

[30. В чем отличие метода element() от poll()?](#30-В-чем-отличие-метода-element-от-poll)

[31. Перечислите наиболее часто используемые реализации интерфейса Queue.](#31-Перечислите-наиболее-часто-используемые-реализации-интерфейса-Queue)

[32. Что такое ограниченные и неограниченные очереди?](#32-Что-такое-ограниченные-и-неограниченные-очереди)

[33. Что такое односторонние и двусторонние очереди?](#33-Что-такое-односторонние-и-двусторонние-очереди)

[34. В чем отличие Deque от Queue?](#34-В-чем-отличие-Deque-от-Queue)

[35. В чем отличие методов removeLast() и pollLast()?](#35-В-чем-отличие-методов-removeLast-и-pollLast)

[36. Назовите самую распространенную реализацию Deque.](#36-Назовите-самую-распространенную-реализацию-Deque)

# 1. Что такое "коллекция".

Коллекции в Java — это специализированные структуры данных, которые позволяют эффективно хранить и обрабатывать
множество объектов. Это иерархия интерфейсов и реализаций, которая является частью JDK и позволяет программистам
пользоваться большим
количеством структур для хранения набора данных. Java предоставляет различные реализации коллекций, такие как ArrayList,
LinkedList, HashMap, TreeSet и другие. Выбор конкретной коллекции зависит от требований приложения и того, как данные
будут использоваться.

[К оглавлению](#CollectionsLite)

# 2. Перечислите основные методы из интерфейса Collection.

Главным набором методов, который важен при рассмотрении любой коллекции является набор CRUD-операций (create, read,
update, delete). На уровне Collection не существует способа обновить запись в коллекции

- add(Object o) - добавляет элемент в коллекцию.
- iterator() - возвращает итератор для перебора элементов коллекции.
- remove(Object o) - удаляет элемент из коллекции.
- contains(Object o) - проверяет, есть ли элемент в коллекции.
- size() - возвращает количество элементов в коллекции.
- clear() - очищает коллекцию (удаляет все элементы).
- toArray() - возвращает массив, содержащий все элементы коллекции

[К оглавлению](#CollectionsLite)

# 3. Назовите преимущества использования коллекций по сравнению с массивами.

- отсутствует необходимость следить за размерами коллекции (в отличие от массива).
- позволяют сократить количество кода и требуют меньше усилий для реализации, т.к. в коллекциях реализовано много
  методов по добавлению, удалению, сортировке элементов и т.п.
- если правильно подобрать коллекцию, то можно увеличить производительность программы.

[К оглавлению](#CollectionsLite)

# 4. Какие данные могут хранить коллекции?

Любые ссылочные типы данных.

[К оглавлению](#CollectionsLite)

# 5. Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций.

![img](https://github.com/itlazykin/answers_to_exam_questions/blob/main/main/resources/Collections.png)

+ List - список.
+ Set - множество уникальных элементов.
+ Queue - очередь.
+ Map - пара "ключ - значение"

**Реализации List:**

+ ***ArrayList*** - это список, который реализован как массив. Это означает, что элементы в ArrayList хранятся в
  последовательном порядке и могут быть доступны по индексу. Основные характеристики ArrayList включают динамическое
  увеличение размера, высокую производительность при доступе к элементам по индексу и возможность изменения элементов.
  Применяется, когда в процессе работы предполагается частое обращение к элементам по индексу. Следует избегать, если
  предполагается частое добавление/удаление элементов в середину списка. Позволяет хранить любые значения, в том числе
  null. Не потокобезопасен.
+ ***LinkedList*** - это двусвязный список (можно использовать как стэк или очередь), в котором каждый элемент содержит
  ссылки на предыдущий и следующий элементы. Это означает, что вставка и удаление элементов в середине списка
  выполняются быстрее, чем в ArrayList. Однако доступ к элементам по индексу в LinkedList более медленный. Позволяет
  хранить любые значения, в том числе null. Не потокобезопасен.
+ ***Vector*** - похож на ArrayList. Синхронизирован. Содержит много устаревших методов, которые не являются частью
  структуры коллекций. Не рекомендуется использовать, если не требуется потокобезопасность.
+ ***Stack*** - это реализация стека, который представляет собой упорядоченный список элементов, где добавление и
  удаление элементов происходит в конце списка (LIFO - last in, first out). После добавления интерфейса Queue не
  рекомендуется к использованию.

Все эти коллекции реализуют интерфейс List, что означает, что они поддерживают операции добавления, удаления и доступа к
элементам по индексу.

**Реализации Queue:**

+ ***PriorityQueue*** - это класс, который реализует очередь с приоритетом. Он характеризуется тем, что элементы
  добавляются в очередь с учетом их приоритета и извлекаются в порядке возрастания или убывания приоритета.
  PriorityQueue может быть использована для реализации алгоритмов, таких как алгоритм Дейкстры или алгоритм сортировки
  слиянием. Не работает с null и non-comparable элементами. По умолчанию сортировка по принципу naturalOrder. Порядок
  сортировки задается c использованием Comparator. Не потокобезопасен.
+ ***LinkedList*** - это двусвязный список (можно использовать как стэк или очередь), в котором каждый элемент содержит
  ссылки на предыдущий и следующий элементы. Это означает, что вставка и удаление элементов в середине списка
  выполняются быстрее, чем в ArrayList. Однако доступ к элементам по индексу в LinkedList более медленный. Позволяет
  хранить любые значения, в том числе null. Не потокобезопасен.
+ ***ArrayDeque*** - это класс, который реализует двустороннюю очередь. Он характеризуется тем, что позволяет добавлять
  и удалять элементы как в начало, так и в конец очереди за O(1) времени. Также ArrayDeque имеет фиксированный размер и
  может быть использован как стек. Реализован с использованием массивов, однако не позволяет обращаться к элементам по
  индексу и хранить null.

В целом, все эти коллекции позволяют добавлять, извлекать и просматривать элементы в порядке их добавления или в
соответствии с определенным приоритетом.

**Реализации Set:**

+ ***HashSet*** - это наиболее распространенная реализация Set, основанная на хэш-таблице (что позволяет постоянство по
  времени на поиск, удаление и добавление элементов). Он не гарантирует порядок элементов при их добавлении. Не
  допускает дубликатов. Хранит только объекты (примитивы заворачивает в обертки). Не потокобезопасен.
+ ***LinkedHashSet*** - это реализация Set, которая поддерживает порядок элементов в том порядке, в котором они были
  добавлены (именно порядок вставки, а не значения элементов). Как и HashSet, она не допускает дублирования элементов.
  Постоянное время добавления, поиска и удаления элементов. Не потокобезопасен.
+ ***TreeSet*** - это реализация Set, которая хранит элементы в отсортированном порядке. Он использует красно-черное
  дерево для хранения элементов и гарантирует, что они будут отсортированы в естественном порядке (например, числа в
  возрастающем порядке, строки в алфавитном порядке). Не работает с null и non-comparable элементами. По умолчанию
  сортировка по принципу naturalOrder. Порядок сортировки задается c использованием Comparator.

**Реализации Map:**

+ ***HashMap*** - основанный на хэш-таблице класс, который обеспечивает постоянное время выполнения операций добавления,
  удаления и поиска элементов. Однако порядок элементов в HashMap не определен. При попытке вставить элемент по уже
  имеющемуся ключу - заменит значение на новое. Допускает значение ключа null. Не потокобезопасен. Содержит только
  уникальные ключи.
+ ***LinkedHashMap*** - класс, который расширяет HashMap и хранит элементы в порядке их вставки. Поиск элементов в
  LinkedHashMap происходит чуть медленнее, чем в HashMap, но можно обеспечить итерацию элементов в порядке, в котором
  они были добавлены. Не потокобезопасен.
+ ***TreeMap*** - класс, основанный на структуре красно-черного дерева, который хранит элементы в отсортированном
  порядке по ключу. По умолчанию сортировка по принципу naturalOrder. Порядок сортировки задается c использованием
  Comparator. Поиск элементов в TreeMap выполняется за время log(n).
+ ***ConcurrentHashMap*** - класс, аналогичный HashMap, но с многопоточной поддержкой. Он обеспечивает безопасную работу
  с коллекцией в многопоточной среде.

На вершине иерархии Java Collection Framework находятся 2 интерфейса: Collection и Map. Они разделяют все коллекции,
входящие в фреймворк, на 2 части по типу хранения данных: простые последовательные наборы элементов, и набор пар
«ключ-значение».
Интерфейс Collection является базовым для всех коллекций, он расширяет интерфейс Iterable поэтому все объекты коллекций
можно перебирать в улучшенном цикле for. У интерфейса Iterable определен только один метод iterator(). Таким образом все
наследники Collection обязаны вернуть итератор. Итератор – это объект, который абстрагирует
за единым интерфейсом доступ к элементам коллекции. К тому же итератор – это паттерн, который позволяет получить доступ
к элементам любой коллекции без необходимости вникать в суть его реализации.

[К оглавлению](#CollectionsLite)

# 6. Назовите основные классы, которые реализуют интерфейсы List Set Map.

- ArrayList, LinkedList, Vector - классы для хранения элементов в виде массива. Они реализуют интерфейс List.
- HashSet, LinkedHashSet, TreeSet - классы для хранения уникальных элементов. Они реализуют интерфейсы Set и SortedSet.
- HashMap, LinkedHashMap, TreeMap, ConcurrentHashMap - классы для хранения пар ключ-значение. Они реализуют интерфейс
  Map и его наследников.
-
[К оглавлению](#CollectionsLite)

# 7. В чем отличие ArrayList от LinkedList?

**1) Структура данных:**
+ ArrayList - реализован на динамическом массиве.
+ LinkedList - двусвязный список.

**2) Вставка и удаление элементов**
+ ArrayList - медленная, так как при этом может потребоваться перемещение всех элементов после вставленного или удаленного элемента.
+ LinkedList - быстрее, так как достаточно изменить ссылки на предыдущий и следующий элементы, не требуя перемещения всех элементов.

**3) Итерация по элементам:**
+ При итерации по элементам ArrayList быстрее, так как доступ к элементам по индексу работает быстро.
+ При итерации по элементам LinkedList может быть медленнее из-за линейной сложности доступа к элементам.

**4) Использование памяти:**
+ ArrayList требует больше памяти, так как он выделяет фиксированный кусок памяти для хранения элементов, который может быть увеличен, если размер структуры данных увеличивается.
+ LinkedList требует меньше памяти, так как каждый элемент хранит ссылки только на предыдущий и следующий элементы.

**5) Применение:**
+ ArrayList - для быстрого доступа по индексу в малоизменяемых списках.
+ LinkedList - для частых вставок и удалений элементов и малом числе поиска элементов.

[К оглавлению](#CollectionsLite)

# 8. В чем отличие HashSet от TreeSet?

**1) Структура данных:**
+ HashSet - хэш-таблица.
+ TreeSet - красно-черное дерево.

**2) Упорядоченность элементов:**
+ TreeSet - хранит элементы в отсортированном порядке (в соответствии с их естественным порядком или с использованием Comparator).
+ HashSet - порядок не гарантирован и может меняться.

**3) Производительность операций:**
+ TreeSet обеспечивает логарифмическую производительность для операций добавления, удаления и поиска элемента (O(log n)).
+ HashSet производительность для операций добавления, удаления и поиска элемента в среднем константная (O(1)). Однако, в худшем случае производительность HashSet может быть линейной (O(n)) из-за коллизий.

**4) Использование памяти:**
+ TreeSet требует больше памяти для хранения элементов из-за дополнительных структур данных, необходимых для хранения красно-чёрного дерева.
+ HashSet требует меньше памяти.

**5) Поддержка нулевого значения:**
+ TreeSet не позволяет хранить значения null.
+ HashSet позволяет хранить null элементы.

**6) Использование:**
+ TreeSet - если необходимо хранить элементы в отсортированном порядке и производительность операций не является критической.
+ HashSet - если требуется быстрое добавление, удаление и поиск элементов.


[К оглавлению](#CollectionsLite)

# 9. В чем отличие Set от Map?

**1) Структура данных:**
+ Set - коллекцию уникальных элементов без какого-либо определенного порядка.
+ Map - коллекция "пар ключ-значение", где каждый ключ уникален.

**2) Скорость:**
+ Set - при поиске будет перебирать на соответствие.
+ Map - прямой доступ по ключу.

**3) Добавление дубликатов:**
+ Set - проигнорирует добавление дубликата.
+ Map - перезапишет значение по ключу-дубликату.

**4) Использование:**
+ Set - когда нужно хранить уникальные значения.
+ Map - когда нужно хранить пары "ключ-значение" и получать доступ к значению по ключу.


[К оглавлению](#CollectionsLite)

# 10. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?

Порядок следования объектов в коллекции в Java зависит от типа коллекции. Например, объекты в ArrayList хранятся в порядке их добавления, а объекты в TreeSet хранятся в отсортированном порядке.

[К оглавлению](#CollectionsLite)

# 11. Чем отличается Comparable от Comparator?

Comparable - используется только для сравнения объектов класса, в котором данный интерфейс реализован. Т.е. интерфейс
Comparable определяет логику сравнения объектов определенного ссылочного типа внутри своей реализации (по правилам
разработчика). Collections.sort(collection);

Comparator - представляет отдельную реализацию и ее можно использовать многократно и с различными классами. Т.е.
интерфейс Comparator позволяет создавать объекты, которые будут управлять процессом сравнения:

- при сортировках в методах Collections.sort(collection, new MyComparator()), Arrays.sort(array, new MyComparator()) или
  collection.sort(new MyComparator())
- при управлении порядком в отсортированных множествах TreeSet или отсортированных картах TreeMap, например new
  TreeSet<T> (new MyComparator()).

Отличия: Comparable определяет логику сравнения объектов определенного ссылочного типа внутри своей реализации и, если
нет
доступа к исходникам, ее невозможно изменить.
Comparator позволяет определить логику сравнения объектов определенного ссылочного типа вне реализации этого типа и эту
логику можно в любой момент изменить.
Comparable используется для сортировки по возрастанию, а Comparator для сортировки по убыванию.

[К оглавлению](#CollectionsLite)

# 12. Что такое сортировка по принципу Natural Order?

Значения располагаются от меньшего к большему.

[К оглавлению](#CollectionsLite)

# 13. Что такое equals и hashcode?

Методы, необходимые для определения равенства объектов. Метод equals сравнивает два объекта на равенство. Если результат
сравнения равен true, это означает, что два объекта равны.
Метод hashcode используется для определения местоположения объекта в хэш-таблице. Если два объекта имеют одинаковый
хэш-код, то вызывается метод equals для сравнения двух объектов.
Если не переопределить метод equals, он будет сравнивать ссылки на объекты. Если вы переопределите этот
метод, вы должны также переопределить метод hashCode, чтобы обеспечить корректную работу хэш-таблицы.

[К оглавлению](#CollectionsLite)

# 14. Какие есть способы перебора всех элементов List?

- через index (fori, while)
```java
        for(int i=0;i<countries.size();i++){
        System.out.println(countries.get(i));
        }
```

```java
        int i=0;
        while(i<countries.size()){
        System.out.println(countries.get(i++));
        }
```

- через iterator (while)
```java
Iterator<String> countriesIterator=countries.iterator();
        while(countriesIterator.hasNext()){
        System.out.println(countriesIterator.next());
        }
```

```java
ListIterator<String> listIterator=countries.listIterator();
//в прямом порядке
        while(listIterator.hasNext()){
        System.out.println(listIterator.next());
        }
//в обратном порядке
        while(listIterator.hasPrevious()){
        System.out.println(listIterator.previous());
        }    
```

- foreach
```java
        for(String country:countries){
        System.out.println(country);
        }    
```

[К оглавлению](#CollectionsLite)

# 15. Расскажите о методах Map.
V put(K key, V value); - вставит данные в карту.

V get(K key); - получить значение по ключу.

Пару можно обновить тем же методом, что и вставить.
Ключ пары должен быть уникальный. Если в Map уже есть такой key,
то ячейка value будет заменена на новое значение.

remove(key) — удаляет элемент с указанным ключом из карты. Если ключ отсутствует, исключение не выбрасывается.

keySet(), values() и entrySet() — возвращают соответственно набор ключей, значений и пар ключ-значение в карте.

containsKey(key) и containsValue(value) — проверяют, содержит ли карта указанный ключ или значение.

clear() — удаляет все элементы из карты.

size() — возвращает количество элементов в карте.

isEmpty() — проверяет, пуста ли карта.

[К оглавлению](#CollectionsLite)

# 16. Расскажите, какие классы реализовывают интерфейс Map?
- ***HashMap*** - хэш-таблица, самая распространенная и широко используемая реализация интерфейса Map. Она основана на хэш-таблицах и предоставляет эффективный доступ к элементам по ключу. HashMap позволяет хранить значения в виде пар ключ-значение и обеспечивает доступ к ним за константное время в среднем случае.
- ***LinkedHashMap*** - класс, который расширяет функциональность HashMap, сохраняя порядок добавления элементов. LinkedHashMap предоставляет доступ к элементам в порядке их добавления или последнего доступа. Это может быть полезно, если важен порядок элементов или нужно управлять итерацией по коллекции.
- ***TreeMap*** - класс, реализующий интерфейс Map с использованием красно-черного дерева. TreeMap хранит элементы в отсортированном порядке по ключу. Поиск, добавление и удаление элементов в TreeMap происходит за время O(log n), что делает его эффективным выбором для приложений, требующих отсортированные данные.
- ***HashTable*** - устаревшая версия HashMap, синхронизированная версия.
- ***ConcurrentHashMap*** - реализация интерфейса Map, оптимизированная для многопоточных приложений. ConcurrentHashMap обеспечивает безопасный доступ к элементам коллекции из нескольких потоков, минимизируя блокировки с помощью распределения данных по сегментам. Это делает ConcurrentHashMap подходящим выбором для параллельных вычислений.
- ***EnumMap*** - перечисления в качестве ключей, благодаря чему - высокая производительность.
- ***IdentityMap*** - сравнивает ключи по `==` вместо `equals()`. Полезна в случае, когда требуется точное сравнение объектов по их ссылке.

[К оглавлению](#CollectionsLite)

# 17. Расскажите о методах keySet и entrySet? Что такое Entry?
Интерфейс `Map` в Java предоставляет два ключевых метода для работы с ключами и парами ключ-значение: `keySet()` и `entrySet()`.

1. Метод `keySet()`:

+ Возвращает: `Set` объектов, которые представляют ключи всех записей в `Map`.
+ Использование: Используется, когда нужно получить доступ к ключам `Map` и выполнить операции, не связанные с значениями.

Пример:

```java
Map<String, Integer> ages = new HashMap<>();
ages.put("Alice", 25);
ages.put("Bob", 30);
ages.put("Charlie", 28);

Set<String> keys = ages.keySet();
System.out.println("Keys: " + keys); // Keys: [Bob, Alice, Charlie]

for (String key : keys) {
    System.out.println(key);
}
//Bob
//Alice
//Charlie

```

2. Метод `entrySet()`:

+ Возвращает: `Set` объектов типа `Map.Entry`, который представляет собой пару ключ-значение.
+ Использование: Используется, когда нужно получить доступ как к ключам, так и к значениям `Map` одновременно.

Пример:

```java
Map<String, Integer> ages = new HashMap<>();
ages.put("Alice", 25);
ages.put("Bob", 30);
ages.put("Charlie", 28);

Set<Map.Entry<String, Integer>> entries = ages.entrySet();
System.out.println("Entries: " + entries); //Entries: [Bob=30, Alice=25, Charlie=28]

for (Map.Entry<String, Integer> entry : entries) {
    System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
}
//Key: Bob, Value: 30
//Key: Alice, Value: 25
//Key: Charlie, Value: 28
```

Ключевые моменты:

+ `Set` гарантирует, что ключи (или пары ключ-значение) не будут дублироваться.
+ Методы `keySet()` и `entrySet()` возвращают неизменяемые представления `Map`. Изменения в полученных `Set` не повлияют на исходную `Map`.
+ Используйте `keySet()` для работы только с ключами.
+ Используйте `entrySet()` для работы с ключами и значениями одновременно.

Преимущества:

+ Предоставляют удобный способ получить доступ к ключам и значениям `Map`.
+ Обеспечивают удобную итерацию по элементам `Map`.
+ Упрощают манипуляции с элементами `Map`.

Дополнительная информация:

+ Интерфейс `Map` также предоставляет метод `values()`, который возвращает `Collection` всех значений `Map`.
+ Методы `keySet()`, `entrySet()` и `values()` возвращают только представления `Map`, а не её копии.
+ Операции модификации на полученных `Set` или `Collection` могут привести к непредсказуемому поведению.

Entry в `Map` - это пара "ключ-значение". Ключ - это уникальный идентификатор для элемента в `Map`. Он используется для доступа к соответствующему значению. Значение - это фактическая информация, связанная с ключом.

Пример: представьте, что у вас есть `Map`, которая хранит информацию о студентах. Ключом может быть номер студенческого билета, а значением - имя студента.

```java
Map<Integer, String> студенты = new HashMap<>();

студенты.put(12345, "Иван Иванов");
студенты.put(67890, "Мария Петрова");
```

В этом случае, `(12345, "Иван Иванов")` и `(67890, "Мария Петрова")` - это entries в `Map`.

Методы для работы с entries:

+ `entrySet()`: Возвращает набор всех `entries` в `Map`.
+ `containsKey(Object key)`: Проверяет, существует ли ключ в `Map`.
+ `containsValue(Object value)`: Проверяет, существует ли значение в `Map`.
+ `get(Object key)`: Возвращает значение, соответствующее заданному ключу.
+ `put(K key, V value)`: Добавляет или обновляет `entry` в `Map`.
+ `remove(Object key)`: Удаляет `entry` с заданным ключом из `Map`.

Использование `entries`: `еntries` в `Map` используются для хранения и извлечения данных, где для каждой записи есть уникальный ключ, который позволяет быстро и эффективно найти соответствующее значение.

[К оглавлению](#CollectionsLite)

# 18. Что будет если вызвать метод put несколько раз с одинаковым ключом?
В этом случае будет сохраняться последний добавленный элемент с данным ключом.

[К оглавлению](#CollectionsLite)

# 19. Как реализован цикл foreach?
кл `foreach` в Java не является самостоятельным оператором, а является синтаксическим сахаром для итерации по элементам итерабельных объектов (реализующих интерфейс `Iterable`).

1. Итерабельный объект:

Цикл `foreach` работает с объектами, реализующими интерфейс `Iterable`.  Этот интерфейс определяет единственный метод:

```java
Iterator<T> iterator();
```

Этот метод возвращает объект `Iterator`, который позволяет перебирать элементы итерабельного объекта.

2. Iterator:

Класс `Iterator` предоставляет следующие методы:

+ `hasNext()`: Возвращает `true`, если в итераторе есть следующий элемент.
+ `next()`: Возвращает следующий элемент итерации.
+ `remove()`: Удаляет последний элемент, возвращенный методом `next()`. (Необязательный метод)

3. Реализация цикла `foreach`:

Компилятор Java преобразует цикл `foreach` в код, использующий итератор. Пример:

```java
for (int number : numbers) { 
    System.out.println(number);
}
```

Этот код будет преобразован в:

```java
Iterator<Integer> iterator = numbers.iterator();
while (iterator.hasNext()) {
    int number = iterator.next();
    System.out.println(number);
}
```

4. Процесс итерации:

+ Цикл `foreach` вызывает метод `iterator()` на итерабельном объекте.
+ Он получает объект `Iterator` и использует его для перебора элементов.
+ Метод `hasNext()` используется для проверки, есть ли следующий элемент.
+ Если есть, метод `next()` возвращает следующий элемент.
+ Элемент присваивается переменной в цикле `foreach`.
+ Тело цикла `foreach` выполняется.
+ Процесс повторяется, пока `hasNext()` не вернет `false`.

5.  Преимущества цикла `foreach`:

+ Простой синтаксис: Более простой и читаемый код, чем использование обычных циклов `for`.
+ Безопасность:  Избегает ошибок, связанных с индексами.
+ Универсальность: Работает с любым итерабельным объектом.

6. Ограничения:

+ Невозможность изменения коллекции во время итерации: изменение коллекции (добавление или удаление элементов) во время итерации может привести к ошибкам.
+ Невозможность доступа к индексу элементов:  если вам нужен доступ к индексу элемента, необходимо использовать обычный цикл `for`.

[К оглавлению](#CollectionsLite)

# 20. В чем разница между Iterator и Iterable?
***Iterable:***

Определение: интерфейс, который определяет, что объект может быть итерирован (пройден в цикле). Простыми словами - определяет, что объект можно итерировать

Метод: имеет единственный метод `iterator()`, который возвращает объект `Iterator`.

Пример: класс `ArrayList` реализует интерфейс `Iterable`, что позволяет нам использовать цикл `for-each` для итерации по элементам списка.

***Iterator:***

Определение: интерфейс, который обеспечивает механизм для итерации по элементам коллекции.

Методы:
+ `hasNext()`: Возвращает `true`, если в коллекции есть еще элементы для итерации.
+ `next()`: Возвращает следующий элемент в коллекции.
+ `remove()`: Удаляет последний элемент, возвращенный методом `next()`.

Пример:  мы используем `Iterator` для итерации по коллекции и управления итерацией. Простыми словами - предоставляет механизм для итерации.

```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class Main {

    public static void main(String[] args) {

        List<String> names = new ArrayList<>();
        names.add("Alice");
        names.add("Bob");
        names.add("Charlie");

        // Using Iterable
        for (String name : names) {
            System.out.println(name);
        }

        // Using Iterator
        Iterator<String> iterator = names.iterator();
        while (iterator.hasNext()) {
            String name = iterator.next();
            System.out.println(name);
        }
    }
}
```
[К оглавлению](#CollectionsLite)

# 21. Как происходит удаление элементов из ArrayList?
Находится заданный элемент. Далее сдвигаются влево на один элемент все последующие (с большим индексом) элементы, а
значение size уменьшается на 1.

```java
        System.arraycopy(es,i+1,es,i,newSize-i)
        es[size=newSize]=null;
```

[К оглавлению](#CollectionsLite)

# 22. Как происходит удаление элементов из LinkedList?
Заменяются ссылки previous и next у соседних элементов.

[К оглавлению](#CollectionsLite)

# 23. Что такое авто упаковка и распаковка? Зачем они нужны?
Автоупаковка - это автоматическая инкапсуляция примитивного типа в эквивалентную ему класс-обёртку всякий раз, когда
требуется объект данного типа. Происходит:

- при присвоении значения примитивного типа переменной соответствующего класса-обёртки.
- при передаче примитивного типа в параметр метода, ожидающего соответствующий ему класс-обёртку.

Автораспаковка - это преобразование класса-обёртки в соответствующий ему примитивный тип. Если при распаковке
класс-обёртка был равен null, произойдет исключение java.lang.NullPointerException. Происходит:

- при присвоении экземпляра класса-обёртки переменной соответствующего примитивного типа.
- в выражениях, в которых один или оба аргумента являются экземплярами классов-обёрток (кроме операции == и !=).
- при передаче объекта класса-обёртки в метод, ожидающий соответствующий примитивный тип.

Автоупаковка и распаковка очень часто происходит при работе с коллекциями, так как они не могут хранить примитивные типы
данных.

+ Автоупаковка и распаковка работают только с соответствующими примитивными типами данных и объектами-оболочками. Например, нельзя автоупаковать `float` в `Integer`.
+ Не рекомендуется использовать автоупаковку и распаковку в циклах, где могут быть созданы тысячи объектов-оболочек, так как это может привести к проблемам с памятью.
+ Вместо автоупаковки можно использовать методы `valueOf()` класса-оболочки для создания объекта из примитивного значения. Например, `Integer.valueOf(10)` создает объект `Integer` со значением 10.

Пример:

```java
int num = 420; // Примитивный тип данных
Integer numObj = num; // Автоупаковка int в Integer
int num2 = numObj; // Автораспаковка Integer в int
```

[К оглавлению](#CollectionsLite)

# 24. В каком случае при работе с упакованными значениями может возникнуть проблема с производительностью?

+ Избыточное использование памяти.
+ Затраты на производительность (упаковка/распаковка) при работе с циклами, коллекциями.
+ Возможно неожиданное поведение при кэшировании.

[К оглавлению](#CollectionsLite)

# 25. Опишите недостатки и преимущества в использовании примитивных типов и классов-оберток.
**Примитивные типы данных**

***Преимущества:***
+ используют мало памяти;
+ операции с примитивами выполняются значительно быстрее;
+ простота (проще объявлять, не требуется создавать объекты для объявления, применять конструкторы);
+ простота логических операций (==, <> и т.д.).

***Недостатки:***
+ отсутствуют `null`-значения;
+ неявные преобразования (потеря точности при использовании в арифметических операциях разных типов данных);
+ отсутствие методов;
+ ограниченный функционал (не поддерживают концепции ООП: полиморфизм, наследование, инкапсуляция).

**Классы-обертки**

***Преимущества:***
+ использование таких классов как объекты открывает доступ к методам и функциональности ООП;
+ имеют `null`-значения;
+ можно использовать в коллекциях и обобщениях;

***Недостатки:***
+ погрешность и производительность (избыточное использование памяти);
+ может создавать дополнительный уровень иерархии классов из-за использования объектов;
+ использование может привести к ошибкам в коде при отсутствии проверки на `null`..

[К оглавлению](#CollectionsLite)

# 26. Что такое очередь? Расскажите принцип работы и для чего она используется.
Очередь (Queue) в Java – это абстрактный тип данных, который реализует принцип FIFO (First In, First Out - первый вошел, первый вышел). Это означает, что элементы добавляются в конец очереди, а извлекаются из начала. Представьте, как люди стоят в очереди в магазине – первый человек, кто пришел, первым и будет обслуживаться кассиром.

Интерфейс Deque расширяет вышеописанный интерфейс Queue и определяет поведение двунаправленной очереди, которая работает как обычная однонаправленная очередь, либо как стек, действующий по принципу LIFO (Last In, First Out - последний вошел, первый вышел).

Принцип работы:

+ Добавление элементов (enqueue): новый элемент добавляется в конец очереди.
+ Извлечение элементов (dequeue): извлекается элемент, находящийся в начале очереди.

Реализации очереди в Java:

+ `java.util.LinkedList`: Очередь, основанная на связном списке. Быстрая работа с добавлением и удалением элементов в начале и конце очереди.
+ `java.util.ArrayDeque`: Очередь, основанная на массиве. Эффективная работа, если требуется частое добавление элементов в конец очереди.

Для чего используются очереди:

+ Обработка задач: очередь может использоваться для хранения задач, которые должны быть обработаны в определенном порядке. Например, в многопоточном приложении очередь может хранить задачи, которые должны быть выполнены отдельными потоками.
+ Обработка событий: очередь может использоваться для хранения событий, которые должны быть обработаны в определенном порядке. Например, в веб-приложении очередь может хранить запросы пользователей, которые должны быть обработаны сервером.
+ Многопоточная синхронизация: очередь может использоваться для синхронизации доступа к ресурсам между несколькими потоками. Например, очередь может использоваться для хранения данных, которые должны быть обработаны несколькими потоками, но только один поток может получить доступ к данным в один момент времени.
+ Системы обмена сообщениями: очереди широко используются в системах обмена сообщениями для отправки и получения сообщений между различными компонентами системы.

Пример использования очереди:

```java
import java.util.LinkedList;
import java.util.Queue;

public class QueueExample {

    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();

        // Добавление элементов в очередь
        queue.offer("Element 1");
        queue.offer("Element 2");
        queue.offer("Element 3");

        // Извлечение элементов из очереди
        while (!queue.isEmpty()) {
            System.out.println(queue.poll());
        }
    }
}
```

Этот пример демонстрирует, как создать очередь, добавить в нее элементы и затем извлечь их в порядке, в котором они были добавлены.

Важно отметить: очереди являются мощным инструментом для организации и обработки данных в Java. Выбор реализации очереди зависит от конкретных потребностей приложения.

[К оглавлению](#CollectionsLite)

# 27. Расскажите про интерфейсы Queue, Deque и их иерархию.
**Очередь (Queue) в Java** – это абстрактный тип данных, который реализует принцип FIFO (First In, First Out - первый вошел, первый вышел). Это означает, что элементы добавляются в конец очереди, а извлекаются из начала. Представьте, как люди стоят в очереди в магазине – первый человек, кто пришел, первым и будет обслуживаться кассиром.

Основные реализации Queue:

***PriorityQueue:***

Основные свойства:
+ Основана на куче (heap).
+ Порядок элементов определяется заданным компаратором (если компаратор не задан - NaturalOrder).
+ Обеспечивает быструю вставку и удаление элементов с минимальным значением.

Преимущества:
+ Эффективность при необходимости быстрого доступа к минимальному элементу.
+ Подходит для задач, требующих сортировки по приоритету.

Интерфейс `java.util.Queue` предоставляет основные операции с очередями:

+ `add(E element)`: добавляет элемент в конец очереди.
+ `E element()`: возвращает, но не удаляет, элемент из начала очереди. Если очередь пуста, генерирует исключение `NoSuchElementException`.
+ `boolean offer(E obj)`: добавляет элемент `obj` в конец очереди. Если элемент удачно добавлен, возвращает `true`, иначе - `false`.
+ `E peek()`: возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение `null`.
+ `E poll()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение `null`.
+ `E remove()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение `NoSuchElementException`.

**Интерфейс Deque** - расширяет вышеописанный интерфейс Queue и определяет поведение двунаправленной очереди, которая работает как обычная однонаправленная очередь, либо как стек, действующий по принципу LIFO (Last In, First Out - последний вошел, первый вышел).

**Основные реализации Deque:**

***ArrayDeque:*** - использует массив для хранения элементов.

Основные свойства:
+ Быстрая работа с добавлением и удалением элементов с обоих концов.
+ Неэффективна при добавлении и удалении элементов из середины.
+ Не подходит для хранения больших объемов данных, так как при достижении предела размера массива требуется перераспределение памяти.

Применение: оптимально для небольших коллекций, где требуется быстрый доступ к элементам с обоих концов.

***LinkedList*** - использует двусвязный список для хранения элементов.

Основные свойства:
+ Эффективна при добавлении и удалении элементов из любой позиции.
+ Доступ к элементам по индексу может быть медленным.
+ Требует больше памяти, чем `ArrayDeque`.

Применение: оптимально для коллекций с частыми операциями добавления и удаления элементов в произвольных местах.

***ConcurrentLinkedDeque*** - использует двусвязный список для хранения элементов. Обеспечивает потокобезопасность.

Основные свойства:
+ Эффективна при добавлении и удалении элементов из любой позиции.
+ Доступ к элементам по индексу может быть медленным.
+ Требует больше памяти, чем `ArrayDeque`.
+ Гарантирует потокобезопасность, что делает ее подходящей для многопоточной среды.

Применение: оптимально для коллекций, которые используются в многопоточной среде и требуют потокобезопасной работы с элементами.

Выбор оптимальной реализации `Deque` зависит от конкретной задачи и требований к производительности.

+ Для небольших коллекций с частыми операциями добавления и удаления с обоих концов `ArrayDeque` будет наиболее эффективной.
+ Для коллекций с частыми операциями добавления и удаления из любой позиции, а также для больших объемов данных `LinkedList` будет более подходящим выбором.
+ Для многопоточной среды `ConcurrentLinkedDeque` предоставляет потокобезопасную работу с коллекцией.

Интерфейс Deque определяет следующие методы:

+ `void addFirst(E obj)`: добавляет элемент в начало очереди.
+ `void addLast(E obj)`: добавляет элемент `obj` в конец очереди.
+ `E getFirst()`: возвращает без удаления элемент из головы очереди. Если очередь пуста, генерирует исключение `NoSuchElementException`.
+ `E getLast()`: возвращает без удаления последний элемент очереди. Если очередь пуста, генерирует исключение `NoSuchElementException`.
+ `boolean offerFirst(E obj)`: добавляет элемент `obj` в самое начало очереди. Если элемент удачно добавлен, возвращает `true`, иначе - `false`.
+ `boolean offerLast(E obj)`: добавляет элемент `obj` в конец очереди. Если элемент удачно добавлен, возвращает `true`, иначе - `false`.
+ `E peekFirst()`: возвращает без удаления элемент из начала очереди. Если очередь пуста, возвращает значение `null`.
+ `E peekLast()`: возвращает без удаления последний элемент очереди. Если очередь пуста, возвращает значение `null`.
+ `E pollFirst()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, возвращает значение `null`.
+ `E pollLast()`: возвращает с удалением последний элемент очереди. Если очередь пуста, возвращает значение `null`.
+ `E pop()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение `NoSuchElementException`.
+ `void push(E element)`: добавляет элемент в самое начало очереди.
+ `E removeFirst()`: возвращает с удалением элемент из начала очереди. Если очередь пуста, генерирует исключение `NoSuchElementException`.
+ `E removeLast()`: возвращает с удалением элемент из конца очереди. Если очередь пуста, генерирует исключение `NoSuchElementException`.
+ `boolean removeFirstOccurrence(Object obj)`: удаляет первый встреченный элемент `obj` из очереди. Если удаление произшло, то возвращает `true`, иначе возвращает `false`.
+ `boolean removeLastOccurrence(Object obj)`: удаляет последний встреченный элемент `obj` из очереди. Если удаление произшло, то возвращает `true`, иначе возвращает `false`.

Таким образом, наличие методов pop и push позволяет классам, реализующим этот элемент, действовать в качестве стека. В тоже время имеющийся функционал также позволяет создавать двунаправленные очереди, что делает классы, применяющие данный интерфейс, довольно гибкими.

[К оглавлению](#CollectionsLite)

# 28. В чем отличие метода poll() от remove()?
Оба метода позволяют удалить верхний элемент из очереди. Отличия в них видны, когда мы применяем эти методы на пустой очереди.
poll() - возвращает null.
remove() - генерирует исключение NoSuchElementException.

[К оглавлению](#CollectionsLite)

# 29. В чем отличие метода element() от peek()?
Оба метода позволяют вернуть первый элемент из очереди без его удаления.
Отличия в них видны, когда мы применяем эти методы на пустой очереди.
element() - генерирует исключение NoSuchElementException.
peek() - возвращает null.

[К оглавлению](#CollectionsLite)

# 30. В чем отличие метода element() от poll()?
element() возвращает (но не удаляет) первый элемент очереди. Если очередь пуста, выбрасывает исключение NoSuchElementException.
poll() возвращает и удаляет первый элемент очереди. Возвращает null, если очередь пуста.

[К оглавлению](#CollectionsLite)

# 31. Перечислите наиболее часто используемые реализации интерфейса Queue.
Наиболее часто используемые реализации интерфейса Queue:

***LinkedList*** - использует двусвязный список для хранения элементов.

Основные свойства:
+ Эффективна при добавлении и удалении элементов из любой позиции.
+ Доступ к элементам по индексу может быть медленным.
+ Требует больше памяти, чем `ArrayDeque`.

Применение: оптимально для коллекций с частыми операциями добавления и удаления элементов в произвольных местах.

***PriorityQueue:***

Основные свойства:
+ Основана на куче (heap).
+ Порядок элементов определяется заданным компаратором (если компаратор не задан - NaturalOrder).
+ Обеспечивает быструю вставку и удаление элементов с минимальным значением.

Преимущества:
+ Эффективность при необходимости быстрого доступа к минимальному элементу.
+ Подходит для задач, требующих сортировки по приоритету.

***ArrayDeque:*** - использует массив для хранения элементов.

Основные свойства:
+ Быстрая работа с добавлением и удалением элементов с обоих концов.
+ Неэффективна при добавлении и удалении элементов из середины.
+ Не подходит для хранения больших объемов данных, так как при достижении предела размера массива требуется перераспределение памяти.

Применение: оптимально для небольших коллекций, где требуется быстрый доступ к элементам с обоих концов.

Дополнительные реализации:

+ ConcurrentLinkedQueue:  очередь, которая позволяет выполнять многопоточные операции над элементами. Она основана на связном списке и обеспечивает потокобезопасную очередь.
+ LinkedBlockingQueue:  очередь, которая позволяет выполнять многопоточные операции над элементами, блокируя потоки, которые пытаются получить доступ к пустой очереди или добавить элемент в полную очередь.
+ DelayQueue: очередь, которая позволяет хранить элементы, которые имеют определенное время задержки. Элементы извлекаются из очереди только по достижении времени задержки.


[К оглавлению](#CollectionsLite)

# 32. Что такое ограниченные и неограниченные очереди?

Очереди, доступные в пакете java.util, являются неограниченными очередями - это те очереди, которые не имеют
фиксированного размера.Они могут увеличиваться по мере необходимости до тех пор, пока позволяет память.(LinkedList,
ConcurrentLinkedQueue)

Очереди, доступные в пакете java.util.concurrent, являются ограниченными очередями -это очереди, которые имеют
фиксированный размер. Когда размер очереди достигает своего предела, попытки добавить новые элементы могут блокироваться
или приводить к исключениям в зависимости от реализации.(ArrayBlockingQueue, LinkedBlockingQueue)

[К оглавлению](#CollectionsLite)

# 33. Что такое односторонние и двусторонние очереди?
Односторонняя очередь, это такая очередь, в которую элементы могут быть добавлены\удалены только в одном направлении.
Двухсторонняя очередь, это такая очередь, в которую элементы могут быть добавлены\удалены в двух направлениях.

Пример кода:

```java
import java.util.LinkedList;
import java.util.Queue;
import java.util.Deque;

public class QueueExample {

    public static void main(String[] args) {

        // Односторонняя очередь
        Queue<String> queue = new LinkedList<>();
        queue.offer("A"); // Добавление элемента в конец очереди
        queue.offer("B");
        queue.offer("C");

        System.out.println("Односторонняя очередь:");
        while (!queue.isEmpty()) {
            System.out.println(queue.poll()); // Удаление и получение элемента из начала очереди
        }

        // Двусторонняя очередь
        Deque<String> deque = new LinkedList<>();
        deque.offerFirst("A"); // Добавление элемента в начало деки
        deque.offerLast("B"); // Добавление элемента в конец деки
        deque.offerFirst("C");

        System.out.println("\nДвусторонняя очередь:");
        while (!deque.isEmpty()) {
            System.out.println(deque.pollFirst()); // Удаление и получение элемента из начала деки
        }
    }
}
```
Примеры использования:
+ Односторонняя очередь: обработка событий, управление задачами в многопоточном программировании, создание буферов для передачи данных.
+ Двусторонняя очередь: история команд в текстовом редакторе, отмена действий, реализация стека и очереди в одной структуре данных.

Преимущества и недостатки:

Односторонняя очередь:
+ Преимущества: простота реализации, эффективный доступ к первому элементу.
+ Недостатки: ограниченная функциональность, нельзя получить доступ к последнему элементу без удаления всех предыдущих.

Двусторонняя очередь:

+ Преимущества: Более гибкая функциональность, возможность доступа к элементам с обоих концов.
+ Недостатки: Более сложная реализация, может быть менее эффективной, чем односторонняя очередь.


[К оглавлению](#CollectionsLite)

# 34. В чем отличие Deque от Queue?
Queue реализует одностороннюю очередь,
такая очередь позволяет поместить элементы в один конец очереди,
а извлекать их – из другого.

Deque расширяет интерфейс Queue.
Этот интерфейс также является очередью, но ее отличительной особенностью то,
что эта очередь является двухсторонней, т.е. она поддерживает удаление
и добавление элементов с обоих концов очереди.

Таким образом, в отличие от Queue, здесь также можно организовать способ
хранения элементов по принципу LIFO (сокращение по первой букве
от описания этого принципа на английском языке Last In First Out
– последний пришел, первый вышел
Такую структуру данных в программировании называют стеком.

Пример аналогии из жизни – стопка тетрадей на проверку у учителя,
учитель проверяет их по порядку и та тетрадь, которая была положена
в эту стопку первой будет проверена последней.
(или стопка тарелок)

[К оглавлению](#CollectionsLite)

# 35. В чем отличие методов removeLast() и pollLast()?
Методы удаляют первый элемент из очереди с его возвратом. Первый сгенерирует исключение при пустой очереди, второй –
вернет null.

[К оглавлению](#CollectionsLite)

# 36. Назовите самую распространенную реализацию Deque.
***LinkedList*** - использует двусвязный список для хранения элементов.

Основные свойства:
+ Эффективна при добавлении и удалении элементов из любой позиции.
+ Доступ к элементам по индексу может быть медленным.
+ Требует больше памяти, чем `ArrayDeque`.

Применение: оптимально для коллекций с частыми операциями добавления и удаления элементов в произвольных местах.

***ArrayDeque:*** - использует массив для хранения элементов.

Основные свойства:
+ Быстрая работа с добавлением и удалением элементов с обоих концов.
+ Неэффективна при добавлении и удалении элементов из середины.
+ Не подходит для хранения больших объемов данных, так как при достижении предела размера массива требуется перераспределение памяти.

Применение: оптимально для небольших коллекций, где требуется быстрый доступ к элементам с обоих концов.

[К оглавлению](#CollectionsLite)