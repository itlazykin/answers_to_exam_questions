## CollectionsPro

[1. Что такое generics?](#1-что-такое-generics)

[2. Что такое wild cards?](#2-что-такое-wild-cards)

[3. Что такое bounded wild cards?](#3-что-такое-bounded-wild-cards)

[4. Что такое unbounded wild cards?](#4-Что-такое-unbounded-wild-cards)

[5. Где хранится информация про Generics?](#5-Где-хранится-информация-про-Generics)

[6. Как можно получить тип Generics?](#6-Как-можно-получить-тип-Generics)

[7. Что такое итератор? В чем разница между iterator и listIterator? Что такое fail-fast и fail-safe поведение итератора и в чем между ними разница? Когда возникает ConcurrentModificationException?](#7-Что-такое-итератор-В-чем-разница-между-iterator-и-listIterator-Что-такое-fail-fast-и-fail-safe-поведение-итератора-и-в-чем-между-ними-разница-Когда-возникает-ConcurrentModificationException)

[8. Что такое коллекции?](#8-Что-такое-коллекции)

[9. Назовите базовые интерфейсы коллекций?](#9-Назовите-базовые-интерфейсы-коллекций)

[10. Расскажите реализации интерфейса List?](#10-Расскажите-реализации-интерфейса-List)

[11. Расскажите реализации интерфейса Set?](#11-Расскажите-реализации-интерфейса-Set)

[12. Расскажите реализации интерфейса Map?](#12-Расскажите-реализации-интерфейса-Map)

[13. Отличие ArrayList от LinkedList?](#13-Отличие-ArrayList-от-LinkedList)

[14. Отличие Set от List?](#14-Отличие-Set-от-List)

[15. Расскажите про методы Object hashCode и equals?](#15-Расскажите-про-методы-Object-hashCode-и-equals)

[16. Расскажите, что такое коллизии в Map? Как с ними бороться?](#16-Расскажите-что-такое-коллизии-в-Map-Как-с-ними-бороться)

[17. Расскажите, что такое анализ алгоритма?](#17-Расскажите-что-такое-анализ-алгоритма)

[18. Какая временная сложность алгоритмов добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?](#18-Какая-временная-сложность-алгоритмов-добавления-замены-и-удаления-в-каждой-из-коллекций-С-чем-связаны-отличия)

[19. Расскажите реализации данных очередей и стеков.](#19-Расскажите-реализации-данных-очередей-и-стеков)

[20. Расскажите про реализации деревьев.](#20-Расскажите-про-реализации-деревьев)

[21. Что такое loadFactor?](#21-Что-такое-loadFactor)

[22. Перечислите побитовые логические операции, которые Вы знаете? Расскажите, как они работают.](#22-Перечислите-побитовые-логические-операции-которые-Вы-знаете-Расскажите-как-они-работают)

[23. Расскажите про операции сдвига. Какие они бывают и что делают?](#23-Расскажите-про-операции-сдвига-Какие-они-бывают-и-что-делают)

[24. Как хранится знак числа в Java? Как хранятся отрицательные числа?](#24-Как-хранится-знак-числа-в-Java-Как-хранятся-отрицательные-числа)

[25. Расскажите о системах сборки проекта. В чем отличие систем сборки Ant, Maven и Gradle?](#25-Расскажите-о-системах-сборки-проекта-В-чем-отличие-систем-сборки-Ant-Maven-и-Gradle)

[26. Как создать maven проект?](#26-Как-создать-maven-проект)

[27. Какова структура maven проекта?](#27-Какова-структура-maven-проекта)

[28. Расскажите о файле pom xml. Как он структурирован и за что отвечает содержание каждой части?](#28-Расскажите-о-файле-pom-xml-Как-он-структурирован-и-за-что-отвечает-содержание-каждой-части)

[29. Что такое координаты зависимости?](#29-Что-такое-координаты-зависимости)

[30. Что такое транзитивные зависимости?](#30-Что-такое-транзитивные-зависимости)

[31. Что такое область видимости зависимости? Сколько областей видимости предусмотрено и где они применяются?](#31-Что-такое-область-видимости-зависимости-Сколько-областей-видимости-предусмотрено-и-где-они-применяются)

[32. Расскажите о жизненном цикле maven. В какой последовательности выполняются фазы цикла и что происходит на каждой фазе сборки?](#32-Расскажите-о-жизненном-цикле-maven-В-какой-последовательности-выполняются-фазы-цикла-и-что-происходит-на-каждой-фазе-сборки)

# 1. Что такое generics?

Начиная с Java 5 в языке программирования появились возможности обобщенного программирования. До этого программисту
приходилось выполнять приведение каждого объекта, прочитанного из коллекции. Если кто-то случайно вставлял туда объект
неправильного типа, приведение могло вызвать runtime exception. С помощью обобщенных типов можно сообщить компилятору,
какие типы допускаются в каждой коллекции. Компилятор автоматически добавит приведение типов и во время компиляции
обнаружит попытки вставить объект неправильного типа, и у нас в рантайме уже ничего не упадет.
Это делает программы более безопасными и ясными. С их помощью можно объявлять классы,
интерфейсы и методы, где тип данных указан в виде параметра.
[К оглавлению](#CollectionsPro)

# 2. Что такое wild cards?

Wildcards в Java используются в обобщениях для обозначения неизвестного типа. Это удобно, когда вы хотите работать с
различными типами данных, но не хотите жёстко задавать конкретный тип. Wildcards представляются символом вопросительного
знака (?). Используется, когда тип данных может быть абсолютно любым. Если необходимо читать из контейнера, то
используйте wildcard с верхней границей "? extends". Если необходимо
писать в контейнер, то используйте wildcard с нижней границей "? super". Не используйте wildcard, если нужно производить
и запись, и чтение.

````java
List<?> list = new ArrayList<>();
`````

[К оглавлению](#CollectionsPro)

# 3. Что такое bounded wild cards?

Ограниченный wildcard с верхней границей (<? extends Type>): Используется, когда тип данных должен быть подтипом (или
самим типом) указанного класса. Например:

````java
List<? extends Number> list = new ArrayList<>();
````

Здесь list может содержать элементы типа Number, Integer, Double, и других классов, которые являются подтипами Number.

[К оглавлению](#CollectionsPro)

# 4. Что такое unbounded wild cards?

Ограниченный wildcard с нижней границей (<? super Type>):
Используется, когда тип данных должен быть суперклассом (или самим типом) указанного класса. Например:

````java
List<? super Integer> list = new ArrayList<>();
````

В этом случае list может содержать элементы типа Integer, Number, или Object (так как они являются супер классами
Integer).

[К оглавлению](#CollectionsPro)

# 5. Где хранится информация про Generics?

После компиляции JVM не имеет информации о типах параметров обобщений. Все данные о Generics используются только на
этапе компиляции для обеспечения типовой безопасности и не сохраняются в байт-коде. Процесс удаления информации о типах
во время компиляции называется стирание типов. Во время компиляции все параметры типов в обобщениях (Generics)
заменяются на их границы или на Object, если границы не указаны. Например, List<String> и List<Integer> после
компиляции становятся просто List. Почему нельзя создавать массивы обобщённых типов или напрямую проверять тип обобщения
с помощью instanceof во время выполнения — эта информация просто недоступна в байт-коде.

[К оглавлению](#CollectionsPro)

# 6. Как можно получить тип Generics?

Если обобщённый тип задан в классе или интерфейсе как параметризованный тип, вы можете получить информацию о нём с
помощью рефлексии.

````java
public class GenericTypeDemo<T> {
    public static void main(String[] args) {
        // Анонимный класс для захвата информации о типе обобщения
        GenericTypeDemo<String> instance = new GenericTypeDemo<String>() {
        };
        Type superclass = instance.getClass().getGenericSuperclass();

        if (superclass instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) superclass;
            Type[] typeArguments = parameterizedType.getActualTypeArguments();
            for (Type typeArgument : typeArguments) {
                System.out.println("Тип обобщения: " + typeArgument);
            }
        }
    }
````

Используется анонимный подкласс (GenericTypeDemo<String> instance = new GenericTypeDemo<String>() {}), чтобы обойти Type
Erasure и сохранить информацию о типе обобщения, которую затем можно извлечь с помощью рефлексии.

Ещё один способ сохранить информацию о типе — передать его явно в конструктор или метод в виде класса (Class<T>):

````java
public class GenericClass<T> {
    private Class<T> type;

    public GenericClass(Class<T> type) {
        this.type = type;
    }

    public void printType() {
        System.out.println("Тип обобщения: " + type.getName());
    }

    public static void main(String[] args) {
        GenericClass<String> instance = new GenericClass<>(String.class);
        instance.printType();  // Выведет: Тип обобщения: java.lang.String
    }
}
````

[К оглавлению](#CollectionsPro)

# 7. Что такое итератор? В чем разница между iterator и listIterator? Что такое fail-fast и fail-safe поведение итератора и в чем между ними разница? Когда возникает ConcurrentModificationException?

Итератор в Java — это объект, который предоставляет способ последовательного доступа к элементам коллекции без
необходимости знать внутреннее представление этой коллекции. Итераторы используются для перебора элементов коллекций,
таких как списки, множества и другие структуры данных, реализующие интерфейс java.util.Collection.

Iterator и ListIterator — это два интерфейса в Java, которые используются для перебора элементов коллекций. Iterator:
Может использоваться с любыми коллекциями, реализующими интерфейс Collection (например, List, Set, Queue).
ListIterator: Предназначен только для коллекций, реализующих интерфейс List (например, ArrayList, LinkedList).

Iterator: Поддерживает только односторонний перебор — от начала к концу коллекции.
ListIterator: Поддерживает двусторонний перебор — можно перемещаться как вперёд, так и назад по коллекции.

Iterator: Не предоставляет информации об индексах элементов.
ListIterator: Позволяет получить текущий индекс с помощью методов nextIndex() и previousIndex().

Iterator: Поддерживает удаление элементов с помощью метода remove(). Других изменений коллекции (например, добавления
элементов) не поддерживает.
ListIterator: Поддерживает удаление (remove()), замену (set(E e)) и добавление (add(E e)) элементов в коллекцию.

Iterator: Начинает перебор с самого начала коллекции.
ListIterator: Может начинать перебор с любого заданного индекса, что позволяет более гибкое управление порядком
перебора.

Fail-fast итераторы бросают исключение ConcurrentModificationException, если коллекция модифицируется (добавление,
удаление, изменение элементов) в процессе итерации любым способом, кроме использования методов самого итератора (
например, remove() у итератора).

Как работает fail-fast механизм:
Итераторы fail-fast проверяют "структурные модификации" коллекции при каждом вызове метода, такого как next() или
remove().
Внутри коллекции есть счетчик модификаций (modification count), который увеличивается при структурных изменениях.
Итератор сохраняет значение этого счетчика на момент своего создания и сравнивает его с текущим значением при каждой
операции.
Если значения не совпадают (например, элемент был добавлен или удален через саму коллекцию, а не через итератор), то
генерируется ConcurrentModificationException.

Fail-safe итераторы не бросают исключение при модификации коллекции во время итерации. Вместо этого они работают с
копией данных коллекции, что позволяет избежать конфликтов.

Как работает fail-safe механизм:
Fail-safe итераторы работают на "слабых копиях" данных. Это означает, что любые изменения, внесенные в коллекцию после
создания итератора, не видны итератору.
Такие итераторы обеспечивают безопасный доступ, но изменения в коллекции не отражаются на итераторе, и наоборот —
изменения через итератор не отражаются на коллекции.

[К оглавлению](#CollectionsPro)

# 8. Что такое коллекции?

Коллекции в Java — это фреймворк (набор классов и интерфейсов), который предоставляет архитектуру для хранения и
обработки групп объектов. Коллекции позволяют управлять группами объектов, выполнять над ними различные операции, такие
как добавление, удаление, поиск, сортировка и перебор элементов. Для хранения набора данных в Java предназначены
массивы. Однако массивы не
всегда удобно использовать в первую очередь потому, что массивы имеют фиксированный размер. Поэтому эту проблему в Java
решают коллекции. Но дело не только в том, что коллекции обладают свойством автоматического расширения своего размера,
но и то, что классы коллекций реализуют различные алгоритмы и структуры данных. Поэтому мы имеем хорошо оптимизированные
структуры данных, которые описывают легкие способы работы с данными и при правильном выборе коллекции мы можем ускорить
работу нашего приложения. Основные особенности коллекций:

- Универсальность: Коллекции могут хранить любые объекты (кроме примитивных типов, хотя можно использовать их обертки,
  такие как Integer, Double и т.д.).
- Типобезопасность: Благодаря Generics коллекции позволяют хранить объекты определенного типа, что помогает избежать
  ошибок времени выполнения.
- Структурированность: Коллекции упрощают работу с группами данных, предоставляя мощные методы для управления
  элементами.

[К оглавлению](#CollectionsPro)

# 9. Назовите базовые интерфейсы коллекций?

Collection<E>:Базовый интерфейс для большинства коллекций. Расширяет интерфейс Iterable.
Определяет основные методы, такие как add(), remove(), size(), clear() и другие.

Map<K, V>:Коллекция, хранящая пары "ключ-значение".
Ключи уникальны, значения могут повторяться.
Не наследует интерфейс Collection, но является важной частью коллекционного фреймворка.

[К оглавлению](#CollectionsPro)

# 10. Расскажите реализации интерфейса List?

Представляет упорядоченную коллекцию (список), которая может содержать дублирующиеся элементы. Поддерживает доступ по
индексу(элементы списка можно напрямую получать, добавлять, изменять или удалять, используя индекс, который представляет
позицию элемента в списке.)

- ArrayList - на массиве с несинхронизированными методами.
- LinkedList - двусвязный список.
- Vector - на массиве с синхронизированными методами.
- Stack - на массиве есть синхронизированные методы, но не все.

[К оглавлению](#CollectionsPro)

# 11. Расскажите реализации интерфейса Set?

Коллекция, которая не содержит дублирующихся элементов. Не гарантирует порядок элементов (например, HashSet), хотя есть
реализации, сохраняющие порядок (например, LinkedHashSet) или упорядоченные (например, TreeSet).

- HashSet - основан на HashMap.
- LinkedHashSet - расширяет HashSet, позволяет получать элементы в порядке их добавления, но требует больше памяти.
- TreeSet - основан на сбалансированном двоичном дереве, в результате элементы упорядочены по возрастанию hashCode()'ов.
  Можно управлять порядком при помощи компаратора.

[К оглавлению](#CollectionsPro)

# 12. Расскажите реализации интерфейса Map?

Коллекция, хранящая пары "ключ-значение". Ключи уникальны, значения могут повторяться. Не наследует интерфейс
Collection, но является важной частью коллекционного фреймворка.

- HashMap - основан на хэш-таблицах. Ключи и значения могут быть любых типов, в том числе и null. Данная реализация не
  дает гарантий относительно порядка элементов.
- LinkedHashMap - расширяет класс HashMap. Он создает связный список элементов в карте, расположенных в том порядке, в
  котором они вставлялись.
- TreeMap - Он создает коллекцию, которая для хранения элементов применяет дерево. Объекты сохраняются в отсортированном
  порядке по возрастанию.

[К оглавлению](#CollectionsPro)

# 13. Отличие ArrayList от LinkedList?

Отличаются по структуре данных, возможности доступа по индексу, добавлением элементов, удалением элементов,
использованию памяти, поддержке очередей и стеков, по тому, как проходит итерация по элементам, по тому как изменяется
размер структуры.

ArrayList основан на массиве динамической длины. LinkedList - Двусвязный список (каждый элемент хранит ссылку на
предыдущий и следующий элемент).
ArrayList Быстрый доступ по индексу (O(1)). LinkedList Медленный доступ по индексу (O(n)), так как необходимо перебирать
элементы.
ArrayList Быстро добавляет элементы в конец (O(1)), медленно в середину или начало (O(n)). LinkedList Быстрое добавление
в начало или конец (O(1)), медленное добавление в середину (O(n)).
ArrayList Медленное удаление элементов (O(n)), так как требует сдвига элементов. LinkedList Быстрое удаление в начале
или конце (O(1)), медленное удаление в середине (O(n)).
ArrayList быстрая итерация по элементам, тк они расположены в непрерывной области. LinkedList - Медленная, из-за доступа
по ссылкам между элементами.
ArrayList Не поддерживает напрямую операции очереди/стека, но можно реализовать(его можно использовать для реализации
этих структур данных с помощью предоставляемых методов). LinkedList Имеет методы addFirst(), addLast(), removeFirst(),
removeLast(), идеально подходит для очередей и стеков.  
ArrayList При достижении предела увеличивает массив, копируя элементы в новый массив большего размера. LinkedList Нет
необходимости в реаллокации, элементы добавляются динамически.
ArrayList Меньше дополнительной памяти, кроме массива данных. LinkedList Требует больше памяти для хранения ссылок на
соседние элементы.

[К оглавлению](#CollectionsPro)

# 14. Отличие Set от List?

Set - множество, не хранит дубликаты.

List - список, может содержать дубли.

[К оглавлению](#CollectionsPro)

# 15. Расскажите про методы Object hashCode и equals?

Методы, необходимые для определения равенства объектов.
Hashcode возвращает число, являющееся уникальным идентификатором объекта.
Это алгоритм, который позволяет множество значений объектов сузить
до какого-то натурального количества.
Equals сравнивает объекты по значению их полей. Объекты всех коллекций,
в названии которых есть Hash... должны иметь hashcode и equals.
Метод hashCode() используется для числового представления объекта, метод equals() для сравнения двух объектов. При
переопределении метода equals() всегда переопределяют hashCode(). Если метод equals() возвращает true, то hashCode()
всегда равны, но не наоборот, потому что возможны коллизии, когда для разных объектов будет одинаковый hashCode(). "
Множество объектов мощнее множества хеш-кодов." Множество возможных хеш-кодов ограничено диапазоном примитивного типа
int 2^32, а множество объектов ничем не ограничено.

Метод equals() переопределяется так:
Не равны ли ссылки.
Не равен null.
Проверяем что объекты от одного класса.
Не равны ли hashCode.
Не равны состояния полей.

Метод hashCode() переопределяется так:
Простое нечетное число (31 популярно).
Умножаем результат на другое простое нечетное число (популярно 17). Прибавляем хэш-код поля, которое относится к
бизнес-логике. Повторяем пункт 2 пока не кончатся поля, которые относятся к бизнес-логике.

[К оглавлению](#CollectionsPro)

# 16. Расскажите, что такое коллизии в Map? Как с ними бороться?

Коллизии в Map происходят, когда два или более ключа хешируются в один и тот
же бакет в хеш-таблице. Это может привести к тому, что различные ключи будут иметь одинаковый хеш-код, что
затрудняет их уникальное определение и может снизить эффективность работы структуры данных. Хеш-функция: Когда вы
добавляете элемент в Map, хеш-функция вычисляет хеш-код ключа, который определяет, в каком бакете хранится
элемент.
Коллизия: Если два или более ключа имеют одинаковый хеш-код, они будут помещены в одну и ту же корзину. Например, если
хеш-функция вычисляет одинаковый индекс для двух разных ключей, они будут храниться в одной корзине.

В Java для разрешения коллизий используется модифицированный метод цепочек. Суть: когда количество элементов в корзине
превышает определенное значение, данная корзина переходит от использования связного списка к использованию
сбалансированного дерева. Но данный метод имеет смысл лишь тогда, когда на элементах хеш-таблицы задан линейный порядок.
Т.е. при использовании данных типа int или double имеет смысл переходить к дереву поиска, а при использовании
каких-нибудь ссылок на объекты не имеет, т.к. они не реализуют нужный интерфейс. Такой подход позволяет улучшить
производительность с O(n) до O(log(n)). Данный способ используется в таких коллекциях как HashMap, LinkedHashMap и
ConcurrentHashMap.

Коллизия - это когда для двух объектов вычисляется одинаковый хеш-код.
Решение: проверить методом equals(), что ссылки на объекты не равны. Для хэш-таблицы в ту же ячейку добавляется еще один
объект, за счет того что каждая ячейка - это связанный список.

hashCode позволяет определить корзину для поиска элемента,
а equals используется для сравнения ключей элементов
в списке внутри корзины и искомого ключа.

[К оглавлению](#CollectionsPro)

# 17. Расскажите, что такое анализ алгоритма?

Анализ алгоритма дает нам понимание того, сколько времени займет решение данной задачи при помощи данного алгоритма.
Эффективность алгоритма оценивается его временной сложностью.

Временная сложность алгоритма – это функция, позволяющая определить, как быстро увеличивается время работы алгоритма с
увеличением объёма данных.

Наиболее часто встречающиеся классы сложности:

- O(1) – константная сложность (т.е. константное время);
- О(n) – линейная сложность;
- О(nа) – полиномиальная сложность;
- О(log(n)) – логарифмическая сложность;
- O(n*log(n)) – квазилинейная сложность;
- O(2n) – экспоненциальная сложность;
- O(n!) – факториальная сложность.

[К оглавлению](#CollectionsPro)

# 18. Какая временная сложность алгоритмов добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?

![img](https://github.com/itlazykin/answers_to_exam_questions/tree/main/main/resources/Временная сложность коллекций.png)

+ **`ArrayList`:** индекс - `O(1)`, поиск `O(n)`, вставка `O(n)`, удаление `O(n)`.
+ **`LinkedList`:** индекс - `O(n)`, поиск `O(n)`, вставка `O(1)`, удаление `O(1)`.
+ **Деревья** для всех операций - `O(log(n))`.
+ **Хэш таблицы** для всех операций - `O(1)`, если не считать коллизии.

[К оглавлению](#CollectionsPro)

# 19. Расскажите реализации данных очередей и стеков.

[К оглавлению](#CollectionsPro)

# 20. Расскажите про реализации деревьев.

[К оглавлению](#CollectionsPro)

# 21. Что такое loadFactor?

[К оглавлению](#CollectionsPro)

# 22. Перечислите побитовые логические операции, которые Вы знаете? Расскажите, как они работают.

[К оглавлению](#CollectionsPro)

# 23. Расскажите про операции сдвига. Какие они бывают и что делают?

[К оглавлению](#CollectionsPro)

# 24. Как хранится знак числа в Java? Как хранятся отрицательные числа?

[К оглавлению](#CollectionsPro)

# 25. Расскажите о системах сборки проекта. В чем отличие систем сборки Ant, Maven и Gradle?

[К оглавлению](#CollectionsPro)

# 26. Как создать maven проект?

[К оглавлению](#CollectionsPro)

# 27. Какова структура maven-проекта?

[К оглавлению](#CollectionsPro)

# 28. Расскажите о файле pom xml. Как он структурирован и за что отвечает содержание каждой части?

[К оглавлению](#CollectionsPro)

# 29. Что такое координаты зависимости?

[К оглавлению](#CollectionsPro)

# 30. Что такое транзитивные зависимости?

[К оглавлению](#CollectionsPro)

# 31. Что такое область видимости зависимости? Сколько областей видимости предусмотрено и где они применяются?

[К оглавлению](#CollectionsPro)

# 32. Расскажите о жизненном цикле maven. В какой последовательности выполняются фазы цикла и что происходит на каждой фазе сборки?

[К оглавлению](#CollectionsPro)

