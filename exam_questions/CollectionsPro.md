## CollectionsPro

[1. Что такое generics?](#1-что-такое-generics)

[2. Что такое wild cards?](#2-что-такое-wild-cards)

[3. Что такое bounded wild cards?](#3-что-такое-bounded-wild-cards)

[4. Что такое unbounded wild cards?](#4-Что-такое-unbounded-wild-cards)

[5. Где хранится информация про Generics?](#5-Где-хранится-информация-про-Generics)

[6. Как можно получить тип Generics?](#6-Как-можно-получить-тип-Generics)

[7. Что такое итератор? В чем разница между iterator и listIterator? Что такое fail-fast и fail-safe поведение итератора и в чем между ними разница? Когда возникает ConcurrentModificationException?](#7-Что-такое-итератор-В-чем-разница-между-iterator-и-listIterator-Что-такое-fail-fast-и-fail-safe-поведение-итератора-и-в-чем-между-ними-разница-Когда-возникает-ConcurrentModificationException)

[8. Что такое коллекции?](#8-Что-такое-коллекции)

[9. Назовите базовые интерфейсы коллекций?](#9-Назовите-базовые-интерфейсы-коллекций)

[10. Расскажите реализации интерфейса List?](#10-Расскажите-реализации-интерфейса-List)

[11. Расскажите реализации интерфейса Set?](#11-Расскажите-реализации-интерфейса-Set)

[12. Расскажите реализации интерфейса Map?](#12-Расскажите-реализации-интерфейса-Map)

[13. Отличие ArrayList от LinkedList?](#13-Отличие-ArrayList-от-LinkedList)

[14. Отличие Set от List?](#14-Отличие-Set-от-List)

[15. Расскажите про методы Object hashCode и equals?](#15-Расскажите-про-методы-Object-hashCode-и-equals)

[16. Расскажите, что такое коллизии в Map? Как с ними бороться?](#16-Расскажите-что-такое-коллизии-в-Map-Как-с-ними-бороться)

[17. Расскажите, что такое анализ алгоритма?](#17-Расскажите-что-такое-анализ-алгоритма)

[18. Какая временная сложность алгоритмов добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?](#18-Какая-временная-сложность-алгоритмов-добавления-замены-и-удаления-в-каждой-из-коллекций-С-чем-связаны-отличия)

[19. Расскажите реализации данных очередей и стеков.](#19-Расскажите-реализации-данных-очередей-и-стеков)

[20. Расскажите про реализации деревьев.](#20-Расскажите-про-реализации-деревьев)

[21. Что такое loadFactor?](#21-Что-такое-loadFactor)

[22. Перечислите побитовые логические операции, которые Вы знаете? Расскажите, как они работают.](#22-Перечислите-побитовые-логические-операции-которые-Вы-знаете-Расскажите-как-они-работают)

[23. Расскажите про операции сдвига. Какие они бывают и что делают?](#23-Расскажите-про-операции-сдвига-Какие-они-бывают-и-что-делают)

[24. Как хранится знак числа в Java? Как хранятся отрицательные числа?](#24-Как-хранится-знак-числа-в-Java-Как-хранятся-отрицательные-числа)

[25. Расскажите о системах сборки проекта. В чем отличие систем сборки Ant, Maven и Gradle?](#25-Расскажите-о-системах-сборки-проекта-В-чем-отличие-систем-сборки-Ant-Maven-и-Gradle)

[26. Как создать maven проект?](#26-Как-создать-maven-проект)

[27. Какова структура maven проекта?](#27-Какова-структура-maven-проекта)

[28. Расскажите о файле pom xml. Как он структурирован и за что отвечает содержание каждой части?](#28-Расскажите-о-файле-pom-xml-Как-он-структурирован-и-за-что-отвечает-содержание-каждой-части)

[29. Что такое координаты зависимости?](#29-Что-такое-координаты-зависимости)

[30. Что такое транзитивные зависимости?](#30-Что-такое-транзитивные-зависимости)

[31. Что такое область видимости зависимости? Сколько областей видимости предусмотрено и где они применяются?](#31-Что-такое-область-видимости-зависимости-Сколько-областей-видимости-предусмотрено-и-где-они-применяются)

[32. Расскажите о жизненном цикле maven. В какой последовательности выполняются фазы цикла и что происходит на каждой фазе сборки?](#32-Расскажите-о-жизненном-цикле-maven-В-какой-последовательности-выполняются-фазы-цикла-и-что-происходит-на-каждой-фазе-сборки)

# 1. Что такое generics?

Начиная с Java 5 в языке программирования появились возможности обобщенного программирования. До этого программисту
приходилось выполнять приведение каждого объекта, прочитанного из коллекции. Если кто-то случайно вставлял туда объект
неправильного типа, приведение могло вызвать runtime exception. С помощью обобщенных типов можно сообщить компилятору,
какие типы допускаются в каждой коллекции. Компилятор автоматически добавит приведение типов и во время компиляции
обнаружит попытки вставить объект неправильного типа, и у нас в рантайме уже ничего не упадет.
Это делает программы более безопасными и ясными. С их помощью можно объявлять классы,
интерфейсы и методы, где тип данных указан в виде параметра.
[К оглавлению](#CollectionsPro)

# 2. Что такое wild cards?

Wildcards в Java используются в обобщениях для обозначения неизвестного типа. Это удобно, когда вы хотите работать с
различными типами данных, но не хотите жёстко задавать конкретный тип. Wildcards представляются символом вопросительного
знака (?). Используется, когда тип данных может быть абсолютно любым. Если необходимо читать из контейнера, то
используйте wildcard с верхней границей "? extends". Если необходимо
писать в контейнер, то используйте wildcard с нижней границей "? super". Не используйте wildcard, если нужно производить
и запись, и чтение.

````java
List<?> list = new ArrayList<>();
`````

[К оглавлению](#CollectionsPro)

# 3. Что такое bounded wild cards?

Ограниченный wildcard с верхней границей (<? extends Type>): Используется, когда тип данных должен быть подтипом (или
самим типом) указанного класса. Например:

````java
List<? extends Number> list = new ArrayList<>();
````

Здесь list может содержать элементы типа Number, Integer, Double, и других классов, которые являются подтипами Number.

[К оглавлению](#CollectionsPro)

# 4. Что такое unbounded wild cards?

Ограниченный wildcard с нижней границей (<? super Type>):
Используется, когда тип данных должен быть суперклассом (или самим типом) указанного класса. Например:

````java
List<? super Integer> list = new ArrayList<>();
````

В этом случае list может содержать элементы типа Integer, Number, или Object (так как они являются супер классами
Integer).

[К оглавлению](#CollectionsPro)

# 5. Где хранится информация про Generics?

После компиляции JVM не имеет информации о типах параметров обобщений. Все данные о Generics используются только на
этапе компиляции для обеспечения типовой безопасности и не сохраняются в байт-коде. Процесс удаления информации о типах
во время компиляции называется стирание типов. Во время компиляции все параметры типов в обобщениях (Generics)
заменяются на их границы или на Object, если границы не указаны. Например, List<String> и List<Integer> после
компиляции становятся просто List. Почему нельзя создавать массивы обобщённых типов или напрямую проверять тип обобщения
с помощью instanceof во время выполнения — эта информация просто недоступна в байт-коде.

[К оглавлению](#CollectionsPro)

# 6. Как можно получить тип Generics?

Если обобщённый тип задан в классе или интерфейсе как параметризованный тип, вы можете получить информацию о нём с
помощью рефлексии.

````java
public class GenericTypeDemo<T> {
    public static void main(String[] args) {
        // Анонимный класс для захвата информации о типе обобщения
        GenericTypeDemo<String> instance = new GenericTypeDemo<String>() {
        };
        Type superclass = instance.getClass().getGenericSuperclass();

        if (superclass instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) superclass;
            Type[] typeArguments = parameterizedType.getActualTypeArguments();
            for (Type typeArgument : typeArguments) {
                System.out.println("Тип обобщения: " + typeArgument);
            }
        }
    }
````

Используется анонимный подкласс (GenericTypeDemo<String> instance = new GenericTypeDemo<String>() {}), чтобы обойти Type
Erasure и сохранить информацию о типе обобщения, которую затем можно извлечь с помощью рефлексии.

Ещё один способ сохранить информацию о типе — передать его явно в конструктор или метод в виде класса (Class<T>):

````java
public class GenericClass<T> {
    private Class<T> type;

    public GenericClass(Class<T> type) {
        this.type = type;
    }

    public void printType() {
        System.out.println("Тип обобщения: " + type.getName());
    }

    public static void main(String[] args) {
        GenericClass<String> instance = new GenericClass<>(String.class);
        instance.printType();  // Выведет: Тип обобщения: java.lang.String
    }
}
````

[К оглавлению](#CollectionsPro)

# 7. Что такое итератор? В чем разница между iterator и listIterator? Что такое fail-fast и fail-safe поведение итератора и в чем между ними разница? Когда возникает ConcurrentModificationException?

Итератор в Java — это объект, который предоставляет способ последовательного доступа к элементам коллекции без
необходимости знать внутреннее представление этой коллекции. Итераторы используются для перебора элементов коллекций,
таких как списки, множества и другие структуры данных, реализующие интерфейс java.util.Collection.

Iterator и ListIterator — это два интерфейса в Java, которые используются для перебора элементов коллекций. Iterator:
Может использоваться с любыми коллекциями, реализующими интерфейс Collection (например, List, Set, Queue).
ListIterator: Предназначен только для коллекций, реализующих интерфейс List (например, ArrayList, LinkedList).

Iterator: Поддерживает только односторонний перебор — от начала к концу коллекции.
ListIterator: Поддерживает двусторонний перебор — можно перемещаться как вперёд, так и назад по коллекции.

Iterator: Не предоставляет информации об индексах элементов.
ListIterator: Позволяет получить текущий индекс с помощью методов nextIndex() и previousIndex().

Iterator: Поддерживает удаление элементов с помощью метода remove(). Других изменений коллекции (например, добавления
элементов) не поддерживает.
ListIterator: Поддерживает удаление (remove()), замену (set(E e)) и добавление (add(E e)) элементов в коллекцию.

Iterator: Начинает перебор с самого начала коллекции.
ListIterator: Может начинать перебор с любого заданного индекса, что позволяет более гибкое управление порядком
перебора.

Fail-fast итераторы бросают исключение ConcurrentModificationException, если коллекция модифицируется (добавление,
удаление, изменение элементов) в процессе итерации любым способом, кроме использования методов самого итератора (
например, remove() у итератора).

Как работает fail-fast механизм:
Итераторы fail-fast проверяют "структурные модификации" коллекции при каждом вызове метода, такого как next() или
remove().
Внутри коллекции есть счетчик модификаций (modification count), который увеличивается при структурных изменениях.
Итератор сохраняет значение этого счетчика на момент своего создания и сравнивает его с текущим значением при каждой
операции.
Если значения не совпадают (например, элемент был добавлен или удален через саму коллекцию, а не через итератор), то
генерируется ConcurrentModificationException.

Fail-safe итераторы не бросают исключение при модификации коллекции во время итерации. Вместо этого они работают с
копией данных коллекции, что позволяет избежать конфликтов.

Как работает fail-safe механизм:
Fail-safe итераторы работают на "слабых копиях" данных. Это означает, что любые изменения, внесенные в коллекцию после
создания итератора, не видны итератору.
Такие итераторы обеспечивают безопасный доступ, но изменения в коллекции не отражаются на итераторе, и наоборот —
изменения через итератор не отражаются на коллекции.

[К оглавлению](#CollectionsPro)

# 8. Что такое коллекции?

Коллекции в Java — это фреймворк (набор классов и интерфейсов), который предоставляет архитектуру для хранения и
обработки групп объектов. Коллекции позволяют управлять группами объектов, выполнять над ними различные операции, такие
как добавление, удаление, поиск, сортировка и перебор элементов. Для хранения набора данных в Java предназначены
массивы. Однако массивы не
всегда удобно использовать в первую очередь потому, что массивы имеют фиксированный размер. Поэтому эту проблему в Java
решают коллекции. Но дело не только в том, что коллекции обладают свойством автоматического расширения своего размера,
но и то, что классы коллекций реализуют различные алгоритмы и структуры данных. Поэтому мы имеем хорошо оптимизированные
структуры данных, которые описывают легкие способы работы с данными и при правильном выборе коллекции мы можем ускорить
работу нашего приложения. Основные особенности коллекций:

- Универсальность: Коллекции могут хранить любые объекты (кроме примитивных типов, хотя можно использовать их обертки,
  такие как Integer, Double и т.д.).
- Типобезопасность: Благодаря Generics коллекции позволяют хранить объекты определенного типа, что помогает избежать
  ошибок времени выполнения.
- Структурированность: Коллекции упрощают работу с группами данных, предоставляя мощные методы для управления
  элементами.

[К оглавлению](#CollectionsPro)

# 9. Назовите базовые интерфейсы коллекций?

Collection<E>:Базовый интерфейс для большинства коллекций. Расширяет интерфейс Iterable.
Определяет основные методы, такие как add(), remove(), size(), clear() и другие.

Map<K, V>:Коллекция, хранящая пары "ключ-значение".
Ключи уникальны, значения могут повторяться.
Не наследует интерфейс Collection, но является важной частью коллекционного фреймворка.

[К оглавлению](#CollectionsPro)

# 10. Расскажите реализации интерфейса List?

Представляет упорядоченную коллекцию (список), которая может содержать дублирующиеся элементы. Поддерживает доступ по
индексу(элементы списка можно напрямую получать, добавлять, изменять или удалять, используя индекс, который представляет
позицию элемента в списке.)

- ArrayList - на массиве с несинхронизированными методами.
- LinkedList - класс, который реализует два интерфейса - List и Deque. Этим обеспечивается возможность создавать
  двунаправленные(те, которые можно обходить в обоих направлениях) очереди из любых (в том числе и null) элементов.
  Каждый объект помещенный в связанный список, является узлом (для этого используются объекты вложенного класса Node).
  Каждый узел содержит в себе элемент который мы добавили, а также ссылку на предыдущий и следующий узел
- Vector - на массиве с синхронизированными методами.
- Stack - на массиве есть синхронизированные методы, но не все.

[К оглавлению](#CollectionsPro)

# 11. Расскажите реализации интерфейса Set?

Коллекция, которая не содержит дублирующихся элементов. Не гарантирует порядок элементов (например, HashSet), хотя есть
реализации, сохраняющие порядок (например, LinkedHashSet) или упорядоченные (например, TreeSet).

- HashSet - основан на HashMap.
- LinkedHashSet - расширяет HashSet, позволяет получать элементы в порядке их добавления, но требует больше памяти.
- TreeSet - основан на сбалансированном двоичном дереве, в результате элементы упорядочены по возрастанию hashCode()'ов.
  Можно управлять порядком при помощи компаратора.

[К оглавлению](#CollectionsPro)

# 12. Расскажите реализации интерфейса Map?

Коллекция, хранящая пары "ключ-значение". Ключи уникальны, значения могут повторяться. Не наследует интерфейс
Collection, но является важной частью коллекционного фреймворка.

- HashMap - основан на хэш-таблицах. Ключи и значения могут быть любых типов, в том числе и null, подходит для
  большинства стандартных случаев, когда не требуется порядок элементов.
- LinkedHashMap - расширяет класс HashMap. Он создает связный список элементов в карте, расположенных в том порядке, в
  котором они вставлялись.
- TreeMap - Он создает коллекцию, которая для хранения элементов применяет дерево. Объекты сохраняются в отсортированном
  порядке по возрастанию.

[К оглавлению](#CollectionsPro)

# 13. Отличие ArrayList от LinkedList?

Отличаются по структуре данных, возможности доступа по индексу, добавлением элементов, удалением элементов,
использованию памяти, поддержке очередей и стеков, по тому, как проходит итерация по элементам, по тому как изменяется
размер структуры.

ArrayList основан на массиве динамической длины. LinkedList - Двусвязный список (каждый элемент хранит ссылку на
предыдущий и следующий элемент).
ArrayList Быстрый доступ по индексу (O(1)). LinkedList Медленный доступ по индексу (O(n)), так как необходимо перебирать
элементы.
ArrayList Быстро добавляет элементы в конец (O(1)), медленно в середину или начало (O(n)). LinkedList Быстрое добавление
в начало или конец (O(1)), медленное добавление в середину (O(n)).
ArrayList Медленное удаление элементов (O(n)), так как требует сдвига элементов. LinkedList Быстрое удаление в начале
или конце (O(1)), медленное удаление в середине (O(n)).
ArrayList быстрая итерация по элементам, тк они расположены в непрерывной области. LinkedList - Медленная, из-за доступа
по ссылкам между элементами.
ArrayList Не поддерживает напрямую операции очереди/стека, но можно реализовать(его можно использовать для реализации
этих структур данных с помощью предоставляемых методов). LinkedList Имеет методы addFirst(), addLast(), removeFirst(),
removeLast(), идеально подходит для очередей и стеков.  
ArrayList При достижении предела увеличивает массив, копируя элементы в новый массив большего размера. LinkedList Нет
необходимости в реаллокации, элементы добавляются динамически.
ArrayList Меньше дополнительной памяти, кроме массива данных. LinkedList Требует больше памяти для хранения ссылок на
соседние элементы.

[К оглавлению](#CollectionsPro)

# 14. Отличие Set от List?

Set - множество, не хранит дубликаты.

List - список, может содержать дубли.

[К оглавлению](#CollectionsPro)

# 15. Расскажите про методы Object hashCode и equals?

Методы, необходимые для определения равенства объектов.
Hashcode возвращает число, являющееся уникальным идентификатором объекта.
Это алгоритм, который позволяет множество значений объектов сузить
до какого-то натурального количества.
Equals сравнивает объекты по значению их полей. Объекты всех коллекций,
в названии которых есть Hash... должны иметь hashcode и equals.
Метод hashCode() используется для числового представления объекта, метод equals() для сравнения двух объектов. При
переопределении метода equals() всегда переопределяют hashCode(). Если метод equals() возвращает true, то hashCode()
всегда равны, но не наоборот, потому что возможны коллизии, когда для разных объектов будет одинаковый hashCode(). "
Множество объектов мощнее множества хеш-кодов." Множество возможных хеш-кодов ограничено диапазоном примитивного типа
int 2^32, а множество объектов ничем не ограничено.

Метод equals() переопределяется так:
Не равны ли ссылки.
Не равен null.
Проверяем что объекты от одного класса.
Не равны ли hashCode.
Не равны состояния полей.

Метод hashCode() переопределяется так:
Простое нечетное число (31 популярно).
Умножаем результат на другое простое нечетное число (популярно 17). Прибавляем хэш-код поля, которое относится к
бизнес-логике. Повторяем пункт 2 пока не кончатся поля, которые относятся к бизнес-логике.

[К оглавлению](#CollectionsPro)

# 16. Расскажите, что такое коллизии в Map? Как с ними бороться?

Коллизии в Map происходят, когда два или более ключа хешируются в один и тот
же бакет в хеш-таблице. Это может привести к тому, что различные ключи будут иметь одинаковый хеш-код, что
затрудняет их уникальное определение и может снизить эффективность работы структуры данных. Хеш-функция: Когда вы
добавляете элемент в Map, хеш-функция вычисляет хеш-код ключа, который определяет, в каком бакете хранится
элемент.
Коллизия: Если два или более ключа имеют одинаковый хеш-код, они будут помещены в одну и ту же корзину. Например, если
хеш-функция вычисляет одинаковый индекс для двух разных ключей, они будут храниться в одной корзине.

В Java для разрешения коллизий используется модифицированный метод цепочек. Суть: когда количество элементов в корзине
превышает определенное значение, данная корзина переходит от использования связного списка к использованию
сбалансированного дерева. Но данный метод имеет смысл лишь тогда, когда на элементах хеш-таблицы задан линейный порядок.
Т.е. при использовании данных типа int или double имеет смысл переходить к дереву поиска, а при использовании
каких-нибудь ссылок на объекты не имеет, т.к. они не реализуют нужный интерфейс. Такой подход позволяет улучшить
производительность с O(n) до O(log(n)). Данный способ используется в таких коллекциях как HashMap, LinkedHashMap и
ConcurrentHashMap.

Коллизия - это когда для двух объектов вычисляется одинаковый хеш-код.
Решение: проверить методом equals(), что ссылки на объекты не равны. Для хэш-таблицы в ту же ячейку добавляется еще один
объект, за счет того что каждая ячейка - это связанный список.

hashCode позволяет определить корзину для поиска элемента,
а equals используется для сравнения ключей элементов
в списке внутри корзины и искомого ключа.

[К оглавлению](#CollectionsPro)

# 17. Расскажите, что такое анализ алгоритма?

Анализ алгоритма дает нам понимание того, сколько времени займет решение данной задачи при помощи данного алгоритма.
Эффективность алгоритма оценивается его временной сложностью.
Временная сложность алгоритма – это функция, позволяющая определить, как быстро увеличивается время работы алгоритма с
увеличением объёма данных.
Наиболее часто встречающиеся классы сложности:

- O(1) – константная сложность (т.е. константное время);
- О(n) – линейная сложность;
- О(nа) – полиномиальная сложность;
- О(log(n)) – логарифмическая сложность;
- O(n*log(n)) – квазилинейная сложность;
- O(2n) – экспоненциальная сложность;
- O(n!) – факториальная сложность.

[К оглавлению](#CollectionsPro)

# 18. Какая временная сложность алгоритмов добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?

![img](https://github.com/itlazykin/answers_to_exam_questions/blob/main/main/resources/%D0%92%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F%20%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C%20%D0%BA%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9.png)

+ **`ArrayList`:** индекс - `O(1)`, поиск `O(n)`, вставка `O(n)`, удаление `O(n)`.
+ **`LinkedList`:** индекс - `O(n)`, поиск `O(n)`, вставка `O(1)`, удаление `O(1)`.
+ **Деревья** для всех операций - `O(log(n))`.
+ **Хэш таблицы** для всех операций - `O(1)`, если не считать коллизии.

[К оглавлению](#CollectionsPro)

# 19. Расскажите реализации данных очередей и стеков.

- Queue (FIFO) - односторонняя очередь, элементы можно получить в том порядке в котором добавляли. Такая очередь
  позволяет поместить элементы в один конец очереди, а извлекать их – из другого. LinkedList, ArrayBlockingQueue и
  PriorityQueue — наиболее часто используемые реализации интерфейса Queue.
- Dequeue (расширяет Queue) - двусторонняя очередь, можно вставлять/получать элементы из начала и конца. Наиболее часто
  используемой реализацией интерфейса Deque является класс LinkedList.
  Из документации следует, что LinkedList - реализует Dequeue, а так же интерфейс Queue со всеми его методами.
  Следовательно, при создании объекта LinkedList можно использовать оба базовых типа указанных интерфейсов следующие обе
  строки кода будут работать без проблем:

````java
Queue<String> queue = new LinkedList<>();
Deque<String> deque = new LinkedList<>();
````

- Stack (LIFO) - стек, можно получить только последний элемент. Stack - примитивная структура данных. Работу этой
  структуры можно представить в виде тарелок, поставленных друг на друга.
  Новая тарелка всегда оказывается верхней. Если нам нужно достать тарелку из середины стопки, то нужно снять верхние
  тарелки. Stack лучше всего реализовать на базе связанного списка. Связанный список умеет быстро вставлять данные и
  удалять с начала или конца. Это поведение как раз и нужно при реализации стека.

[К оглавлению](#CollectionsPro)

# 20. Расскажите про реализации деревьев.

В Java используются красно-черные деревья бинарного поиска - RB Tree. Базовый элемент дерева - это узел. Узел хранит в
себе данные и ссылки на другие узлы. Однако может иметь только одного предка - узел предшественника. Родительский узел
может иметь от 0 до N потомков. В случае с бинарным деревом родительский узел может иметь от 0 до 2 потоков. В деревьях
не могут быть циклические связи. В узел можно прийти только единственным путем. Родительский узел имеет левый и правый
узел, которые могут быть null ссылками. Дерево может быть бинарным, но может не быть деревом поиска, но всякое дерево
поиска бинарное. Чтобы бинарное дерево стало бинарным деревом поиска нужно выполнить правило:

- Значение левого потомка должно быть меньше родительского.
- Значение правого потомка должно быть больше или равно родительскому.

Основные реализации:

- TreeMap - упорядоченная по ключам. Основана на красно-черных деревьях. Может использовать компаратор в конструкторе.
  Красно-черные дерево - это самобалансирующееся дерево, которое гарантирует логарифмический рост высоты дерева от числа
  узлов.
- TreeSet - основан на сбалансированном двоичном дереве, в результате элементы упорядочены по возрастанию хеш-кодов.
  Можно
  управлять порядком при помощи компаратора.

[К оглавлению](#CollectionsPro)

# 21. Что такое loadFactor?

loadFactor - это коэффициент загрузки, равен соотношению (размер коллекции / количество элементов). При достижении
порогового значения размер коллекции увеличивается.

Например, в хеш-таблице поле, оно показывает на сколько заполнен массив, на котором эта таблица основана. Если на
3/4, то создается новый массив с большим размером и данные перераспределяются.

[К оглавлению](#CollectionsPro)

# 22. Перечислите побитовые логические операции, которые Вы знаете? Расскажите, как они работают.

- Побитовое "ИЛИ" (|). В результирующий бит будет записана единица, если хотя бы один операнд равен единице.
- Побитовое "И" (&). В результирующий бит будет записана единица только в том случае, если оба операнда равны единице.
- Побитовое "Исключающее ИЛИ" (^). По-другому называется XOR (исключение - X, или - OR). В результирующий бит будет
  записана единица только в том случае, если операнды не равны между собой.
- Унарная операция "НЕ" (~). По-другому называется поразрядным отрицанием. Инвертирует все двоичные разряды числа, то
  есть меняет значение каждого разряда на противоположное.

[К оглавлению](#CollectionsPro)

# 23. Расскажите про операции сдвига. Какие они бывают и что делают?

- Беззнаковый сдвиг влево (<<). Сдвигает двоичное представление первого операнда влево на количество бит, заданное во
  втором операнде, знак числа не сохраняется. Младшие(крайние правые) биты при этом заполняются нулями. Сдвиг на 1 бит
  влево соответствует умножению на 2.
- Знаковый сдвиг вправо (>>). Сдвигает двоичное представление первого операнда вправо на количество бит, заданное во
  втором операнде, знак числа сохраняется. Старшие(крайние левые биты) заполняются ведущими нулями (при сдвиге
  положительного числа) или единицами (при сдвиге отрицательного числа). Сдвиг на бит вправо соответствует делению на 2.
- Беззнаковый сдвиг вправо(>>>). Сдвигает двоичное представление первого операнда вправо на количество бит, заданное во
  втором операнде, знак числа не сохраняется. Для положительных чисел работает как деление
- Без знакового(логического) сдвига влево не существует, потому что такой сдвиг не оказывает влияния на старший значащий
  бит(MSB) - крайний левый бит числа, изменяются только крайние правые биты. Кроме того, в процессорах семейства 8086
  арифметический и логический сдвиг выполняют одну и ту же операцию.

Примеры применения битовых операций:

- Ускорение операций умножения и деления чисел на два. Примеры можно увидеть в стандартной библиотеке jdk. Важно
  понимать, что сдвиги намного хуже читаются в коде, нежели обычные арифметические операции, поэтому применять их нужно
  согласованно на уровне команды/проекта, иначе другие программисты могут внезапно столкнуться со сложностями чтения
  такого кода.
- Битовые поля(флаги). Пример: пусть есть права на доступ - чтение, запись, выполнение. Их удобнее хранить не в трёх
  разных переменных, а в одной, устанавливая соответствующие биты.
- Алгоритмы шифрования и сжатия (например, Шифр Вернама построен на XOR).
- Работа с графикой.
- Работа с сетью.

  [К оглавлению](#CollectionsPro)

# 24. Как хранится знак числа в Java? Как хранятся отрицательные числа?

Все примитивные (целочисленные) типы данных в Java (кроме char) представлены со знаком, то есть число может быть
положительным или отрицательным. Знак числа определяет старший двоичный разряд (самый левый). 0 - знак плюс. 1 - знак
минус. Старший двоичный разряд называется дополнительным кодом (или вторым дополнением (two's complement)), так как
хранит только знак числа. Например, в типе int старший двоичный разряд уходит под хранение знака, а под само значение
уходят остальные 31 бит. Чтобы преобразовать положительное число в отрицательное, нужно инвертировать все его биты и к
получившемуся числу добавить 1.

[К оглавлению](#CollectionsPro)

# 25. Расскажите о системах сборки проекта. В чем отличие систем сборки Ant, Maven и Gradle?

Системы сборки проектов в Java автоматизируют процесс компиляции, тестирования, упаковки и развертывания приложений. Они
упрощают управление зависимостями, настройку окружения, автоматизацию задач и многое другое. Основные системы сборки для
Java — это Ant, Maven и Gradle. Основные отличия:

1) Подход к описанию сборок:

- Ant: Процедурный (что нужно сделать).
- Maven: Декларативный (что нужно получить).
- Gradle: Гибридный (декларативный с возможностью процедурных настроек).

2)Управление зависимостями:

- Ant: Отсутствует встроенная поддержка, ручное управление или через плагины.
- Maven: Встроенное управление через POM и центральные репозитории.
- Gradle: Встроенное управление с поддержкой различных репозиториев и мощных механизмов настройки.

3)Конфигурация:

- Ant: XML, что делает конфигурацию громоздкой.
- Maven: XML с жесткими конвенциями, что упрощает, но иногда ограничивает.
- Gradle: Groovy или Kotlin DSL, что делает конфигурацию более гибкой и читаемой.

4)Производительность:

- Ant: Нет оптимизации для инкрементальных сборок.
- Maven: Ограниченная поддержка инкрементальных сборок.
- Gradle: Поддержка инкрементальных сборок и кэширования, что ускоряет процесс.

[К оглавлению](#CollectionsPro)

# 26. Как создать maven проект?

Качаем maven-> Устанавливаем-> Настраиваем переменные среды. Добавляем путь к maven в PATH-> Открываем командную
строку-> Вводим команду < mvn archetype:generate -DgroupId=com.example -DartifactId=myapp
-DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false >-> После выполнения команды в текущей
директории будет создана папка с именем myapp, содержащая стандартную структуру Maven-проекта:-> В корневой папке
проекта выполните команду: mvn clean install.Команда mvn clean install выполняет очистку предыдущих сборок (clean),
компиляцию, тестирование и упаковку проекта в JAR или WAR файл.

- groupId: Уникальный идентификатор группы, часто соответствует структуре пакетов (например, com.example).
- artifactId: Имя проекта или артефакта (например, myapp).
- archetypeArtifactId: Указывает на шаблон проекта, который будет использован для создания. maven-archetype-quickstart —
  это стандартный архетип для быстрого начала работы с Java-проектами.
- interactiveMode=false: Отключает интерактивный режим, чтобы команда выполнялась автоматически.

[К оглавлению](#CollectionsPro)

# 27. Какова структура maven-проекта?

my-app

|-- pom.xml

`-- src

|-- main

|`-- java

|`-- com

|`-- mycompany

|`-- app

|`-- App.java

`-- test

`-- java

`-- com

`-- mycompany

`-- app

`-- AppTest.java

[К оглавлению](#CollectionsPro)

# 28. Расскажите о файле pom xml. Как он структурирован и за что отвечает содержание каждой части?

Файл pom.xml — основной файл конфигурации Maven, где указываются зависимости, плагины и другие настройки проекта. Файл
pom.xml написан на языке XML и имеет следующую основную структуру:

- Инфо о проекте.
- Описание проекта.
- Управление зависимостями.
- Плагины сборки.
- Репозитории.
- Профили сборки.
- Плагины специфичные для этого профиля.

Основные части pom.xml

1)Корневой элемент 'project'.

- Основной контейнер для всего содержимого pom.xml.
- Атрибуты xmlns, xmlns:xsi, и xsi:
  schemaLocation указывают на схему XML и помогают валидации структуры POM.

2)'modelVersion': Указывает версию модели POM.

3)Информация о проекте:

- 'groupId': Уникальный идентификатор группы, обычно соответствует структуре пакетов организации или проекта (например,
  com.example).
- 'artifactId': Идентификатор проекта или артефакта (например, myapp). Обычно совпадает с именем директории проекта.
- 'version': Версия проекта (например, 1.0.0). Это версия, которая будет использоваться в артефакте сборки.
- 'packaging': Тип артефакта, который будет создан (jar, war, pom, и т.д.). По умолчанию jar.

4)Описание проекта (опционально):

- 'name': Человеко читаемое название проекта.
- 'description': Краткое описание проекта.
- 'url': URL проекта или его домашняя страница.

5)'dependencies':

Управляет зависимостями проекта. Каждая зависимость указывается в элементе <dependency>, включающем:

- 'groupId': Идентификатор группы зависимости.
- 'artifactId': Идентификатор зависимости.
- 'version': Версия зависимости.
- 'scope': Область видимости зависимости (compile, test, provided, runtime, system). Например, test означает, что
  зависимость используется только для тестирования.

6)'build':

Настройки сборки проекта:

- 'plugins': Указывает плагины, используемые в процессе сборки. Например, maven-compiler-plugin для компиляции исходного
  кода.
- 'plugin': Содержит конфигурации для каждого плагина:
- 'groupId', <artifactId>, <version>: Информация о плагине.
- 'configuration': Параметры конфигурации для плагина (например, версия Java для компиляции).
- 'repositories' (опционально): Определяет репозитории для поиска зависимостей, если они не находятся в стандартном
  Maven Central. Может включать как публичные, так и приватные репозитории.
  'profiles' (опционально):Позволяет создавать разные профили сборки с различными настройками (например, для разработки,
  тестирования или
  продакшн-среды). Профили могут активироваться различными способами, такими как наличие определённого файла или
  переменные среды.

[К оглавлению](#CollectionsPro)

# 29. Что такое координаты зависимости?

В Maven координаты зависимости определяют уникальные характеристики каждой зависимости, которые позволяют Maven найти,
загрузить и использовать библиотеку или компонент в вашем проекте. Координаты зависимости состоят из нескольких
обязательных и опциональных элементов, которые уникально идентифицируют конкретную версию артефакта в репозитории.
Основные компоненты координат зависимости:

1)'groupId':

- Уникальный идентификатор группы или организации, к которой принадлежит артефакт. Обычно совпадает с доменным именем
  организации в обратном порядке (например, com.example).

2)artifactId':

- Идентификатор конкретного артефакта или библиотеки. Обычно соответствует названию проекта или модуля (например,
  myapp).

3)'version':

- Версия артефакта. Указывает конкретную версию зависимости, которая будет использоваться. Например, 1.0.0, 2.5.1 или
  1.0.0-SNAPSHOT для версии в стадии разработки.

4)packaging' (опционально для зависимостей):

- Тип упаковки артефакта. Может быть jar, war, pom, и другие. По умолчанию — jar, если не указано иное.

5)'classifier' (опционально):

- Дополнительный идентификатор, который может быть использован для различения артефактов с одинаковыми groupId,
  artifactId, и version, но с различными вариантами (например, источник кода, javadoc, бинарные файлы для разных
  платформ).

6)'scope' (опционально):

- Область видимости зависимости, которая определяет, на каком этапе жизненного цикла сборки зависимость будет
  использоваться (например, compile, test, provided, runtime, system).

Координаты зависимости используются Maven для:

- Идентификации артефактов: Позволяют уникально идентифицировать библиотеку среди множества других в репозиториях.
- Управления зависимостями: Maven использует координаты для загрузки нужных библиотек из репозиториев, таких как Maven
  Central или другие.
- Управления версиями: Координаты позволяют легко обновлять или фиксировать нужные версии библиотек в проекте.
- Управления сборкой: Определение scope помогает Maven оптимизировать сборку проекта, подключая зависимости только там,
  где это необходимо (например, для тестов, компиляции или исполнения

[К оглавлению](#CollectionsPro)

# 30. Что такое транзитивные зависимости?

Это зависимость, которая является зависимостью прямых зависимостей.

[К оглавлению](#CollectionsPro)

# 31. Что такое область видимости зависимости? Сколько областей видимости предусмотрено и где они применяются?

Область видимости зависимости (scope) в Maven определяет, на каком этапе жизненного цикла сборки и в каких контекстах
зависимости будут доступны в проекте. Это помогает оптимизировать управление зависимостями и правильно настроить их
использование.

1)compile

- Описание: Это область видимости по умолчанию, если не указана другая.
- Применение: Зависимости с областью видимости compile доступны на всех этапах сборки: компиляция, тестирование,
  упаковка и выполнение.
    - Также включаются в финальный артефакт (например, JAR или WAR).

Пример использования: Основные библиотеки, которые требуются для выполнения основного кода, например, библиотеки
логирования или фреймворки.

2)provided

- Описание: Зависимость должна быть предоставлена средой выполнения или контейнером (например, веб-сервером или
  приложением сервера).
- Применение: Доступна при компиляции и тестировании, но не включается в финальный артефакт.
    - Обычно используется для библиотек, которые предоставляются окружением, таким как servlet-api или JDK.

Пример использования: javax.servlet:servlet-api для веб-приложений, развернутых на серверах приложений.

3)runtime

- Описание: Зависимость требуется только во время выполнения, но не нужна на этапе компиляции.
- Применение: Не используется при компиляции, но включается на этапе тестирования и выполнения.

Пример использования: Драйверы баз данных, которые не нужны для компиляции, но необходимы во время выполнения.

4)test

- Описание: Зависимость используется только для тестирования кода.
- Применение: Доступна только на этапе тестирования и не включается в финальный артефакт.
    - Не доступна при компиляции и выполнении основного кода.

Пример использования: Тестовые библиотеки, такие как JUnit или Mockito.

5)system

- Описание: Подобна provided, но зависимость должна находиться в локальной файловой системе и явно указывается в
  pom.xml.
- Применение: Используется на этапах компиляции и тестирования.
    - Требует явного указания пути к JAR-файлу через
      элемент 'systemPath'.
- Ограничения: Не рекомендуется использовать из-за жесткой привязки к локальной файловой системе и невозможности работы
  с репозиториями Maven.

Пример использования: Системные библиотеки, которые не могут быть размещены в репозиториях Maven.

6)import (доступна только для зависимостей типа pom)

-Описание: Используется для импорта зависимостей из других POM-файлов, например, для управления версиями зависимостей
через BOM (Bill of Materials).

- Применение: Применяется только с зависимостями типа pom.
    - Импортирует зависимости, указанные в другом POM-файле, и позволяет использовать их в текущем проекте.

[К оглавлению](#CollectionsPro)

# 32. Расскажите о жизненном цикле maven. В какой последовательности выполняются фазы цикла и что происходит на каждой фазе сборки?

Всего Maven's Default Lifecycle содержит 23 фазы

- clean - очистка директории target
- validate - проверка проекта на корректность и доступность необходимых зависимостей
- compile - компиляция исходного кода в байт-код, файлы помещаются в target/classes
- test - выполнение unit-тестов
- package - упаковка скомпилированного кода в архив jar/war/ear и т.д.
- verify - комплексная проверка на соответствие предопределенным правилам (в т.ч. с помощью плагинов)
- install - установка пакета в локальный репозиторий для использования в качестве зависимости в других локальных
  проектах
- deploy - копирование финального пакета (архива) в удаленный репозиторий

[К оглавлению](#CollectionsPro)

