## CollectionsPro

[1. Что такое generics?](#1-что-такое-generics)

[2. Что такое wild cards?](#2-что-такое-wild-cards)

[3. Что такое bounded wild cards?](#3-что-такое-bounded-wild-cards)

[4. Что такое unbounded wild cards?](#4-Что-такое-unbounded-wild-cards)

[5. Где хранится информация про Generics?](#5-Где-хранится-информация-про-Generics)

[6. Как можно получить тип Generics?](#6-Как-можно-получить-тип-Generics)

[7. Что такое итератор? В чем разница между iterator и listIterator? Что такое fail-fast и fail-safe поведение итератора и в чем между ними разница? Когда возникает ConcurrentModificationException?](#7-Что-такое-итератор-В-чем-разница-между-iterator-и-listIterator-Что-такое-fail-fast-и-fail-safe-поведение-итератора-и-в-чем-между-ними-разница-Когда-возникает-ConcurrentModificationException)

[8. Что такое коллекции?](#8-Что-такое-коллекции)

[9. Назовите базовые интерфейсы коллекций?](#9-Назовите-базовые-интерфейсы-коллекций)

[10. Расскажите реализации интерфейса List?](#10-Расскажите-реализации-интерфейса-List)

[11. Расскажите реализации интерфейса Set?](#11-Расскажите-реализации-интерфейса-Set)

[12. Расскажите реализации интерфейса Map?](#12-Расскажите-реализации-интерфейса-Map)

[13. Отличие ArrayList от LinkedList?](#13-Отличие-ArrayList-от-LinkedList)

[14. Отличие Set от List?](#14-Отличие-Set-от-List)

[15. Расскажите про методы Object hashCode и equals?](#15-Расскажите-про-методы-Object-hashCode-и-equals)

[16. Расскажите, что такое коллизии в Map? Как с ними бороться?](#16-Расскажите-что-такое-коллизии-в-Map-Как-с-ними-бороться)

[17. Расскажите, что такое анализ алгоритма?](#17-Расскажите-что-такое-анализ-алгоритма)

[18. Какая временная сложность алгоритмов добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?](#18-Какая-временная-сложность-алгоритмов-добавления-замены-и-удаления-в-каждой-из-коллекций-С-чем-связаны-отличия)

[19. Расскажите реализации данных очередей и стеков.](#19-Расскажите-реализации-данных-очередей-и-стеков)

[20. Расскажите про реализации деревьев.](#20-Расскажите-про-реализации-деревьев)

[21. Что такое loadFactor?](#21-Что-такое-loadFactor)

[22. Перечислите побитовые логические операции, которые Вы знаете? Расскажите, как они работают.](#22-Перечислите-побитовые-логические-операции-которые-Вы-знаете-Расскажите-как-они-работают)

[23. Расскажите про операции сдвига. Какие они бывают и что делают?](#23-Расскажите-про-операции-сдвига-Какие-они-бывают-и-что-делают)

[24. Как хранится знак числа в Java? Как хранятся отрицательные числа?](#24-Как-хранится-знак-числа-в-Java-Как-хранятся-отрицательные-числа)

[25. Расскажите о системах сборки проекта. В чем отличие систем сборки Ant, Maven и Gradle?](#25-Расскажите-о-системах-сборки-проекта-В-чем-отличие-систем-сборки-Ant-Maven-и-Gradle)

[26. Как создать maven проект?](#26-Как-создать-maven-проект)

[27. Какова структура maven проекта?](#27-Какова-структура-maven-проекта)

[28. Расскажите о файле pom xml. Как он структурирован и за что отвечает содержание каждой части?](#28-Расскажите-о-файле-pom-xml-Как-он-структурирован-и-за-что-отвечает-содержание-каждой-части)

[29. Что такое координаты зависимости?](#29-Что-такое-координаты-зависимости)

[30. Что такое транзитивные зависимости?](#30-Что-такое-транзитивные-зависимости)

[31. Что такое область видимости зависимости? Сколько областей видимости предусмотрено и где они применяются?](#31-Что-такое-область-видимости-зависимости-Сколько-областей-видимости-предусмотрено-и-где-они-применяются)

[32. Расскажите о жизненном цикле maven. В какой последовательности выполняются фазы цикла и что происходит на каждой фазе сборки?](#32-Расскажите-о-жизненном-цикле-maven-В-какой-последовательности-выполняются-фазы-цикла-и-что-происходит-на-каждой-фазе-сборки)

# 1. Что такое generics?

Дженерики появились в Java 5 версии. До этого программисту
приходилось выполнять приведение типов каждого объекта, прочитанного из коллекции. Если кто-то случайно вставлял туда
объект
неправильного типа, приведение могло вызвать runtime exception. С помощью обобщенных типов можно сообщить компилятору,
какие типы допускаются в каждой коллекции. Компилятор автоматически добавит приведение типов и во время компиляции
обнаружит попытки вставить объект неправильного типа, и у нас в рантайме уже ничего не упадет.
Это делает программы более безопасными и ясными. С их помощью можно объявлять классы,
интерфейсы и методы, где тип данных указан в виде параметра.

[К оглавлению](#CollectionsPro)

# 2. Что такое wild cards?

Wildcards в Java используются в обобщениях для обозначения неизвестного типа. Это удобно, когда вы хотите работать с
различными типами данных, но не хотите жёстко задавать конкретный тип. Wildcards представляются символом вопросительного
знака (?). Используется, когда тип данных может быть абсолютно любым. Не используйте wildcard, если нужно производить
и запись, и чтение, потому что компилятор не может определить, какой тип данных безопасен для добавления.

````java
List<?> list = new ArrayList<>();
`````

[К оглавлению](#CollectionsPro)

# 3. Что такое bounded wild cards?

Ограниченный wildcard с верхней границей (<? extends Type>). Используется, когда тип данных должен быть подтипом (или
самим типом) указанного класса. Если необходимо читать из контейнера, то
используйте wildcard с верхней границей "? extends". Например:

````java
List<? extends Number> list = new ArrayList<>();
````

Здесь list может содержать элементы типа Number, Integer, Double, и других классов, которые являются подтипами Number.

[К оглавлению](#CollectionsPro)

# 4. Что такое unbounded wild cards?

Ограниченный wildcard с нижней границей (<? super Type>).
Используется, когда тип данных должен быть суперклассом (или самим типом) указанного класса. Если необходимо
писать в контейнер, то используйте wildcard с нижней границей "? super". Например:

````java
List<? super Integer> list = new ArrayList<>();
````

В этом случае list может содержать элементы типа Integer, Number, или Object (так как они являются супер классами
Integer).

[К оглавлению](#CollectionsPro)

# 5. Где хранится информация про Generics?

После компиляции JVM не имеет информации о типах параметров обобщений. Все данные о Generics используются только на
этапе компиляции для обеспечения типовой безопасности и не сохраняются в байт-коде. Процесс удаления информации о типах
во время компиляции называется стирание типов. Во время компиляции все параметры типов в обобщениях (Generics)
заменяются на их границы или на Object, если границы не указаны. Например, `List<String>` и `List<Integer>` после
компиляции становятся просто List.

Почему нельзя создавать массивы обобщённых типов или напрямую проверять тип обобщения
с помощью instanceof во время выполнения — эта информация просто недоступна в байт-коде.

[К оглавлению](#CollectionsPro)

# 6. Как можно получить тип Generics?

Если обобщённый тип задан в классе или интерфейсе как параметризованный тип, вы можете получить информацию о нём с
помощью рефлексии. Рефлексия (Reflection) в Java — это механизм, который позволяет программе во время выполнения
получать информацию о своей структуре и манипулировать объектами, классами, методами и полями. Это мощный инструмент,
который дает возможность динамически анализировать и изменять поведение программы, даже если во время компиляции
информация о классах или методах недоступна.

````java
public class GenericTypeDemo<T> {
    public static void main(String[] args) {
        // Анонимный класс для захвата информации о типе обобщения
        GenericTypeDemo<String> instance = new GenericTypeDemo<String>() {
        };
        Type superclass = instance.getClass().getGenericSuperclass();

        if (superclass instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) superclass;
            Type[] typeArguments = parameterizedType.getActualTypeArguments();
            for (Type typeArgument : typeArguments) {
                System.out.println("Тип обобщения: " + typeArgument);
            }
        }
    }
````

Используется анонимный подкласс - instance, чтобы обойти стирание типов и сохранить информацию о типе обобщения, которую
затем можно извлечь с помощью рефлексии.

Ещё один способ сохранить информацию о типе — передать его явно в конструктор или метод в виде класса (Class<T>):

````java
public class GenericClass<T> {
    private Class<T> type;

    public GenericClass(Class<T> type) {
        this.type = type;
    }

    public void printType() {
        System.out.println("Тип обобщения: " + type.getName());
    }

    public static void main(String[] args) {
        GenericClass<String> instance = new GenericClass<>(String.class);
        instance.printType();  // Выведет: Тип обобщения: java.lang.String
    }
}
````

[К оглавлению](#CollectionsPro)

# 7. Что такое итератор? В чем разница между iterator и listIterator? Что такое fail-fast и fail-safe поведение итератора и в чем между ними разница? Когда возникает ConcurrentModificationException?

Итератор в Java — это объект, который предоставляет способ последовательного доступа к элементам коллекции без
необходимости знать внутреннее представление этой коллекции. Итератор используется для перебора элементов коллекций.

Iterator и ListIterator — это два интерфейса в Java, которые используются для перебора элементов коллекций.

- Iterator: Может использоваться с любыми коллекциями, реализующими интерфейс Collection (например, List, Set, Queue).
    - ListIterator: Предназначен только для коллекций, реализующих интерфейс List (например, ArrayList, LinkedList).
- Iterator: Поддерживает только односторонний перебор — от начала к концу коллекции.
    - ListIterator: Поддерживает двусторонний перебор — можно перемещаться как вперёд, так и назад по коллекции.
- Iterator: Не предоставляет информации об индексах элементов.
    - ListIterator: Позволяет получить текущий индекс с помощью методов nextIndex() и previousIndex().
- Iterator: Поддерживает удаление элементов с помощью метода remove(). Других изменений коллекции (например, добавления
  элементов) не поддерживает.
    - ListIterator: Поддерживает удаление (remove()), замену (set(E e)) и добавление (add(E e)) элементов в коллекцию.
- Iterator: Начинает перебор с самого начала коллекции.
    - ListIterator: Может начинать перебор с любого заданного индекса, что позволяет более гибкое управление порядком
      перебора.

Fail-fast итераторы бросают исключение ConcurrentModificationException, если коллекция модифицируется (добавление,
удаление, изменение элементов) в процессе итерации любым способом, кроме использования методов самого итератора (
например, remove() у итератора).

Как работает fail-fast механизм:
Итераторы fail-fast проверяют "структурные модификации" коллекции при каждом вызове метода, такого как next() или
remove().
Внутри коллекции есть счетчик модификаций (modification count), который увеличивается при структурных изменениях.
Итератор сохраняет значение этого счетчика на момент своего создания и сравнивает его с текущим значением при каждой
операции.
Если значения не совпадают (например, элемент был добавлен или удален через саму коллекцию, а не через итератор), то
генерируется ConcurrentModificationException.

Fail-safe итераторы не бросают исключение при модификации коллекции во время итерации. Вместо этого они работают с
копией данных коллекции, что позволяет избежать конфликтов.

Как работает fail-safe механизм:
Fail-safe итераторы работают с клоном коллекции. Это означает, что любые изменения, внесенные в коллекцию после
создания итератора, не видны итератору.
Такие итераторы обеспечивают безопасный доступ, но изменения в коллекции не отражаются на итераторе.

[К оглавлению](#CollectionsPro)

# 8. Что такое коллекции?

Коллекции в Java — это фреймворк, который предоставляет архитектуру для хранения и управления группами объектов. Он
включает в себя интерфейсы, классы и алгоритмы, которые облегчают работу с группами объектов, такие как списки,
множества, очереди и карты.

[К оглавлению](#CollectionsPro)

# 9. Назовите базовые интерфейсы коллекций?

`Collection<E>` - Базовый интерфейс для большинства коллекций. Расширяет интерфейс Iterable.
Определяет основные методы, такие как add(), remove(), retainAll(), size(), clear(), isEmpty(), contains(), iterator().

`Map<K, V>` - Коллекция, хранящая пары "ключ-значение".
Ключи уникальны, значения могут повторяться.
Не наследует интерфейс Collection, но является частью фреймворка.

[К оглавлению](#CollectionsPro)

# 10. Расскажите реализации интерфейса List?

Представляет упорядоченную коллекцию (список), которая может содержать дублирующиеся элементы. Поддерживает доступ по
индексу(элементы списка можно напрямую получать, добавлять, изменять или удалять, используя индекс, который представляет
позицию элемента в списке.)

- ArrayList - на динамическом массиве.
- LinkedList - класс, который реализует два интерфейса - List и Deque. Этим обеспечивается возможность создавать
  двунаправленные(те, которые можно обходить в обоих направлениях) очереди из любых (в том числе и null) элементов.
  Каждый объект помещенный в связанный список, является узлом (для этого используются объекты вложенного класса Node).
  Каждый узел содержит в себе элемент который мы добавили, а также ссылку на предыдущий и следующий узел
- Vector - использовали до ArraysList.
- Stack - очередь LIFO (стопка тарелок)

[К оглавлению](#CollectionsPro)

# 11. Расскажите реализации интерфейса Set?

Коллекция, которая не содержит дублирующихся элементов. Не гарантирует порядок элементов (например, HashSet), хотя есть
реализации, сохраняющие порядок (например, LinkedHashSet) или упорядоченные (например, TreeSet).

- HashSet - внутренне HashSet реализован на основе HashMap. Каждый элемент HashSet хранится как ключ во внутреннем
  HashMap с фиксированным значением-заглушкой (обычно это объект new Object()).
- LinkedHashSet - расширяет HashSet, позволяет получать элементы в порядке их добавления, но требует больше памяти.
- TreeSet - основан на сбалансированном двоичном дереве, в результате элементы упорядочены по возрастанию hashCode()'ов.
  Можно управлять порядком при помощи компаратора.

[К оглавлению](#CollectionsPro)

# 12. Расскажите реализации интерфейса Map?

Коллекция, хранящая пары "ключ-значение". Ключи уникальны, значения могут повторяться. Не наследует интерфейс
Collection, но является частью фреймворка.

- `HashMap` - основан на хэш-таблицах, представляет собой массив корзин (buckets), где каждая корзина может хранить одно
  или несколько значений. Ключи и значения могут быть любых типов, в том числе и null, подходит для
  большинства стандартных случаев, когда не требуется порядок элементов. Значения в HashMap хранятся внутри корзин в
  виде объектов `Map.Entry`, которые содержат пары "ключ-значение" и связаны друг с другом в случае коллизий.
- `LinkedHashMap` - расширяет класс HashMap. Он создает связный список элементов в карте, расположенных в том порядке, в
  котором они вставлялись.
- `TreeMap` - Он создает коллекцию, которая для хранения элементов применяет дерево. Объекты сохраняются в
  отсортированном порядке по возрастанию.

[К оглавлению](#CollectionsPro)

# 13. Отличие ArrayList от LinkedList?

Отличаются по структуре данных, возможности доступа по индексу, добавлением элементов, удалением элементов,
использованию памяти, поддержке очередей и стеков, по тому, как проходит итерация по элементам, по тому как изменяется
размер структуры.

- ArrayList основан на массиве динамической длины.
    - LinkedList - двусвязный список (каждый элемент хранит ссылку на предыдущий и следующий элемент).
- ArrayList - быстрый доступ по индексу (O(1)).
    - LinkedList - медленный доступ по индексу (O(n)), так как необходимо перебирать элементы.
- ArrayList - быстро добавляет элементы в конец (O(1)), медленно в середину или начало (O(n)).
    - LinkedList - быстрое добавление в начало или конец (O(1)), медленное добавление в середину (O(n)).
- ArrayList - медленное удаление элементов (O(n)), так как требует сдвига элементов.
    - LinkedList - быстрое удаление в начале или конце (O(1)), медленное удаление в середине (O(n)).
- ArrayList - не поддерживает напрямую операции очереди/стека, но можно реализовать(его можно использовать для
  реализации
  этих структур данных с помощью предоставляемых методов).
    - LinkedList - имеет методы addFirst(), addLast(), removeFirst(), removeLast(), идеально подходит для очередей и
      стеков.
- ArrayList при достижении предела увеличивает массив, копируя элементы в новый массив большего размера.
    - LinkedList - нет необходимости в увеличении, элементы добавляются динамически.

LinkedList требует больше памяти для хранения такого же количества элементов, потому что кроме
самого элемента хранятся еще указатели на следующий и предыдущий элементы списка, тогда как в ArrayList элементы просто
идут по порядку

Если необходимо вставлять (или удалять) в середину коллекции много элементов, то лучше
использовать LinkedList. Во всех остальных случаях – ArrayList.

[К оглавлению](#CollectionsPro)

# 14. Отличие Set от List?

`Set` - предназначен для хранения уникальных элементов, и в большинстве реализаций основной задачей является быстрое
добавление, удаление и поиск. Для обеспечения этой скорости используются хеш-таблицы (HashSet) или сбалансированные
деревья (TreeSet), которые не обеспечивают порядок добавления элементов.

`List` - предназначен для хранения упорядоченной коллекции элементов, которые могут повторяться. Он предоставляет гибкий
способ работы с последовательностями данных, где порядок элементов имеет значение, и доступ к элементам можно
осуществлять по индексу.

[К оглавлению](#CollectionsPro)

# 15. Расскажите про методы Object hashCode и equals?

Методы, необходимые для определения равенства объектов.
Метод `hashCode()` используется для числового представления объекта, метод `equals()` для сравнения двух объектов. По
умолчанию, реализация equals() в классе Object сравнивает объекты по ссылке, то есть два объекта равны, только если они
являются одним и тем же объектом в памяти (==). Чтобы сравнивать объекты по значению их полей, метод equals()
переопределяется. При переопределении метода `equals()` всегда переопределяют `hashCode()`.
Множество возможных хеш-кодов ограничено диапазоном примитивного типа int 2^32, а множество объектов ничем не
ограничено.

Правила переопределения `equals()`

- объект должен быть равен самому себе
- если x.equals(y) возвращает true, то и y.equals(x) должно возвращать true.
- если x.equals(y) возвращает true и y.equals(a) возвращает true, то x.equals(a) тоже должен вернуть true.
- многократные вызовы x.equals(y) должны возвращать одинаковый результат до тех пор, пока объекты не будут изменены.
- x.equals(null) всегда должен возвращать false.

Правила переопределения `hashCode()`:

- Для числовых типов, таких как int, long, float, double, char и boolean, хеш-коды могут быть их значениями или
  некоторыми простыми преобразованиями. Например:
    - Для int: хеш-код — само значение.
    - Для long: хеш-код — это int-результат операции (int)(value ^ (value >>> 32)).
    - Для float: хеш-код получается с помощью преобразования его в int через метод Float.floatToIntBits(value).
    - Для double: преобразуется в long с помощью Double.doubleToLongBits(value) и затем используется формула для long.
    - Для boolean: true даёт хеш-код 1231, false — 1237.

- Для объектов, таких как строки, массивы или пользовательские классы, точная формула вычисления хеш-кода зависит от
  типа и структуры объекта и может варьироваться. Обычно комбинируются хеш-коды их полей. Общая
  формула может выглядеть примерно так: ````hashCode = 31 * hashCode + fieldHashCode;```` (31 — это часто используемое
  простое число, которое помогает уменьшить коллизии).

[К оглавлению](#CollectionsPro)

# 16. Расскажите, что такое коллизии в Map? Как с ними бороться?

В Java Map, используют хеширование для быстрого доступа к значениям по ключам. Хеширование основано
на использовании метода hashCode() для вычисления хеш-кода ключа, который затем используется для определения позиции,
где хранится значение во внутренней структуре данных.
Коллизия происходит, когда два различных ключа имеют одинаковый хеш-код, и, следовательно, их значения попадают в одну и
ту же корзину в Map. Коллизии неизбежны, поскольку множество возможных ключей обычно больше, чем
диапазон значений хеш-кодов. Однако, правильная реализация хеширования минимизирует частоту коллизий.

Для разрешения коллизий в HashMap используется комбинация двух стратегий:

- Цепочка (Chaining): Вместо хранения одного элемента в корзине, HashMap хранит связанный список (начиная с Java 8 — это
  может быть сбалансированное дерево, если количество элементов в корзине превышает определенный порог). Когда возникает
  коллизия, новый элемент просто добавляется в этот список или дерево. В худшем случае, если все ключи попали в одну
  корзину, время доступа к элементу будет пропорционально количеству элементов в этой корзине.
- Перераспределение (Rehashing): Когда HashMap достигает определенного уровня заполненности (обычно 75% от общего
  количества корзин), происходит перераспределение (rehashing). Размер массива корзин удваивается, и все элементы
  пересчитываются и перераспределяются по новому массиву. Это уменьшает вероятность коллизий, распределяя элементы более
  равномерно по новым корзинам.

Кроме того, Java 8 улучшила производительность в случаях частых коллизий, заменяя связанный список в корзине на
красно-черное дерево при превышении определенного порога элементов в одной корзине (по умолчанию 8). Это
улучшает время поиска, которое становится логарифмическим вместо линейного.

[К оглавлению](#CollectionsPro)

# 17. Расскажите, что такое анализ алгоритма?

Анализ алгоритма дает нам понимание того, сколько времени займет решение данной задачи при помощи данного алгоритма.
Эффективность алгоритма оценивается его временной сложностью.
Временная сложность алгоритма – это функция, позволяющая определить, как быстро увеличивается время работы алгоритма с
увеличением объёма данных.
Наиболее часто встречающиеся классы сложности:

- O(1) – константная сложность (т.е. константное время);
- О(n) – линейная сложность;
- О(log(n)) – логарифмическая сложность;
- О(nа) – полиномиальная сложность;
- O(n*log(n)) – квазилинейная сложность;
- O(2n) – экспоненциальная сложность;
- O(n!) – факториальная сложность.

[К оглавлению](#CollectionsPro)

# 18. Какая временная сложность алгоритмов добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?

![img](https://github.com/itlazykin/answers_to_exam_questions/blob/main/main/resources/%D0%92%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F%20%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C%20%D0%BA%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B9.png)

1. ArrayList (на основе массива)
    - Добавление: в конец — амортизированное O(1). Когда массив заполняется, он увеличивается в размере, что требует O(
      n) времени на копирование всех элементов в новый массив.
    - Замена: O(1), так как доступ к элементам по индексу осуществляется за константное время.
    - Удаление: O(n), так как после удаления элемента все последующие элементы нужно сдвинуть влево.
2. LinkedList (двусвязный список)
    - Добавление: В начало или конец — O(1), поскольку требуется изменить только несколько ссылок. В середину — O(n),
      так как нужно сначала найти позицию (линейный обход).
    - Замена: O(n), так как нужно сначала найти элемент.
    - Удаление: с начала или конца — O(1). В середине — O(n), так как требуется линейный обход до элемента.
3. HashMap (хэш-таблица)
    - Добавление/замена: O(1) в среднем, но O(n) в худшем случае при большом количестве коллизий.
    - Удаление: O(1) в среднем, но O(n) в худшем случае (опять же из-за коллизий).
4. TreeMap (на основе красно-черного дерева)
    - Добавление/замена: O(log n), так как элементы хранятся упорядоченно, и операция требует поиска правильного места.
    - Удаление: O(log n), так как удаление требует перестройки дерева.

С чем связаны отличия?

- Коллекции используют разные структуры данных, например, массивы, списки, деревья, хэш-таблицы. Это напрямую влияет на
  сложность операций.
- Методы управления памятью: Например, ArrayList использует массивы, которые иногда требуют расширения и копирования,
  что увеличивает сложность операций.
- Необходимость перемещения данных: В ArrayList при удалении требуется перемещать элементы, тогда как в LinkedList
  достаточно изменить ссылки.
- Алгоритмы поиска и вставки: В деревьях и хэш-таблицах используются разные подходы для поиска и вставки, которые
  определяют временные характеристики.

[К оглавлению](#CollectionsPro)

# 19. Расскажите реализации данных очередей и стеков.

- `Queue` (FIFO) - односторонняя очередь, элементы можно получить в том порядке в котором добавляли. Такая очередь
  позволяет поместить элементы в один конец очереди, а извлекать их – из другого. LinkedList,
  PriorityQueue — наиболее часто используемые реализации интерфейса Queue.
  PriorityQueue - особенностью данной очереди является возможность управления
  порядком элементов. По-умолчанию, элементы сортируются с использованием «natural ordering», но это
  поведение может быть переопределено при помощи объекта Comparator, который задаётся при создании
  очереди. Данная коллекция не поддерживает null в качестве элементов.

- `Dequeue` (расширяет Queue) - двусторонняя очередь, можно вставлять/получать элементы из начала и конца. Наиболее
  часто
  используемой реализацией интерфейса Deque является класс LinkedList.
  Из документации следует, что LinkedList - реализует Dequeue, а так же интерфейс Queue со всеми его методами.
  Следовательно, при создании объекта LinkedList можно использовать оба базовых типа указанных интерфейсов следующие обе
  строки кода будут работать без проблем:

````java
Queue<String> queue = new LinkedList<>();
Deque<String> deque = new LinkedList<>();
````

ArrayDeque — реализация интерфейса Deque, который расширяет интерфейс Queue методами,
позволяющими реализовать конструкцию вида LIFO (last-in-first-out). Интерфейс Deque и
реализация ArrayDeque были добавлены в Java 1.6. Эта коллекция представляет собой реализацию с
использованием массивов, подобно ArrayList, но не позволяет обращаться к элементам по индексу и
хранение null. Как заявлено в документации, коллекция работает быстрее чем Stack, если используется
как LIFO коллекция, а также быстрее чем LinkedList, если используется как FIFO.

- `Stack` (LIFO) - стек, можно получить только последний элемент. Stack - примитивная структура данных. Работу этой
  структуры можно представить в виде тарелок, поставленных друг на друга.
  Новая тарелка всегда оказывается верхней. Если нам нужно достать тарелку из середины стопки, то нужно снять верхние
  тарелки. Stack лучше всего реализовать на базе связанного списка. Связанный список умеет быстро вставлять данные и
  удалять с начала или конца. Это поведение как раз и нужно при реализации стека.

[К оглавлению](#CollectionsPro)

# 20. Расскажите про реализации деревьев.

В Java используются красно-черные деревья бинарного поиска - RB Tree. Базовый элемент дерева - это узел. Узел хранит в
себе данные и ссылки на другие узлы. Однако может иметь только одного предка - узел предшественника. Родительский узел
может иметь от 0 до N потомков. В случае с бинарным деревом родительский узел может иметь от 0 до 2 потоков. В деревьях
не могут быть циклические связи. В узел можно прийти только единственным путем. Родительский узел имеет левый и правый
узел, которые могут быть null ссылками. Дерево может быть бинарным, но может не быть деревом поиска, но всякое дерево
поиска бинарное. Чтобы бинарное дерево стало бинарным деревом поиска нужно выполнить правило:

- Значение левого потомка должно быть меньше родительского.
- Значение правого потомка должно быть больше или равно родительскому.

Основные реализации:

- TreeMap - упорядоченная по ключам. Основана на красно-черных деревьях. Может использовать компаратор в конструкторе.
  Красно-черные дерево - это самобалансирующееся дерево, которое гарантирует логарифмический рост высоты дерева от числа
  узлов.
- TreeSet - основан на сбалансированном двоичном дереве, в результате элементы упорядочены по возрастанию хеш-кодов.
  Можно управлять порядком при помощи компаратора.

[К оглавлению](#CollectionsPro)

# 21. Что такое loadFactor?

loadFactor - это коэффициент загрузки, равен соотношению (размер коллекции / количество элементов). При достижении
порогового значения размер коллекции увеличивается.

Например, в хеш-таблице поле, оно показывает на сколько заполнен массив, на котором эта таблица основана. Если на
3/4, то создается новый массив с большим размером и данные перераспределяются.

[К оглавлению](#CollectionsPro)

# 22. Перечислите побитовые логические операции, которые Вы знаете? Расскажите, как они работают.

- Побитовое "ИЛИ" (|). В результирующий бит будет записана единица, если хотя бы один операнд равен единице.
- Побитовое "И" (&). В результирующий бит будет записана единица только в том случае, если оба операнда равны единице.
- Побитовое "Исключающее ИЛИ" (^). По-другому называется XOR (исключение - X, или - OR). В результирующий бит будет
  записана единица только в том случае, если операнды не равны между собой.
- Унарная операция "НЕ" (~). По-другому называется поразрядным отрицанием. Инвертирует все двоичные разряды числа, то
  есть меняет значение каждого разряда на противоположное.

[К оглавлению](#CollectionsPro)

# 23. Расскажите про операции сдвига. Какие они бывают и что делают?

- Беззнаковый сдвиг влево (<<). Сдвигает двоичное представление первого операнда влево на количество бит, заданное во
  втором операнде, знак числа не сохраняется. Младшие(крайние правые) биты при этом заполняются нулями. Сдвиг на 1 бит
  влево соответствует умножению на 2.
- Знаковый сдвиг вправо (>>). Сдвигает двоичное представление первого операнда вправо на количество бит, заданное во
  втором операнде, знак числа сохраняется. Старшие(крайние левые биты) заполняются ведущими нулями (при сдвиге
  положительного числа) или единицами (при сдвиге отрицательного числа). Сдвиг на бит вправо соответствует делению на 2.
- Беззнаковый сдвиг вправо(>>>). Сдвигает двоичное представление первого операнда вправо на количество бит, заданное во
  втором операнде, знак числа не сохраняется. Для положительных чисел работает как деление
- Без знакового(логического) сдвига влево не существует, потому что такой сдвиг не оказывает влияния на старший значащий
  бит(MSB) - крайний левый бит числа, изменяются только крайние правые биты. Кроме того, в процессорах семейства 8086
  арифметический и логический сдвиг выполняют одну и ту же операцию.

Примеры применения битовых операций:

- Ускорение операций умножения и деления чисел на два. Примеры можно увидеть в стандартной библиотеке jdk. Важно
  понимать, что сдвиги намного хуже читаются в коде, нежели обычные арифметические операции, поэтому применять их нужно
  согласованно на уровне команды/проекта, иначе другие программисты могут внезапно столкнуться со сложностями чтения
  такого кода.
- Битовые поля(флаги). Пример: пусть есть права на доступ - чтение, запись, выполнение. Их удобнее хранить не в трёх
  разных переменных, а в одной, устанавливая соответствующие биты.
- Алгоритмы шифрования и сжатия (например, Шифр Вернама построен на XOR).
- Работа с графикой.
- Работа с сетью.

  [К оглавлению](#CollectionsPro)

# 24. Как хранится знак числа в Java? Как хранятся отрицательные числа?

Все примитивные (целочисленные) типы данных в Java (кроме char) представлены со знаком, то есть число может быть
положительным или отрицательным. Знак числа определяет старший двоичный разряд (самый левый). 0 - знак плюс. 1 - знак
минус. Старший двоичный разряд называется дополнительным кодом (или вторым дополнением (two's complement)), так как
хранит только знак числа. Например, в типе int старший двоичный разряд уходит под хранение знака, а под само значение
уходят остальные 31 бит. Чтобы преобразовать положительное число в отрицательное, нужно инвертировать все его биты и к
получившемуся числу добавить 1.

[К оглавлению](#CollectionsPro)

# 25. Расскажите о системах сборки проекта. В чем отличие систем сборки Ant, Maven и Gradle?

Системы сборки проектов в Java автоматизируют процесс компиляции, тестирования, упаковки и развертывания приложений. Они
упрощают управление зависимостями, настройку окружения, автоматизацию задач и многое другое. Основные системы сборки для
Java — это Ant, Maven и Gradle. Основные отличия:

1) Подход к описанию сборок:

- Ant: Процедурный (что нужно сделать).
- Maven: Декларативный (что нужно получить).
- Gradle: Гибридный (декларативный с возможностью процедурных настроек).

2)Управление зависимостями:

- Ant: Отсутствует встроенная поддержка, ручное управление или через плагины.
- Maven: Встроенное управление через POM и центральные репозитории.
- Gradle: Встроенное управление с поддержкой различных репозиториев и мощных механизмов настройки.

3)Конфигурация:

- Ant: XML, что делает конфигурацию громоздкой.
- Maven: XML с жесткими конвенциями, что упрощает, но иногда ограничивает.
- Gradle: Groovy или Kotlin DSL, что делает конфигурацию более гибкой и читаемой.

4)Производительность:

- Ant: Нет оптимизации для инкрементальных сборок.
- Maven: Ограниченная поддержка инкрементальных сборок.
- Gradle: Поддержка инкрементальных сборок и кэширования, что ускоряет процесс.

[К оглавлению](#CollectionsPro)

# 26. Как создать maven проект?

Качаем maven-> устанавливаем-> настраиваем переменные среды. Добавляем путь к maven в PATH-> открываем командную
строку-> вводим команду `mvn archetype:generate -DgroupId=com.example -DartifactId=myapp
-DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false` -> после выполнения команды в текущей
директории будет создана папка с именем myapp, содержащая стандартную структуру Maven-проекта:-> в корневой папке
проекта выполните команду: mvn clean install. Команда mvn clean install выполняет очистку предыдущих сборок (clean),
компиляцию, тестирование и упаковку проекта в JAR или WAR файл.

- `groupId` : Уникальный идентификатор группы, часто соответствует структуре пакетов (например, com.example).
- `artifactId` : Имя проекта или артефакта (например, myapp).
- `archetypeArtifactId` : Указывает на шаблон проекта, который будет использован для создания.
  maven-archetype-quickstart —
  это стандартный архетип для быстрого начала работы с Java-проектами.
- `interactiveMode=false` : Отключает интерактивный режим, чтобы команда выполнялась автоматически.

[К оглавлению](#CollectionsPro)

# 27. Какова структура maven-проекта?

````
myapp
├── pom.xml
└── src
├── main
│   ├── java
│   │   └── com
│   │       └── example
│   │           └── App.java
│   ├── resources
│   │   └── application.properties
│   ├── filters
│   │   └── dev.properties
│   ├── webapp
│   │   ├── WEB-INF
│   │   │   └── web.xml
│   │   └── index.jsp
│   ├── scripts
│   │   └── script.sql
│   └── configuration
│       └── config.yaml
└── test
├── java
│   └── com
│       └── example
│           └── AppTest.java
└── resources
└── test-data.json
````

[К оглавлению](#CollectionsPro)

# 28. Расскажите о файле pom xml. Как он структурирован и за что отвечает содержание каждой части?

Файл pom.xml — основной файл конфигурации Maven, где указываются зависимости, плагины и другие настройки проекта. Файл
pom.xml написан на языке XML и имеет следующую основную структуру:

- Инфо о проекте.
- Описание проекта.
- Управление зависимостями.
- Плагины сборки.
- Репозитории.
- Профили сборки.
- Плагины специфичные для этого профиля.

Основные части pom.xml

1)Корневой элемент `project`.

- Основной контейнер для всего содержимого pom.xml.
- Атрибуты xmlns, xmlns:xsi, и xsi:
  schemaLocation указывают на схему XML и помогают валидации структуры POM.

2)`modelVersion`: Указывает версию модели POM.

3)Информация о проекте:

- `groupId` : Уникальный идентификатор группы, обычно соответствует структуре пакетов организации или проекта (например,
  com.example).
- `artifactId`: Идентификатор проекта или артефакта (например, myapp). Обычно совпадает с именем директории проекта.
- `version`: Версия проекта (например, 1.0.0). Это версия, которая будет использоваться в артефакте сборки.
- `packaging`: Тип артефакта, который будет создан (jar, war, pom, и т.д.). По умолчанию jar.

4)Описание проекта (опционально):

- `name`: Человеко читаемое название проекта.
- `description`: Краткое описание проекта.
- `url`: URL проекта или его домашняя страница.

5)`dependencies`:

Управляет зависимостями проекта. Каждая зависимость указывается в элементе <dependency>, включающем:

- `groupId`: Идентификатор группы зависимости.
- `artifactId`: Идентификатор зависимости.
- `version`: Версия зависимости.
- `scope`: Область видимости зависимости (compile, test, provided, runtime, system). Например, test означает, что
  зависимость используется только для тестирования.

6)`build`:

Настройки сборки проекта:

- `plugins`: Указывает плагины, используемые в процессе сборки. Например, maven-compiler-plugin для компиляции исходного
  кода.
- `plugin`: Содержит конфигурации для каждого плагина:
- `groupId`, <artifactId>, <version>: Информация о плагине.
- `configuration`: Параметры конфигурации для плагина (например, версия Java для компиляции).
- `repositories` (опционально): Определяет репозитории для поиска зависимостей, если они не находятся в стандартном
  Maven Central. Может включать как публичные, так и приватные репозитории.
- `profiles` (опционально):Позволяет создавать разные профили сборки с различными настройками (например, для разработки,
  тестирования или
  продакшн-среды). Профили могут активироваться различными способами, такими как наличие определённого файла или
  переменные среды.

[К оглавлению](#CollectionsPro)

# 29. Что такое координаты зависимости?

В Maven координаты зависимости определяют уникальные характеристики каждой зависимости, которые позволяют Maven найти,
загрузить и использовать библиотеку или компонент в вашем проекте. Координаты зависимости состоят из нескольких
обязательных и опциональных элементов, которые уникально идентифицируют конкретную версию артефакта в репозитории.
Основные компоненты координат зависимости:

1) `groupId` :

- Уникальный идентификатор группы или организации, к которой принадлежит артефакт. Обычно совпадает с доменным именем
  организации в обратном порядке (например, com.example).

2)`artifactId`:

- Идентификатор конкретного артефакта или библиотеки. Обычно соответствует названию проекта или модуля (например,
  myapp).

3)`version`:

- Версия артефакта. Указывает конкретную версию зависимости, которая будет использоваться. Например, 1.0.0, 2.5.1 или
  1.0.0-SNAPSHOT для версии в стадии разработки.

4)`packaging` (опционально для зависимостей):

- Тип упаковки артефакта. Может быть jar, war, pom, и другие. По умолчанию — jar, если не указано иное.

5)`classifier` (опционально):

- Дополнительный идентификатор, который может быть использован для различения артефактов с одинаковыми groupId,
  artifactId, и version, но с различными вариантами (например, источник кода, javadoc, бинарные файлы для разных
  платформ).

6)`scope` (опционально):

- Область видимости зависимости, которая определяет, на каком этапе жизненного цикла сборки зависимость будет
  использоваться (например, compile, test, provided, runtime, system).

Координаты зависимости используются Maven для:

- Идентификации артефактов: Позволяют уникально идентифицировать библиотеку среди множества других в репозиториях.
- Управления зависимостями: Maven использует координаты для загрузки нужных библиотек из репозиториев, таких как Maven
  Central или другие.
- Управления версиями: Координаты позволяют легко обновлять или фиксировать нужные версии библиотек в проекте.
- Управления сборкой: Определение scope помогает Maven оптимизировать сборку проекта, подключая зависимости только там,
  где это необходимо (например, для тестов, компиляции или исполнения

[К оглавлению](#CollectionsPro)

# 30. Что такое транзитивные зависимости?

Транзитивные зависимости — это зависимости, автоматически подтягивающиеся в проект в результате указания
зависимостей, у которых есть свои зависимости. Если библиотека A, в свою очередь, зависит от библиотеки B, то библиотека
B становится транзитивной зависимостью вашего проекта. Вы не указывали библиотеку B напрямую, но она подтянулась
автоматически через библиотеку A.

[К оглавлению](#CollectionsPro)

# 31. Что такое область видимости зависимости? Сколько областей видимости предусмотрено и где они применяются?

Область видимости зависимости (scope) в Maven определяет, на каком этапе жизненного цикла сборки и в каких контекстах
зависимости будут доступны в проекте. Это помогает оптимизировать управление зависимостями и правильно настроить их
использование.

1)`compile`

- Описание: Это область видимости по умолчанию, если не указана другая.
- Применение: Зависимости с областью видимости compile доступны на всех этапах сборки: компиляция, тестирование,
  упаковка и выполнение.
    - Также включаются в финальный артефакт (например, JAR или WAR).

Пример использования: Основные библиотеки, которые требуются для выполнения основного кода, например, библиотеки
логирования или фреймворки.

2)`provided`

- Описание: Зависимость должна быть предоставлена средой выполнения или контейнером (например, веб-сервером или
  приложением сервера).
- Применение: Доступна при компиляции и тестировании, но не включается в финальный артефакт.
    - Обычно используется для библиотек, которые предоставляются окружением, таким как servlet-api или JDK.

Пример использования: javax.servlet:servlet-api для веб-приложений, развернутых на серверах приложений.

3)`runtime`

- Описание: Зависимость требуется только во время выполнения, но не нужна на этапе компиляции.
- Применение: Не используется при компиляции, но включается на этапе тестирования и выполнения.

Пример использования: Драйверы баз данных, которые не нужны для компиляции, но необходимы во время выполнения.

4)`test`

- Описание: Зависимость используется только для тестирования кода.
- Применение: Доступна только на этапе тестирования и не включается в финальный артефакт.
    - Не доступна при компиляции и выполнении основного кода.

Пример использования: Тестовые библиотеки, такие как JUnit или Mockito.

5)`system`

- Описание: Подобна provided, но зависимость должна находиться в локальной файловой системе и явно указывается в
  pom.xml.
- Применение: Используется на этапах компиляции и тестирования.
    - Требует явного указания пути к JAR-файлу через
      элемент 'systemPath'.
- Ограничения: Не рекомендуется использовать из-за жесткой привязки к локальной файловой системе и невозможности работы
  с репозиториями Maven.

Пример использования: Системные библиотеки, которые не могут быть размещены в репозиториях Maven.

6)`import` (доступна только для зависимостей типа pom)

- Описание: Используется для импорта зависимостей из других POM-файлов, например, для управления версиями зависимостей
  через BOM (Bill of Materials).

- Применение: Применяется только с зависимостями типа pom.
    - Импортирует зависимости, указанные в другом POM-файле, и позволяет использовать их в текущем проекте.

[К оглавлению](#CollectionsPro)

# 32. Расскажите о жизненном цикле maven. В какой последовательности выполняются фазы цикла и что происходит на каждой фазе сборки?

Всего Maven's Default Lifecycle содержит 23 фазы

`clean` - очистка директории target

`validate` - проверка проекта на корректность и доступность необходимых зависимостей

`compile` - компиляция исходного кода в байт-код, файлы помещаются в target/classes

`test` - выполнение unit-тестов

`package` - упаковка скомпилированного кода в архив jar/war/ear и т.д.

`verify` - комплексная проверка на соответствие предопределенным правилам (в т.ч. с помощью плагинов)

`install` - установка пакета в локальный репозиторий для использования в качестве зависимости в других локальных
проектах

`deploy` - копирование финального пакета (архива) в удаленный репозиторий

[К оглавлению](#CollectionsPro)

