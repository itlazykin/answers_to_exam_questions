## OOP

[1. Что такое ООП?](#1-Что-такое-ООП)

[2. Базовые концепции ООП?](#2-Базовые-концепции-ООП)

[3. Укажите из каких элементов состоит класс. Расскажите о каждом из них.](#3-Укажите-из-каких-элементов-состоит-класс-Расскажите-о-каждом-из-них)

[4. Что такое конструктор?](#4-Что-такое-конструктор)

[5. Можно ли наследовать конструктор?](#5-Можно-ли-наследовать-конструктор)

[6. Что такое перегрузка конструктора?](#6-Что-такое-перегрузка-конструктора)

[7. Что такое статический метод?](#7-Что-такое-статический-метод)

[8. Что такое не статический метод?](#8-Что-такое-не-статический-метод)

[9. Для чего используется ключевое слово this?](#9-Для-чего-используется-ключевое-слово-this)

[10. Какой класс является базовым родительским классом для всех классов?](#10-Какой-класс-является-базовым-родительским-классом-для-всех-классов)

[11. Что такое наследование? Приведите примеры из реальной жизни.](#11-Что-такое-наследование-Приведите-примеры-из-реальной-жизни)

[12. Опишите процесс создания нового объекта.](#12-Опишите-процесс-создания-нового-объекта)

[13. Как вызвать метод из родительского класса?](#13-Как-вызвать-метод-из-родительского-класса)

[14. Что такое переопределение метода?](#14-Что-такое-переопределение-метода)

[15. Можно ли переопределить статический метод?](#15-Можно-ли-переопределить-статический-метод)

[16. Что такое сокрытие метода?](#16-Что-такое-сокрытие-метода)

[17. Что такое виртуальная функция и используются ли они в Java?](#17-Что-такое-виртуальная-функция-и-используются-ли-они-в-Java)

[18. Что такое перегрузка метода?](#18-Что-такое-перегрузка-метода)

[19. Можно ли изменить тип возвращаемых данных при перегрузке метода?](#19-Можно-ли-изменить-тип-возвращаемых-данных-при-перегрузке-метода)

[20. Что такое множественное наследование? Как его можно реализовать в Java.](#20-Что-такое-множественное-наследование-Как-его-можно-реализовать-в-Java)

[21. Что такое полиморфизм? Приведите примеры из реальной жизни.](#21-Что-такое-полиморфизм-Приведите-примеры-из-реальной-жизни)

[22. Что такое инкапсуляция?](#22-Что-такое-инкапсуляция)

[23. Как реализована инкапсуляция в Java? ](#23-Как-реализована-инкапсуляция-в-Java)

[24. Можно ли применить модификаторы доступа к конструкторам?](#24-Можно-ли-применить-модификаторы-доступа-к-конструкторам)

[25. Что такое интерфейс?](#25-Что-такое-интерфейс)

[26. Перечислите элементы, которые может содержать интерфейс.](#26-Перечислите-элементы-которые-может-содержать-интерфейс)

[27. Можно ли создать объект интерфейса? Если да, то как?](#27-Можно-ли-создать-объект-интерфейса-Если-да-то-как)

[28. Может ли интерфейс содержать какие-либо методы с реализацией? Если да, то какие?](#28-Может-ли-интерфейс-содержать-какие-либо-методы-с-реализацией-Если-да-то-какие)

[29. Что такое абстракция?](#29-Что-такое-абстракция)

[30. Что такое абстрактный класс?](#30-Что-такое-абстрактный-класс)

[31. Сколько абстрактных методов должен и может содержать абстрактный класс?](#31-Сколько-абстрактных-методов-должен-и-может-содержать-абстрактный-класс)

[32. Может ли абстрактный класс содержать обычные методы?](#32-Может-ли-абстрактный-класс-содержать-обычные-методы)

[33. Сколько объектов абстрактного класса можно создать в программе?](#33-Сколько-объектов-абстрактного-класса-можно-создать-в-программе)

[34. Что нужно делать, если наследник абстрактного класса не переопределяет все абстрактные методы родителя?](#34-Что-нужно-делать-если-наследник-абстрактного-класса-не-переопределяет-все-абстрактные-методы-родителя)

[35. Чем отличается интерфейс от абстрактного класса?](#35-Чем-отличается-интерфейс-от-абстрактного-класса)

[36. Что такое вложенные классы? Зачем они нужны?](#36-Что-такое-вложенные-классы-Зачем-они-нужны)

[37. Какие типы вложенных классов существуют в Java?](#37-Какие-типы-вложенных-классов-существуют-в-Java)

[38. Что такое внутренний класс? Когда он применяется?](#38-Что-такое-внутренний-класс-Когда-он-применяется)

[39. Что такое статический вложенный класс? Когда он применяется?](#39-Что-такое-статический-вложенный-класс-Когда-он-применяется)

[40. Сколько объектов статического вложенного класса можно создать в программе?](#40-Сколько-объектов-статического-вложенного-класса-можно-создать-в-программе)

[41. Что такое локальный класс? Когда он применяется?](#41-Что-такое-локальный-класс-Когда-он-применяется)

[42. Что такое анонимный класс? Когда он применяется?](#42-Что-такое-анонимный-класс-Когда-он-применяется)

[43. Сколько объектов анонимного класса можно создать в программе?](#43-Сколько-объектов-анонимного-класса-можно-создать-в-программе)

[44. Что такое исключения? Какие типы исключительных ситуаций бывают?](#44-Что-такое-исключения-Какие-типы-исключительных-ситуаций-бывают)

[45. Назовите основные методы класса Object?](#45-Назовите-основные-методы-класса-Object)

[46. Что такое шаблоны проектирования?](#46-Что-такое-шаблоны-проектирования)

[47. Объясните шаблон декоратор. Придумайте пример, не относящийся к технике.](#47-Объясните-шаблон-декоратор-Придумайте-пример-не-относящийся-к-технике)

[48. Объясните шаблон стратегия. Придумайте пример, не относящийся к технике.](#48-Объясните-шаблон-стратегия-Придумайте-пример-не-относящийся-к-технике)

[49. Объясните шаблон синглтон. Придумайте пример, не относящийся к технике.](#49-Объясните-шаблон-синглтон-Придумайте-пример-не-относящийся-к-технике)

[50. Объясните шаблон фабричный метод. Придумайте пример, не относящийся к технике.](#50-Объясните-шаблон-фабричный-метод-Придумайте-пример-не-относящийся-к-технике)

[51. Что такое enum? Когда можно его применять?](#51-Что-такое-enum-Когда-можно-его-применять)

[52. Что такое record? Когда можно его применять?](#52-Что-такое-record-Когда-можно-его-применять)

[53. Зачем нужны StringBuilder, StringBuffer, StringJoiner? Что они делают?](#53-Зачем-нужны-StringBuilder-StringBuffer-StringJoiner-Что-они-делают)

[54. Чем отличаются StringBuffer и StringBuilder?](#54-Чем-отличаются-StringBuffer-и-StringBuilder)

[55. Каким образом производится экранирование символов и зачем это нужно?](#55-Каким-образом-производится-экранирование-символов-и-зачем-это-нужно)

[56. Что такое управляющие последовательности?](#56-Что-такое-управляющие-последовательности)

[57. Зачем нужно форматирование данных? Метод format()](#57-Зачем-нужно-форматирование-данных-Метод-format)

[58. Что такое varargs? В каких случаях стоит его применять?](#58-Что-такое-varargs-В-каких-случаях-стоит-его-применять)

[59. В каких случаях может возникнуть неоднозначность при работе с varargs?](#59-В-каких-случаях-может-возникнуть-неоднозначность-при-работе-с-varargs)

[60. Что такое форматированный вывод? Какие механизмы позволяют осуществить форматированный вывод?](#60-Что-такое-форматированный-вывод-Какие-механизмы-позволяют-осуществить-форматированный-вывод)

[61. Объясните отличие анонимного класса от локального класса?](#61-Объясните-отличие-анонимного-класса-от-локального-класса)

[62. Расскажите про методы в классе](#62-Расскажите-про-методы-в-классе)

# 1. Что такое ООП?

Объектно-ориентированное программирование (ООП) — это парадигма программирования, которая основывается на концепции
объектов. Объекты являются экземплярами классов, которые содержат данные (в виде полей или атрибутов) и методы для
работы с этими данными.
ООП разработано так, что бы упростить расширение программ и их поддержку.
ООП программу можно охарактеризовать, как данные, управляющие доступом к коду.

Минусы ООП:

+ идеи ООП сложны для понимания.
+ требуется больше памяти, тк программа состоит из классов, методов, интерфейсов.
+ необходим большой набор первоначальных знаний, для того, что бы что-то написать.
+ большие временные затраты на первоначальный анализ.

Плюсы ООП:

+ легко читается – не нужно выискивать в коде функции и выяснять, за что они отвечают.
+ быстро пишется – можно быстро создать сущности, с которыми должна работать программа.
+ простота реализации большого функционала – т. к. на написание кода уходит меньше времени, можно гораздо быстрее
  создать приложение с множеством возможностей.

[К оглавлению](#OOP)

# 2. Базовые концепции ООП?

+ **Класс** - то шаблон или чертёж для создания объектов. В классе описываются свойства (переменные) и поведение (
  методы), которые будут иметь объекты.
+ **Объект** - это экземпляр класса, который создаётся на основе его описания. Объекты взаимодействуют друг с другом
  через методы.
+ **Абстракция** - это модель некоего объекта или явления реального мира, откидывающая незначимые детали, не играющие
  существенной роли в данном контексте. Т.е. она позволяет при работе с объектом не задумываться о его внутренней
  реализации, так же как и в жизни мы не задумываемся какие процессы происходят в телефоне, когда мы им пользуемся. В
  Java: через классы.
+ **Полиморфизм** - способность программы выбирать различные реализации, при вызове операций с одним и тем же названием.
  Полиморфизм в java достигается за счет использования интерфейсов.
+ **Инкапсуляция** - это способность объектов скрывать часть своего состояния и поведения от других объектов,
  предоставляя внешнему миру только интерфейс взаимодействия с собой. В Java: Используются
  модификаторы доступа public, private, package;
+ **Наследование** - свойство системы позволяющее описать новый класс на основе уже существующего с частично или
  полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым,
  родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом.

[К оглавлению](#OOP)

# 3. Укажите из каких элементов состоит класс. Расскажите о каждом из них.

Класс - это своеобразный шаблон, по которому создаются объекты. Класс - логическая конструкция, объект - физическое
воплощение. Например: форма для запекания леденцов - класс, леденец, который мы изготовили из этой формы - объект. Класс
состоит из:

+ название класса (Имя класса)
+ полей(переменных), то что объект про себя знает.
+ методов(функции для работы с полями), то что объект умеет делать.
+ конструкторы (специальные методы для создания объекта)
+ блоки инициализации (необязательные)
+ модификаторы доступа (public, private, protected)
+ вложенные классы или интерфейсы (опционально)
+ статические члены (static поля и методы, если есть)
+ аннотации (если применимо)
+ наследуемые элементы (если класс наследуется от другого)

Поля — это переменные, которые определяют состояние или свойства объекта, созданного на основе класса. Они хранят
данные, с которыми работают методы класса. Поля относятся к состоянию объектов и определяются внутри класса, но за его
пределами методов.
Поля бывают:

+ локальные переменные. Объявляются внутри методов. Уничтожаются по завершении работы метода, в котором объявлены.
+ переменные экземпляра. Доступны в пределах класса, из любого метода или иных блоков кода конкретного класса.
+ статические переменные. Такие переменные привязаны к классу, а не к объекту.

[К оглавлению](#OOP)

# 4. Что такое конструктор?

**Конструктор** — это специальный метод, который вызывается при создании нового объекта (всегда вызывается совместно с
операцией `new`). Конструктор служит для автоматической инициализации переменных, т.е. он инициализирует объект
непосредственно во время создания. Имя конструктора совпадает с именем класса, включая регистр, а по синтаксису
конструктор похож на метод без возвращаемого значения `void`.

Виды конструкторов:

+ конструктор по умолчанию или неявный (без параметров - позволяет регулировать, какие параметры и в каком количестве
  нужно задать для создания объекта определенного класса).
+ конструктор с параметрами или явный.

Особенности конструктора:

- Имя конструктора — всегда совпадает с именем класса.
- Отсутствие возвращаемого значения — конструктор не возвращает значение и не имеет типа возвращаемого значения (
  например, void).
- Модификаторы доступа — конструкторы могут быть public, private, protected или package-private (без модификатора), в
  зависимости от того, где должен быть доступен конструктор.
- Множественные конструкторы — класс может иметь несколько конструкторов с разными параметрами (перегрузка
  конструкторов), чтобы обеспечивать различные способы создания объекта.
- Неявный конструктор — если в классе не определён ни один конструктор, Java автоматически создаёт конструктор по
  умолчанию, который не принимает аргументов.

[К оглавлению](#OOP)

# 5. Можно ли наследовать конструктор?

Конструктор не является полем класса, поэтому его нельзя наследовать, но его можно вызвать с помощью ключевого
слова `super`. Если в наследнике не указан конструктор, то конструктор по умолчанию вызывает конструктор по умолчанию
своего родителя.

[К оглавлению](#OOP)

# 6. Что такое перегрузка конструктора?

**Перегрузка конструктора** - это создание конструкторов с другим набором аргументов (как по количеству, так и по
порядку следования). Перегрузка конструктора позволяет установить различные способы начальной инициализации объектов
класса. Если был создан конструктор, принимающий аргументы, а нам нужен конструктор по умолчанию (без аргументов), то
его нужно создать явно.

[К оглавлению](#OOP)

# 7. Что такое статический метод?

**Статический метод** - это метод, который принадлежит классу, а не конкретному объекту этого класса. Это означает, что
для вызова статического метода не требуется создавать экземпляр класса. Статические методы могут ссылаться только на
статические переменные. Это
гарантирует, что во время выполнения нашего метода все элементы будут инициализированы и будут работать. Это
называется "статическим контекстом".
Статические методы обычно используются для выполнения операции, не зависящей от создания экземпляра. При этом, они
широко используются для создания служебных или вспомогательных классов, поскольку их можно вызывать без
создания объекта этих классов.
В JDK служебные классы используются: Collections, Math, Arrays. Все методы этих классов являются статическими.

Когда использовать статические методы?

1. Для доступа или управления статическими переменными и другими статическими методами, которые не зависят от объектов;
2. Для служебных, вспомогательных классов и интерфейсов, поскольку не требуют создания объекта и соответственно,
   обеспечивают большую производительность;
3. Когда методу требуется доступ лишь к статическим полям класса.

Особенности статических методов:

1. Статические методы нельзя переопределять. Про переопределение методов будет позже в курсе, сейчас просто запомните,
   что статические методы не имеют возможности быть переопределенными;
2. Статические методы не могут использовать ключевые слова this (ссылка на текущий объект) или super (ссылка на объект
   супер класса);
3. Нестатические методы могут обращаться непосредственно как к методам класса (включая статические), так и к переменным
   класса (включая статические);
4. Статические методы могут обращаться к статическим переменным и статическим методам;
5. Статические методы могут обращаться ко всем статическим переменным и другим статическим методам. Однако они не могут
   напрямую обращаться к переменным класса и нестатическим методам. Для этого им нужны ссылки на объект.

[К оглавлению](#OOP)

# 8. Что такое не статический метод?

**Не статический метод** - это метод, для работы которого необходим объект. Т.е. он принадлежит объекту класса и
может быть вызван с помощью ссылки на данный объект. Не статические методы могут обращаться к полям класса, к
статическим так и не статическим.

[К оглавлению](#OOP)

# 9. Для чего используется ключевое слово this?

Ключевое слово `this` используется в Java для указания на текущий экземпляр объекта. Например, если мы хотим обратиться
к полю или методу текущего объекта внутри метода, мы можем использовать `this`.

`this` используется:

+ в теле любого метода для ссылки на текущий объект, чтобы обращаться к полям и методам данного класса.
  Например, когда у переменной экземпляра и переменной метода\конструктора одинаковые имена.

+ когда нужно вызвать один конструктор из другого (например, конструктор по умолчанию вызывается в параметризованном).
  Вызов `this` может находиться только в первой строке конструктора.

[К оглавлению](#OOP)

# 10. Какой класс является базовым родительским классом для всех классов?

`Object` - корневой класс в иерархии классов Java. Все не примитивные типы, включая массивы, наследуют прямо или
косвенно от него. Поэтому ссылочная переменная класса `Object` может ссылаться на объект любого другого класса.

[К оглавлению](#OOP)

# 11. Что такое наследование? Приведите примеры из реальной жизни.

Наследование — это один из ключевых принципов объектно-ориентированного программирования (ООП), который позволяет одному
классу (наследнику) унаследовать поля и методы другого класса (родительского класса). Наследование помогает повторно
использовать код, упрощать разработку и поддерживать архитектуру приложения.

Основные моменты наследования:
- Класс-родитель (базовый класс, суперкласс) — это класс, от которого происходит наследование. Он содержит общие поля и
методы, которые могут использоваться в классах-наследниках.
- Класс-наследник (производный класс, подкласс) — это класс, который наследует функциональность базового класса и может
добавлять собственные поля и методы или переопределять методы родителя.
- Модификатор extends — используется для указания наследования. Класс-наследник расширяет родительский класс.
- Переопределение методов — класс-наследник может изменить реализацию методов родителя с помощью аннотации @Override,
чтобы реализовать своё поведение.
```java
// Родительский класс (суперкласс)
class Animal {
    protected String name;

    // Конструктор родительского класса
    public Animal(String name) {
        this.name = name;
    }

    // Метод родительского класса
    public void makeSound() {
        System.out.println("Some generic animal sound");
    }

    public void displayInfo() {
        System.out.println("Animal: " + name);
    }
}

// Класс-наследник (подкласс)
class Dog extends Animal {

    // Конструктор класса-наследника
    public Dog(String name) {
        super(name);  // Вызов конструктора родительского класса
    }

    // Переопределение метода makeSound() для собаки
    @Override
    public void makeSound() {
        System.out.println(name + " says: Woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        // Создание объекта класса-наследника
        Dog dog = new Dog("Buddy");
        
        // Вызов метода родительского класса
        dog.displayInfo();  // Animal: Buddy

        // Вызов переопределённого метода
        dog.makeSound();  // Buddy says: Woof!
    }
}
```

Пример наследования: класс автомобиль.
На основе его можно создать дочерние классы - седан, хэтчбек, кабриолет. Дочерние классы были созданы на базе класса
автомобиль, они обладают всеми свойствами класса автомобиль, но так же имеют свои уникальные особенности, такие как
разный внешний вид.

[К оглавлению](#OOP)

# 12. Опишите процесс создания нового объекта.

Объявляем переменную класса с именем и типом объекта -> с помощью ключевого слова `new` резервируем память для объекта,
происходит вызов конструктора, который инициализирует новый объект.

[К оглавлению](#OOP)

# 13. Как вызвать метод из родительского класса?

Чтобы вызвать метод из родительского класса в классе-наследнике, в Java используется ключевое слово super. Оно позволяет
обращаться к методам и конструкторам родительского класса. Вызов метода через super обычно применяется, если нужно
вызвать метод родителя, который был переопределён в классе-наследнике, или просто использовать родительскую реализацию.

[К оглавлению](#OOP)

# 14. Что такое переопределение метода?

Переопределение метода - это механизм, который позволяет подклассу изменять реализацию метода, определенного в
супер классе. Это позволяет подклассу контролировать поведение метода, не изменяя его сигнатуру или имя. Имя метода,
порядок параметров, параметры, тип возвращаемого значения должны совпадать с базовым классом. IDEA позволяет с помощью
аннотации `@Override` проверить правильность кода на стадии его компиляции. Этим уменьшает возникновение
непредвиденных ошибок. Переопределять можно только нестатические методы. Если же попытаемся переопределить
статический метод, это будет называться "сокрытием метода из супер класса".

[К оглавлению](#OOP)

# 15. Можно ли переопределить статический метод?

Нет, нельзя переопределить статический метод в Java. Переопределение методов возможно только для нестатических методов.
Статические методы связаны с классом, а не с экземпляром класса, поэтому они не могут быть переопределены.

[К оглавлению](#OOP)

# 16. Что такое сокрытие метода?

Сокрытие метода - это когда дочерний класс определяет статический метод с такой же сигнатурой, что содержится в
родительском классе. Статические методы можно наследовать, но переопределить их нельзя. Обычный статический метод может
быть вызван из своего класса, аналогично скрытый статический метод также вызывается из своего класса. Если в дочернем
классе требуется изменить статический метод из родительского класса, это называется "Сокрытием статического метода" в
отличие от "переопределения" для нестатического метода `@overriding`. Во время компиляции статические методы связаны с
типом объявленной переменной, то есть какой класс объявлен в типе, статический метод того класса и будет вызван.

[К оглавлению](#OOP)

# 17. Что такое виртуальная функция и используются ли они в Java?

Виртуальная функция - это функция (метод), которая может быть переопределена наследником. То есть почти все
нестатические методы Java - это виртуальные функции (кроме private-методов, так как они не могут быть переопределены в
связи с правами видимости). Статические методы принадлежат классу и не могут быть переопределены, поэтому они не
являются виртуальными функциями.

[К оглавлению](#OOP)

# 18. Что такое перегрузка метода?

Это механизм позволяющий создавать методы с одинаковыми именами, но разными входными параметрами. При вызове
перегруженного метода компилятор автоматически определяет нужный вариант метода по его параметрам, которые указаны при
вызове.

[К оглавлению](#OOP)

# 19. Можно ли изменить тип возвращаемых данных при перегрузке метода?

Можно, если списки аргументов отличаются, иначе JVM не поймет какой метод ей нужно вызвать. Т.е. если меняем тип
возвращаемого значения, то мы также должны изменить список аргументов перегружаемого метода.

[К оглавлению](#OOP)

# 20. Что такое множественное наследование? Как его можно реализовать в Java.

Множественное наследование — это концепция в объектно-ориентированном программировании, при которой класс может
наследовать поведение и свойства более чем одного супер класса. В Java множественное наследование классов не
поддерживается напрямую. Это означает, что класс может иметь только одного непосредственного супер класса. Это
ограничение введено, чтобы избежать сложности и неоднозначности, связанные с "алмазной проблемой".
Множественное наследование в java можно реализовать, или через интерфейсы,
или используя агрегацию, или композицию - т.е. подключить нужные нам классы
через переменную или параметр.

Композиция - отношения "часть целое" между двумя объектами, когда один из них включает в себя другой. Особенность этого
отношения заключается в том, что компонент может существовать только как часть контейнера. Например: Университет состоит
из кафедр.

Агрегация - менее строгий вариант композиции, когда один объект имеет ссылку на другой объект. Здесь контейнер не
управляет жизненным циклом компонента. Компонент может существовать отдельно от контейнера. Например: кафедра состоит из
профессоров.

Ассоциация - когда объект использует другой объект, либо зависит от него. Возможна двухсторонняя ассоциация между
объектами. Например: профессор взаимодействует со студентами.

[К оглавлению](#OOP)

# 21. Что такое полиморфизм? Приведите примеры из реальной жизни.

Полиморфизм — это одна из ключевых концепций объектно-ориентированного программирования (ООП), которая позволяет
объектам разных типов реагировать на одни и те же вызовы методов по-разному.
. Основная идея полиморфизма заключается в том, что один и тот же метод может вести себя по-разному в зависимости от
типа объекта, который вызывает этот метод. Это обеспечивает гибкость и расширяемость кода, так как мы можем работать с
объектами через их родительские типы, но при этом они будут выполнять специфичные для них действия.

Например: собачье обоняние - полиморфное свойство. Если собака учует запах кота - она залает и погонится за
ним. Если собака учует запах своего корма, у нее начнется слюноотделение и она побежит к своей миске. В обоих случаях
действует одно и тоже-чувство обоняния, отличие в том, что именно издает запах, т.е. в типе данных воздействующих на нос
собаки.

[К оглавлению](#OOP)

# 22. Что такое инкапсуляция?

Инкапсуляция — это один из принципов объектно-ориентированного программирования (ООП), который заключается в сокрытии
внутренних деталей объекта и предоставлении доступа к ним только через публичные методы (геттеры и сеттеры). Это
помогает защитить данные от некорректного использования и модификации извне.

Краткие характеристики инкапсуляции:
- Сокрытие данных — поля объекта обычно помечаются как private, чтобы их нельзя было изменить напрямую из других классов.
- Геттеры и сеттеры — публичные методы (get и set), которые обеспечивают контролируемый доступ к приватным полям объекта.
- Упрощение управления доступом — класс может управлять тем, какие данные доступны извне, и как они могут изменяться.
- Улучшение безопасности и устойчивости — скрытие деталей реализации предотвращает некорректное изменение состояния
объекта извне.

[К оглавлению](#OOP)

# 23. Как реализована инкапсуляция в Java?

В Java инкапсуляция реализуется с помощью модификаторов доступа (public, private, protected), и специальными методами
для их изменения(get и set) Поля объявляются с
модификатором private, а методы, осуществляющие доступ к этим полям, — public.

- public - доступен везде в программе.
- private - доступен внутри класса.
- default - доступен внутри пакета.
- protected - доступен внутри пакета и в наследниках.

[К оглавлению](#OOP)

# 24. Можно ли применить модификаторы доступа к конструкторам?

Да, модификаторы доступа можно применить к:

- классу.
- конструктору.
- методу.
- поля класса.

Модификаторы доступа нельзя применить только к локальным переменным.

[К оглавлению](#OOP)

# 25. Что такое интерфейс?

Это набор правил, которые должны быть реализованны в классе. Интерфейс содержит объявление методов, но не содержит
реализации этих методов. Интерфейс определяет, что должен делать класс, но не знает как. Интерфейс позволяет создавать
общий тип данных для различных объектов, т.е. использование интерфейса гарантирует наличие определенного метода у
объекта. При реализации интерфейса класс должен реализовывать все его методы, иначе он должен быть помечен,
как `abstract`

[К оглавлению](#OOP)

# 26. Перечислите элементы, которые может содержать интерфейс.

В Java интерфейс может содержать следующие элементы:

Абстрактные методы (abstract) — это методы без реализации, которые должны быть реализованы в классах, которые реализуют
интерфейс. По умолчанию, все методы в интерфейсе до Java 8 считались абстрактными.

```java
void methodName();
```

Методы по умолчанию (default) — методы с реализацией, добавленные начиная с Java 8. Классы, которые реализуют интерфейс,
могут использовать эти методы по умолчанию, но могут и переопределить их.

```java
default void defaultMethod() {
    System.out.println("This is a default method.");
}
```

Статические методы (static) — методы с реализацией, которые можно вызывать напрямую через интерфейс, а не через объект
класса. Также добавлены с Java 8.

```java
static void staticMethod() {
    System.out.println("This is a static method.");
}
```

Константы (static final) — интерфейс может содержать константы (переменные, которые автоматически являются public static
final), и они должны быть инициализированы при объявлении.

```java
static final int MAX_VALUE = 100;
```

Частные методы (private) — начиная с Java 9, интерфейсы могут содержать приватные методы, которые позволяют разделять
код между методами по умолчанию и статическими методами. Эти методы доступны только внутри интерфейса.

```java
private void privateMethod() {
    System.out.println("This is a private method.");
}
```

Пример интерфейса, включающего все элементы:

```java
interface MyInterface {

    // Абстрактный метод
    void abstractMethod();

    // Метод по умолчанию
    default void defaultMethod() {
        System.out.println("This is a default method.");
    }

    // Статический метод
    static void staticMethod() {
        System.out.println("This is a static method.");
    }

    // Константа (public static final автоматически)
    int MAX_VALUE = 100;

    // Приватный метод (начиная с Java 9)
    private void privateMethod() {
        System.out.println("This is a private method.");
    }

    // Пример вызова приватного метода внутри метода по умолчанию
    default void usePrivateMethod() {
        privateMethod();
    }
}
```

Элементы интерфейса:

- Абстрактные методы — обязательны к реализации в классе, который реализует интерфейс.
- Методы по умолчанию — содержат реализацию и могут быть переопределены в классе.
- Статические методы — доступны через интерфейс, не требуют создания объекта.
- Константы — переменные, которые всегда public static final.
- Приватные методы — используются для делегирования кода внутри интерфейса, недоступны извне.

[К оглавлению](#OOP)

# 27. Можно ли создать объект интерфейса? Если да, то как?

Нет, нельзя напрямую создать объект интерфейса в Java, так как интерфейс — это абстрактный тип, и он не содержит полной
реализации методов. Однако, есть способы, которые позволяют работать с объектами интерфейса косвенно.

Как можно работать с объектами интерфейса:
- Реализация интерфейса в классе — класс, который реализует интерфейс, может быть использован для создания объекта, и этот
объект может быть ссылкой на интерфейс. Это основной способ работы с интерфейсами.
- Анонимные классы — можно создать объект интерфейса с помощью анонимного класса (это полезно, когда нужен одноразовый
объект с минимальной реализацией).
- Лямбда-выражения — начиная с Java 8, интерфейсы с одним методом (функциональные интерфейсы) могут быть реализованы с
помощью лямбда-выражений.

[К оглавлению](#OOP)

# 28. Может ли интерфейс содержать какие-либо методы с реализацией? Если да, то какие?

Начиная с Java 8 мы можем включать в интерфейсы методы с реализацией - статические или дефолтные, а начиная с Java 9 еще
приватные и статические.

[К оглавлению](#OOP)

# 29. Что такое абстракция?

Абстракция — это один из ключевых принципов объектно-ориентированного программирования (ООП), который заключается в
сокрытии сложных деталей реализации и предоставлении пользователю только тех аспектов, которые необходимы для
использования объекта. Абстракция помогает сконцентрироваться на важных характеристиках объекта и скрыть ненужные
детали.

Основные моменты абстракции:
- Скрытие деталей реализации — пользователям предоставляется только интерфейс для взаимодействия с объектом, а детали его
внутренней работы остаются скрытыми.
- Упрощение работы с объектами — благодаря абстракции можно работать с объектами, не зная, как они реализованы, что
упрощает использование и поддержку программного кода.
- Чёткое разделение ответственности — абстракция позволяет отделить что объект делает от того, как он это делает.

Как реализуется абстракция в Java:
- Абстрактные классы — классы, которые могут содержать как абстрактные (без реализации), так и конкретные методы.
Абстрактный класс нельзя использовать для создания объектов напрямую, он служит для создания общих базовых классов для
других классов.
- Интерфейсы — интерфейсы обеспечивают ещё более высокий уровень абстракции. Они содержат только абстрактные методы (или
методы по умолчанию), которые должны быть реализованы в классах, которые их реализуют.

[К оглавлению](#OOP)

# 30. Что такое абстрактный класс?

Абстрактный класс в Java — это класс, который не может быть инстанцирован напрямую (нельзя создать объект абстрактного
класса). Он служит как базовый класс для других классов и может содержать как абстрактные методы (без реализации), так и
конкретные методы (с реализацией). Абстрактный класс определяет общие характеристики для всех своих подклассов, а
конкретные классы должны реализовать абстрактные методы этого класса.

Когда использовать абстрактный класс:
- Для общего поведения — когда нужно описать общее поведение для группы классов, но не имеет смысла создавать объект
базового класса.
- Для частичной реализации — если несколько классов должны иметь схожую логику, абстрактный класс может содержать
реализацию общих методов и абстрактные методы, которые должны быть реализованы в каждом конкретном классе.
- Для создания шаблонов — абстрактные классы полезны в ситуациях, когда разные классы должны следовать одному шаблону, но
реализуют его по-своему.

Преимущества абстрактных классов:
- Частичная реализация — можно определить общие методы, которые будут использованы в наследниках.
- Сокрытие ненужных деталей — абстрактные классы могут скрывать детали реализации, предоставляя только необходимые
абстрактные методы для реализации.
- Гибкость — позволяет предоставлять как методы с реализацией, так и абстрактные методы, которые должны быть реализованы в
классах-наследниках.

[К оглавлению](#OOP)

# 31. Сколько абстрактных методов должен и может содержать абстрактный класс?

Не ограниченно, но если много абстрактных методов это, может быть, сигналом о том, что мой класс слишком сложен и его
следует разделить на несколько более простых классов.

[К оглавлению](#OOP)

# 32. Может ли абстрактный класс содержать обычные методы?

Да. Такие методы должны быть обязательно реализованы в подклассах, иначе класс так же становится абстрактным.

[К оглавлению](#OOP)

# 33. Сколько объектов абстрактного класса можно создать в программе?

Невозможно создать объекты абстрактного класса напрямую. Абстрактные классы предназначены для предоставления частичной
или общей функциональности для классов-наследников и служат в качестве шаблона. Таким образом, количество объектов
абстрактного класса, которые можно создать напрямую, — всегда 0.
- Абстрактный класс — это нечто вроде шаблона или конструкции, которая предоставляет частичную реализацию и общую
функциональность для своих подклассов.
- Объекты абстрактных классов напрямую создать нельзя, но можно создать объекты классов-наследников, которые реализуют все
абстрактные методы.

[К оглавлению](#OOP)

# 34. Что нужно делать, если наследник абстрактного класса не переопределяет все абстрактные методы родителя?

Если наследник этого не делает, то он так же становится абстрактным. Если класс должен обязательно иметь реализацию всех
абстрактных методов его следует пометить как `final`

[К оглавлению](#OOP)

# 35. Чем отличается интерфейс от абстрактного класса?

Абстрактный класс:
- Может содержать как абстрактные, так и конкретные методы
- Может содержать поля и конструкторы
- Класс может наследовать только один абстрактный класс
- Используется для частичной реализации

Интерфейс:
- Содержит только абстрактные методы (до Java 8) и методы по умолчанию
- Не может содержать поля экземпляра (только константы)
- Класс может реализовывать несколько интерфейсов
- Используется для задания контракта (без реализации)

Абстрактные классы содержат частичную реализацию, которая дополняется или расширяется в подклассах. При этом все
подклассы схожи между собой в части реализации, унаследованной от абстрактного класса и отличаются лишь в части
собственной реализации абстрактных методов родителя. Поэтому абстрактные классы применяются в случае построения
однотипных иерархий. В этом случае наследование от абстрактного класса реализующего поведение объекта по умолчанию
может быть полезно, т.к. позволяет избежать дублирования кода. Во всех остальных случаях лучше использовать интерфейсы,
т.к. наследуясь от абстрактного класс растворяет собственную индивидуальность, а реализуя интерфейсы - расширяет свою
функциональность.

[К оглавлению](#OOP)

# 36. Что такое вложенные классы? Зачем они нужны?

Это классы, которые определены внутри других классов. Они нужны для того, что бы добавить дополнительную структуру и
организацию кода, а так же для инкапсуляции методов и данных, которые относятся к определенному контексту. Вложенные
классы предоставляют возможность использовать поля внешнего класса без необходимости создания экземпляра внешнего
класса. Это делает код более кратким и читаемым, т.к. не нужно создавать дополнительные переменные или методы для
доступа к полям внешнего класса. С помощью вложенных классов можно создать приватные классы, которые могут быть
использованы только в контексте внешнего класса, что обеспечивает дополнительную безопасность и защиту данных.

Когда использовать вложенные классы:
- Когда один класс используется только в контексте другого — если класс не имеет смысла вне внешнего класса, его можно
сделать вложенным.
- Когда нужна тесная связь между классами — внутренний класс может иметь доступ к приватным полям и методам внешнего
класса, что упрощает совместную работу между ними.
- Для повышения инкапсуляции — вложенные классы помогают скрыть детали реализации, которые не должны быть видны за
пределами внешнего класса.
- Для улучшения структуры и организации кода — вложенные классы делают код более понятным и логичным, особенно если они
логически связаны с внешним классом.

[К оглавлению](#OOP)

# 37. Какие типы вложенных классов существуют в Java?

- Статические вложенные классы (static nested classes) — это вложенные классы, которые могут существовать независимо от
экземпляра внешнего класса. Они ведут себя как обычные классы, но помещаются внутри другого класса.
- Внутренние классы (inner classes) — это вложенные классы, которые существуют внутри экземпляра внешнего класса и имеют
доступ ко всем его членам (включая приватные). Зависят от экземпляра внешнего класса и могут обращаться к его
нестатическим и приватным полям и методам
- Локальные классы (local classes) — это классы, которые объявляются внутри метода внешнего класса. Имеют доступ к
локальным переменным метода, если они помечены как final или эффективно final.
- Анонимные классы (anonymous classes) — это классы без имени, которые обычно используются для создания одноразовых
объектов с минимальной реализацией, и их создание происходит непосредственно при объявлении.

[К оглавлению](#OOP)

# 38. Что такое внутренний класс? Когда он применяется?

Внутренний класс - это не статический вложенный класс. Его применяют, когда нужно написать вспомогательный код для
другого класса. Так же внутренний класс скрывает переменные и методы от остальной части программы, что является хорошим
способом ограничения области их видимости. Внутренний класс так же применяют когда необходимо сохранить связь между
объектом внутреннего класса и объектом внешнего класса. Обычно внутренний класс наследуется от класса или реализует
интерфейс, а код внутри класса манипулирует объектом внешнего класса, в котором он был создан, поэтому можно считать
внутренний класс окном во внешний класс. Каждый внутренний класс способен независимо наследовать определенную
реализацию. Таким образом внутренний класс не ограничен при наследовании в ситуациях, где внешний класс уже наследует
реализацию. Внутренний класс не может существовать сам по себе, поэтому внутренний класс неявно имеет ссылку на объект
внешнего класса. Внутренний класс ассоциируется не с внешним классом, а с экземпляром внешнего класса. Внутренний класс
может обратиться к любому полю внешнего класса напрямую. В случае, если у вложенного класса уже существует поле с таким
же литералом, то обращаться к такому полю следует через ссылку на его экземпляр.

Например: представим класс авто с полями марка и модель, а так же с двумя внутренними классами: тормоза и трансмиссия, в
которых определены методы ускорения и торможения. В данном случает трансмиссия и тормоза это внутренние системы авто. В
контексте авто они не могут существовать отдельно от него.

[К оглавлению](#OOP)

# 39. Что такое статический вложенный класс? Когда он применяется?

Статический вложенный класс это вложенный класс в объявлении которого есть ключевое слово `static`. Как и другие
статические поля, они принадлежат внешнему классу, а не экземпляру класса. Статическим полям не требуется ссылка на
какой-либо объект. Статический вложенный класс не привязан к объекту, объект статического вложенного класса не хранит в
себе ссылку на внешний класс. Статический вложенный класс можно использовать когда прямая связь между вложенным и
внешним классами не требуется. При объявлении статического вложенного класса можно указать любой модификатор доступа.
Статический вложенный класс имеет доступ только к статическим полям во внешнем классе(в том числе к приватным). К
нестатическим полям и методам внешнего класса доступ можно получить только через ссылку на экземпляр внешнего класса.
Сам класс виден окружающим согласно установленному модификатору доступа.

[К оглавлению](#OOP)

# 40. Сколько объектов статического вложенного класса можно создать в программе?

Сколько угодно, это не статическая переменная, которая создается одна на все программу.

[К оглавлению](#OOP)

# 41. Что такое локальный класс? Когда он применяется?

Это разновидность внутреннего класса, в котором класс объявляется в другом классе внутри какого либо блока кода. Его
можно объявить везде, где возможно объявить локальную переменную, он обладает такой же областью видимости. У локальных
классов есть имя, их можно использовать неоднократно.

Особенности локального класса:

- Время жизни локального класса ограниченно блоком кода, в котором он находится, либо пока в программе остаются рабочие
  ссылки на этот класс.
- Если локальный класс находится внутри статического метода, он имеет доступ только к статическим переменным внешнего
  класса.
- Создать экземпляр локального класса можно только после окончания блока кода самого локального класса.
- За пределами внешнего класса локальные переменные недоступны, но экземпляры локальных методов можно использовать, как
  и обычные классы, используя их в качестве аргументов или возвращаемых значений.
- Имеют доступ к полям и методам внешнего класса.
- до java 16 локальные классы не могли содержать в себе статические объявления, допустимы только переменные константы. В
  Java 16 произошло обновление. Начиная с которого все виды внутренних классов поддерживают статические объявления. Что
  бы иметь возможность объявлять в себе record, enum и локальные интерфейсы, которые неявно являются статическими при
  объявлении их во внутреннем классе.

Когда применяется локальный класс:
- Когда требуется вспомогательная логика, специфичная для метода:
- - Локальные классы полезны для выполнения вспомогательных операций, которые относятся только к конкретному методу или
блоку, и не должны быть доступны за его пределами.
- Для повышения инкапсуляции и структурирования кода:
- - Локальные классы помогают структурировать код и скрыть детали реализации, которые не должны быть видны за пределами
метода. Это улучшает инкапсуляцию и изолирует реализацию.
- Когда необходимо использовать класс внутри небольшого блока кода:
- - Локальные классы хороши для создания временных, одноразовых объектов, когда использование полноценного внешнего класса
нецелесообразно.
- При работе с переменными метода:
- - Локальный класс может взаимодействовать с локальными переменными метода или блока, если эти переменные объявлены как
final или не изменяются после своей инициализации (effectively final).

[К оглавлению](#OOP)

# 42. Что такое анонимный класс? Когда он применяется?

Это локальный класс без имени. Анонимным классом следует пользоваться, если нужен локальный класс для одноразового
использования. Создание экземпляра анонимного класса происходит одновременно с его объявлением(между скобками и точкой с
запятой, заключенный в фигурные скобки). В фигурных скобках находится полноценный класс, просто у него нет имени.
Анонимный класс может обращаться к переменным и методам внешнего класса, в том числе статическим и приватным. Цель
анонимного класса - это короткая запись класса для выполнения конкретной разовой задачи. У анонимного класса нет
конструктора. Анонимные классы могут наследовать другие классы, реализовывать интерфейсы. Внутри анонимного класса можно
переопределять методы родителя и писать свои методы. Анонимные классы следует использовать когда уже есть тип, который
описывает этот класс(либо его родителей), и задача будет выполняться один раз за всю работу программы(т.е. когда нам
нужен всего один экземпляр это класса). Анонимные классы желательно применять к компактным задачам, что бы не ухудшать
чтение кода.

[К оглавлению](#OOP)

# 43. Сколько объектов анонимного класса можно создать в программе?

Мы можем создать любое количество объектов анонимного класса, но следует помнить, что каждый анонимный класс создает
новый экземпляр внутреннего класса, что может привести к увеличению потребления памяти.

[К оглавлению](#OOP)

# 44. Что такое исключения? Какие типы исключительных ситуаций бывают?

Исключения (exceptions) в Java — это события, которые происходят во время выполнения программы и нарушают нормальный
поток её выполнения. Исключения представляют собой ошибки или непредвиденные ситуации, которые возникают в процессе
выполнения программы и требуют специальной обработки. Когда исключение возникает, оно прерывает нормальный ход программы
и передаёт управление обработчику исключений. Исключения делятся на несколько классов, но все они имеют общего предка -
класс `Throwable`,
потомками которого являются классы `Exception` и `Error`

`Error`  ошибки представляют собой серьезные проблемы которые не следует обрабатывать,
поскольку они связанны с проблемами уровня JVM. Например: закончилась память, доступная JVM(StackOverflow
error).

`Exceptions` исключения являются результатом проблем в программе - которые в принципе решаемы, предсказуемы, последствия
их возможно устранить внутри программы. Исключения делятся на проверяемые и не проверяемые.

- Проверяемые исключения. Проверяются во время компиляции программы и если такие исключения не обработать - программа не
  скомпилируется. Для обработки исключения используется блок `try-catch` и ключевое слово `throws` после сигнатуры
  метода. К таким исключениям относятся: готовые исключения подклассов IOException, SQLException, а так же все
  пользовательские исключения, которые наследуются от класса `Exception`.
- Не проверяемые исключения. Проверяются во время запуска программы, т.е. если их не обработать с помощью
  конструкции `try-catch`, то код скомпилируется без проблем. К непроверяемым исключениям относятся все наследники
  класса `RunTimeException`

[К оглавлению](#OOP)

# 45. Назовите основные методы класса Object?

public native int hashCode() — возвращает хеш-код объекта.

public boolean equals(Object obj) — сравнивает объекты.

public String toString() — возвращает строковое представление объекта.

public final native Class getClass() — возвращает в рантайме класс данного объекта.

protected native Object clone() throws CloneNotSupportedException — клонирование объекта

public final native void notify() — просыпается один поток, который ждет на "мониторе" данного объекта.

public final native void notifyAll() — просыпаются все потоки, которые ждут на "мониторе" данного объекта.

public final native void wait(long timeout) throws InterruptedException — поток переходит в режим ожидания в течение
указанного времени.

public final void wait() throws InterruptedException — приводит данный поток в ожидание, пока другой поток не вызовет
notify() или notifyAll() методы для этого объекта.

public final void wait(long timeout, int nanos) throws InterruptedException — приводит данный поток в ожидание, пока
другой поток не вызовет notify() или notifyAll() для этого метода, или пока не истечет указанный промежуток времени.

protected void finalize() throws Throwable — вызывается сборщиком мусора, когда garbage collector определил, что ссылок
на объект больше нет.

Модификатор native сигнализирует о том, что метод реализован в платформ-зависимом коде, часто на языке С.

[К оглавлению](#OOP)

# 46. Что такое шаблоны проектирования?

Шаблоны проектирования (design patterns) — это типовые решения часто встречающихся задач в разработке программного
обеспечения. Это готовые структуры или схемы, которые описывают, как организовать код для решения определённых проблем с
учётом гибкости, масштабируемости и поддерживаемости программы.

Основные характеристики шаблонов проектирования:
- Повторяемость — шаблоны проектирования представляют собой проверенные временем подходы, которые можно многократно
использовать в разных проектах и ситуациях.
- Оптимизация разработки — применение шаблонов помогает избежать распространённых ошибок и упрощает процесс разработки,
предоставляя готовые решения типичных задач.
- Повышение читаемости и поддержки — шаблоны проектирования стандартизируют способы решения задач, что делает код более
понятным для других разработчиков и упрощает его поддержку.
- Гибкость и расширяемость — шаблоны помогают создать код, который легко адаптируется к изменяющимся требованиям без
необходимости в серьёзных изменениях.

Классификация шаблонов проектирования:
- Порождающие шаблоны (Creational Patterns):
Отвечают за создание объектов, оптимизируя процесс их инстанцирования и управления. Эти шаблоны помогают избежать
создания объекта напрямую, предоставляя гибкие механизмы создания объектов.
Примеры: Singleton, Factory Method, Builder, Prototype, Abstract Factory.
- Структурные шаблоны (Structural Patterns):
Определяют, как объекты и классы могут быть связаны и организованы для формирования более крупных структур. Эти шаблоны
помогают организовать код и упростить его структуру.
Примеры: Adapter, Facade, Decorator, Composite, Bridge, Proxy.
- Поведенческие шаблоны (Behavioral Patterns):
Описывают взаимодействие между объектами и способ их координации. Эти шаблоны помогают управлять сложными
взаимодействиями между объектами, определяя способы передачи данных и команд.
Примеры: Observer, Strategy, Command, State, Chain of Responsibility, Mediator, Visitor.

Важные моменты:
- Шаблоны проектирования — это не конкретные классы или библиотеки, а скорее общие решения, которые могут быть реализованы
по-разному в зависимости от требований проекта.
- Повышение гибкости и поддерживаемости кода — использование шаблонов проектирования помогает структурировать код и
упрощает добавление новых функций.
- Универсальность и стандартизация — разработчики, использующие шаблоны проектирования, могут легко понимать и
адаптировать код, поскольку многие шаблоны стандартны и общеизвестны.

- [К оглавлению](#OOP)

# 47. Объясните шаблон декоратор. Придумайте пример, не относящийся к технике

Декоратор (Decorator) — это структурный шаблон проектирования, который позволяет добавлять новую функциональность
объектам динамически (во время выполнения) без изменения их структуры или создания подклассов. Шаблон предоставляет
гибкий механизм для расширения поведения объекта за счёт обёртывания его в другой объект (декоратор), который добавляет
или изменяет его функциональность.

Основные характеристики шаблона Декоратор:
Динамическое расширение функциональности — шаблон позволяет добавлять новое поведение объектам в процессе выполнения
программы, не изменяя их исходный код.

Использование композиции — вместо наследования декоратор использует композицию для добавления нового поведения. В этом
случае объект обёртывается другим объектом-декоратором, который добавляет свою функциональность, а затем делегирует
вызовы основному объекту.

Гибкость — можно оборачивать объект в несколько декораторов, добавляя несколько уровней поведения.

Как работает шаблон Декоратор:
Есть компонент (базовый интерфейс или класс), который определяет общий интерфейс для объекта.
Декоратор реализует тот же интерфейс и содержит ссылку на объект компонента. Все вызовы методов декоратора делегируются
обёрнутому объекту, и при необходимости добавляется дополнительное поведение.
Основной объект оборачивается в декоратор, чтобы добавить новые функции.
Структура:

- Компонент (Component) — общий интерфейс для основного объекта и его декораторов.
- Конкретный компонент (ConcreteComponent) — реализация компонента, которая будет декорироваться.
- Декоратор (Decorator) — класс, реализующий интерфейс компонента и содержащий ссылку на обёрнутый объект.
- Конкретный декоратор (ConcreteDecorator) — класс, расширяющий поведение объекта.

Пример реализации шаблона Декоратор:
Предположим, у нас есть базовый интерфейс Notifier для отправки уведомлений, и мы хотим добавить к нему возможность
отправки уведомлений через Email и SMS.

```java
// Компонент
interface Notifier {
    void send(String message);
}

// Конкретный компонент
class BasicNotifier implements Notifier {
    @Override
    public void send(String message) {
        System.out.println("Sending basic notification: " + message);
    }
}

// Декоратор
class NotifierDecorator implements Notifier {
    protected Notifier wrappedNotifier;

    public NotifierDecorator(Notifier notifier) {
        this.wrappedNotifier = notifier;
    }

    @Override
    public void send(String message) {
        wrappedNotifier.send(message);  // Делегируем вызов основному объекту
    }
}

// Конкретный декоратор (Email уведомление)
class EmailNotifier extends NotifierDecorator {
    public EmailNotifier(Notifier notifier) {
        super(notifier);
    }

    @Override
    public void send(String message) {
        super.send(message);
        System.out.println("Sending email notification: " + message);
    }
}

// Конкретный декоратор (SMS уведомление)
class SMSNotifier extends NotifierDecorator {
    public SMSNotifier(Notifier notifier) {
        super(notifier);
    }

    @Override
    public void send(String message) {
        super.send(message);
        System.out.println("Sending SMS notification: " + message);
    }
}

// Пример использования
public class Main {
    public static void main(String[] args) {
        // Базовое уведомление
        Notifier notifier = new BasicNotifier();

        // Добавляем функциональность отправки Email через декоратор
        Notifier emailNotifier = new EmailNotifier(notifier);

        // Добавляем функциональность отправки SMS через декоратор
        Notifier smsAndEmailNotifier = new SMSNotifier(emailNotifier);

        // Отправляем уведомление, используя оба декоратора
        smsAndEmailNotifier.send("Hello!");
        // Вывод:
        // Sending basic notification: Hello!
        // Sending email notification: Hello!
        // Sending SMS notification: Hello!
    }
}
```

Как работает этот пример:

1) У нас есть базовый класс BasicNotifier, который отправляет простые уведомления.

2) Сначала мы оборачиваем его в EmailNotifier, который добавляет возможность отправки email-уведомлений.

3) Затем мы оборачиваем его в SMSNotifier, который добавляет возможность отправки SMS-уведомлений.

4) В результате вызов метода send() сначала выполняет базовую функциональность, а затем добавляет дополнительные
   действия по отправке email и SMS.
   Когда применять шаблон Декоратор:
   Когда нужно динамически добавлять поведение — если требуется добавить новую функциональность объекту без изменения
   его исходного кода.

Когда использование наследования не подходит — наследование создаёт жёсткие связи между классами. Декоратор позволяет
более гибко изменять поведение объекта.

Для работы с библиотеками и классами, которые нельзя изменять — декоратор позволяет расширить функциональность классов,
не изменяя их исходный код.

Преимущества:
- Гибкость — поведение объектов можно изменять на лету, комбинируя различные декораторы.
- Композиция вместо наследования — это позволяет избежать создания множества подклассов и делает систему более гибкой.
- Упрощение кода — можно добавлять функциональность через декораторы, не изменяя существующий код.
- 
Недостатки:
- Сложность при многократном оборачивании — при большом количестве декораторов может стать сложно отслеживать порядок их
применения.
- Дополнительные объекты — каждый новый декоратор создаёт новый объект, что увеличивает использование памяти.

[К оглавлению](#OOP)

# 48. Объясните шаблон стратегия. Придумайте пример, не относящийся к технике.

Стратегия (Strategy) — это поведенческий шаблон проектирования, который определяет семейство алгоритмов, инкапсулирует
каждый из них и делает их взаимозаменяемыми. Шаблон позволяет динамически изменять поведение объекта на основе выбранной
стратегии (алгоритма) во время выполнения программы, не изменяя код самого объекта.

Основные характеристики шаблона Стратегия:
- Инкапсуляция алгоритмов — различные алгоритмы (или поведения) инкапсулируются в отдельных классах, которые реализуют
общий интерфейс. Это делает алгоритмы независимыми друг от друга и от клиента, который их использует.
- Динамическая замена — алгоритмы можно легко заменять во время выполнения программы, просто изменив объект стратегии, что
позволяет гибко адаптировать поведение объекта без изменения его кода.
- Снижение дублирования кода — шаблон помогает избавиться от сложных условных конструкций (например, if-else или switch) и
изолировать каждый алгоритм в своём классе.

Структура:
- Контекст (Context) — класс, который использует стратегию (алгоритм). Он содержит ссылку на объект стратегии и вызывает
его методы для выполнения конкретной задачи.
- Интерфейс стратегии (Strategy) — общий интерфейс для всех алгоритмов (стратегий), который определяет метод или методы,
которые каждая стратегия должна реализовать.
- Конкретные стратегии (ConcreteStrategy) — конкретные классы, которые реализуют различные алгоритмы, соответствующие
интерфейсу стратегии.

Пример реализации шаблона Стратегия:

Предположим, у нас есть система расчёта стоимости товаров с различными стратегиями скидок. Мы можем менять алгоритмы
расчёта скидок в зависимости от контекста (например, скидка для VIP-клиентов или сезонная скидка).
```java
// Интерфейс стратегии
interface DiscountStrategy {
double applyDiscount(double price);
}

// Конкретная стратегия - Сезонная скидка
class SeasonalDiscount implements DiscountStrategy {
@Override
public double applyDiscount(double price) {
return price * 0.9; // Скидка 10%
}
}

// Конкретная стратегия - Скидка для VIP-клиентов
class VIPDiscount implements DiscountStrategy {
@Override
public double applyDiscount(double price) {
return price * 0.8; // Скидка 20%
}
}

// Конкретная стратегия - Без скидки
class NoDiscount implements DiscountStrategy {
@Override
public double applyDiscount(double price) {
return price; // Нет скидки
}
}

// Контекст - класс, который использует стратегии
class PriceCalculator {
private DiscountStrategy discountStrategy;

    // Установка стратегии
    public void setDiscountStrategy(DiscountStrategy discountStrategy) {
        this.discountStrategy = discountStrategy;
    }

    // Расчёт цены с учётом выбранной стратегии скидки
    public double calculatePrice(double price) {
        return discountStrategy.applyDiscount(price);
    }

}

// Пример использования
public class Main {
public static void main(String[] args) {
PriceCalculator calculator = new PriceCalculator();

        // Применяем сезонную скидку
        calculator.setDiscountStrategy(new SeasonalDiscount());
        System.out.println("Price with seasonal discount: " + calculator.calculatePrice(100));

        // Применяем скидку для VIP-клиентов
        calculator.setDiscountStrategy(new VIPDiscount());
        System.out.println("Price with VIP discount: " + calculator.calculatePrice(100));

        // Применяем стратегию без скидки
        calculator.setDiscountStrategy(new NoDiscount());
        System.out.println("Price without discount: " + calculator.calculatePrice(100));
    }

}
```
Как это работает:
- Контекст — класс PriceCalculator, который использует объект стратегии для расчёта цены с учётом скидки.
- Стратегии — три конкретные стратегии: SeasonalDiscount, VIPDiscount и NoDiscount, каждая из которых реализует свою
логику расчёта скидки.
- Динамическая замена — объект PriceCalculator может динамически менять стратегию во время выполнения программы, вызывая
  метод setDiscountStrategy().

Когда применять шаблон Стратегия:

- Когда нужно выбирать поведение (алгоритм) во время выполнения программы: Шаблон "Стратегия" полезен, когда объект
  должен изменять своё поведение в зависимости от ситуации (например, различные
  способы сортировки данных, различные стратегии скидок).
- Когда нужно избежать сложных условных конструкций: Стратегия позволяет избавиться от громоздких if-else или switch
  конструкций, переместив каждый алгоритм в отдельный
  класс.
- Когда нужно сделать алгоритмы взаимозаменяемыми: Стратегии можно легко заменять и комбинировать без изменения
  основного кода программы.

Преимущества:

- Гибкость — можно легко добавлять новые алгоритмы, не изменяя существующий код.
- Чистота кода — каждый алгоритм изолирован в своём классе, что делает код более поддерживаемым и чистым.
- Легко расширяем — добавление новых стратегий не требует изменения существующих классов, что упрощает развитие системы.

Недостатки:

- Усложнение системы — создание множества классов для каждой стратегии может усложнить код и сделать его более
  громоздким.
- Необходимость использования интерфейсов — для реализации каждой стратегии требуется создание интерфейсов или
  абстрактных
  классов.

Важные моменты:

- Контекст и стратегия — контекст хранит ссылку на стратегию и делегирует выполнение задач этому объекту, не зная
  деталей
  его реализации.
- Гибкость замены алгоритмов — алгоритмы можно изменять во время выполнения программы.
- Меньше условных операторов — шаблон помогает избежать множества условных выражений, улучшая читаемость кода.

[К оглавлению](#OOP)

# 49. Объясните шаблон синглтон. Придумайте пример, не относящийся к технике.

Синглтон (Singleton) — это порождающий шаблон проектирования, который гарантирует, что у класса будет только один
экземпляр, и предоставляет глобальную точку доступа к этому экземпляру. Шаблон часто используется, когда необходимо,
чтобы какой-либо ресурс, объект или сервис был единственным в системе.

Основные характеристики шаблона Синглтон:

- Единичность — шаблон гарантирует, что для данного класса будет создан только один объект на протяжении всего времени
  выполнения программы.
- Глобальная точка доступа — шаблон предоставляет глобальный доступ к объекту синглтона, позволяя получать его экземпляр
  в любом месте программы.
- Контроль над созданием объекта — создание экземпляра синглтона строго контролируется самим классом. Обычно объект
  создаётся при первом запросе и больше не создаётся повторно.

Структура:

- Приватный конструктор — предотвращает создание объектов снаружи класса.
- Статическое поле — для хранения единственного экземпляра класса.
- Статический метод — для получения экземпляра класса (часто называется getInstance()).

Пример классического синглтона в Java:

```java
public class Singleton {

    // Единственный экземпляр класса (ленивая инициализация)
    private static Singleton instance;

    // Приватный конструктор, чтобы предотвратить создание объекта извне
    private Singleton() {
        System.out.println("Singleton instance created");
    }

    // Метод для получения единственного экземпляра класса
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();  // Экземпляр создается при первом вызове
        }
        return instance;
    }
}

public class Main {
    public static void main(String[] args) {
// Получение экземпляра синглтона
        Singleton s1 = Singleton.getInstance();
        Singleton s2 = Singleton.getInstance();

        // Проверка: оба объекта указывают на один и тот же экземпляр
        System.out.println(s1 == s2);  // true
    }
}
```

Как работает эта реализация:

- Приватный конструктор предотвращает создание объекта класса напрямую через оператор new.
- Статическое поле instance хранит единственный экземпляр класса.
- Метод getInstance() возвращает этот экземпляр. Если объект ещё не создан, он создаётся при первом вызове метода (
  ленивая инициализация).

Варианты реализации:

- Ленивая инициализация (как в примере выше): Экземпляр синглтона создаётся только при первом обращении к методу
  getInstance().
- Ранняя инициализация:
- Экземпляр создаётся сразу при загрузке класса, что гарантирует, что он будет доступен всегда, но даже если он не
  нужен, он всё равно будет создан.

```java
public class Singleton {

    // Экземпляр создается сразу при загрузке класса
    private static final Singleton instance = new Singleton();

    // Приватный конструктор
    private Singleton() {
    }

    // Метод для получения экземпляра
    public static Singleton getInstance() {
        return instance;
    }
}
```

- Потокобезопасная реализация (синхронизация): В многопоточной среде необходимо убедиться, что только один поток создаёт
  объект синглтона. Это достигается синхронизацией метода getInstance().

```java
-

public class Singleton {

    private static Singleton instance;

    private Singleton() {
    }

    // Синхронизированный метод для обеспечения потокобезопасности
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

- "Double-checked locking" (двойная проверка): Этот метод улучшает производительность за счёт минимизации использования
  синхронизации, проверяя наличие экземпляра перед и после синхронизации.

```java
public class Singleton {

    private static volatile Singleton instance;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (instance == null) {  // Первая проверка
            synchronized (Singleton.class) {
                if (instance == null) {  // Вторая проверка
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

Когда применять Синглтон:

- Когда нужен единственный экземпляр класса — например, для работы с базами данных, настройками приложения, логированием
  или пулом подключений.
- Когда нужен глобальный доступ — если класс предоставляет глобальный сервис (например, менеджер конфигураций), и
  необходимо, чтобы к нему был доступ из разных частей программы.
- Для управления ресурсами — например, при работе с сетевыми соединениями или файловыми потоками, когда необходимо,
  чтобы все использовали один и тот же экземпляр.

Преимущества:

- Контроль над созданием объекта — гарантируется, что существует только один экземпляр класса.
- Глобальная точка доступа — объекты синглтона могут использоваться из любой части программы.
- Экономия ресурсов — особенно полезно для ресурсов, которые должны быть созданы только один раз (например, подключение
  к базе данных).

Недостатки:

- Нарушение принципа единственной ответственности — синглтон отвечает и за управление своим единственным экземпляром, и
  за свои прямые обязанности.
- Тестирование — синглтоны могут усложнить модульное тестирование, так как они создают жёсткие зависимости между
  классами.
- Проблемы с многопоточностью — если синглтон реализован неправильно, это может привести к проблемам в многопоточных
  приложениях.

Важные моменты:

- Приватный конструктор — предотвращает создание экземпляров извне.
- Статическое поле — хранит единственный экземпляр класса.
- Потокобезопасность — в многопоточных приложениях следует обеспечивать корректное создание экземпляра в условиях
  параллельного доступа.

[К оглавлению](#OOP)

# 50. Объясните шаблон фабричный метод. Придумайте пример, не относящийся к технике.

Фабричный метод (Factory Method) — это порождающий шаблон проектирования, который предоставляет интерфейс для создания
объектов в суперклассе, но позволяет подклассам изменять тип создаваемого объекта. Этот шаблон позволяет делегировать
процесс создания объектов классам-наследникам, обеспечивая гибкость и возможность изменения логики создания объектов в
будущем.

Основные характеристики шаблона Фабричный метод:

- Делегирование создания объектов — суперкласс (или интерфейс) определяет метод для создания объекта, но фактическое
  создание объектов перекладывается на подклассы.
- Гибкость — шаблон позволяет подклассам выбирать или изменять тип создаваемых объектов. Это удобно, если нужно
  предоставить разные реализации без изменения кода суперкласса.
- Поддержка полиморфизма — суперклассы используют созданные объекты через общий интерфейс, не зная конкретный тип
  создаваемого объекта. Это позволяет легко добавлять новые типы объектов.

Структура:

- Продукт (Product) — общий интерфейс для создаваемых объектов.
- Конкретные продукты (ConcreteProduct) — классы, реализующие интерфейс продукта. Они представляют собой различные виды
  объектов, которые могут быть созданы фабричным методом.
- Создатель (Creator) — класс, содержащий метод фабрики, который возвращает объект типа продукта. Этот класс может быть
  абстрактным или содержать реализацию по умолчанию фабричного метода.
- Конкретные создатели (ConcreteCreator) — подклассы, которые реализуют фабричный метод и создают конкретные объекты
  продуктов.

Пример реализации шаблона Фабричный метод: Предположим, у нас есть программа, которая создаёт различные типы
уведомлений (Email, SMS, Push). Используем фабричный метод для делегирования создания разных типов уведомлений.

Шаги:

- Определим интерфейс продукта (уведомления).
- Реализуем конкретные классы для каждого типа уведомления.
- Определим фабричный метод в базовом классе, который будет создавать объекты уведомлений.
- Подклассы будут реализовывать этот метод для создания конкретных уведомлений.

```java
// Продукт - интерфейс для всех типов уведомлений
interface Notification {
    void notifyUser();
}

// Конкретные продукты - разные типы уведомлений
class EmailNotification implements Notification {
    @Override
    public void notifyUser() {
        System.out.println("Sending an email notification");
    }
}

class SMSNotification implements Notification {
    @Override
    public void notifyUser() {
        System.out.println("Sending an SMS notification");
    }
}

class PushNotification implements Notification {
    @Override
    public void notifyUser() {
        System.out.println("Sending a push notification");
    }
}

// Создатель - базовый класс с фабричным методом
abstract class NotificationCreator {
    // Фабричный метод
    public abstract Notification createNotification();

    // Метод для отправки уведомления, использующий созданное уведомление
    public void notifyUser() {
        Notification notification = createNotification();
        notification.notifyUser();
    }
}

// Конкретные создатели - классы, которые создают конкретные уведомления
class EmailNotificationCreator extends NotificationCreator {
    @Override
    public Notification createNotification() {
        return new EmailNotification();
    }
}

class SMSNotificationCreator extends NotificationCreator {
    @Override
    public Notification createNotification() {
        return new SMSNotification();
    }
}

class PushNotificationCreator extends NotificationCreator {
    @Override
    public Notification createNotification() {
        return new PushNotification();
    }
}

// Пример использования фабричного метода
public class Main {
    public static void main(String[] args) {
// Создание фабрик для разных типов уведомлений
        NotificationCreator emailCreator = new EmailNotificationCreator();
        NotificationCreator smsCreator = new SMSNotificationCreator();
        NotificationCreator pushCreator = new PushNotificationCreator();

        // Отправка уведомлений
        emailCreator.notifyUser();  // Sending an email notification
        smsCreator.notifyUser();    // Sending an SMS notification
        pushCreator.notifyUser();   // Sending a push notification
    }
}
```

Как работает этот пример:

- Продукты — классы EmailNotification, SMSNotification и PushNotification, которые реализуют интерфейс Notification и
  представляют собой разные типы уведомлений.
- Фабричный метод — метод createNotification() в классе NotificationCreator, который возвращает объект типа
  Notification.
- Конкретные создатели — классы EmailNotificationCreator, SMSNotificationCreator, и PushNotificationCreator, которые
  реализуют фабричный метод для создания конкретных типов уведомлений.
- Полиморфизм — клиент использует объекты типа NotificationCreator для создания и отправки уведомлений, не зная деталей
  о конкретных продуктах (уведомлениях).

Когда применять шаблон Фабричный метод:

- Когда класс не знает, какие конкретные подклассы ему предстоит создавать — например, если процесс создания объекта
  может изменяться в зависимости от контекста или условий выполнения программы.
- Когда класс делегирует создание объектов своим подклассам — если родительский класс хочет предоставить общий интерфейс
  для создания объектов, но фактическое создание оставить подклассам.
- Для расширяемости системы — фабричный метод позволяет легко добавлять новые типы продуктов, не меняя существующий код.

Преимущества:

- Гибкость — классы не зависят от конкретных типов создаваемых объектов, что упрощает расширение системы.
- Расширяемость — можно легко добавлять новые типы продуктов, просто создавая новые классы с реализацией фабричного
  метода.
- Поддержка полиморфизма — клиентский код работает с интерфейсом продукта, а не с конкретными реализациями, что делает
  код более гибким и модульным.

Недостатки:

- Усложнение кода — добавление фабричного метода требует создания дополнительных классов, что может усложнить код при
  простых сценариях.
- Требует наследования — фабричный метод обычно требует создания подклассов для каждой конкретной реализации, что может
  привести к избыточному числу классов.

Важные моменты:

- Фабричный метод делегирует создание объектов — это позволяет подклассам выбирать, какие объекты создавать.
- Расширяемость и гибкость — новые типы продуктов можно добавлять без изменения существующего кода.

[К оглавлению](#OOP)

# 51. Что такое enum? Когда можно его применять?

Enum - это класс-перечисление. Перечисление - это набор констант, связанных между собой по смыслу. Константы здесь - это
статические объекты, создающиеся в единственном экземпляре. Обычно перечисление используют для работы со значениями,
которые никогда не меняются. Например, дни недели, времена года, карточные масти, записи полей шахматной доски.
Перечисление можно использовать и для групп констант другого вида. Например, для перечисления в программе статусов
работы в автосервисе ("Принят на сервис", "В работе", "Ожидание запчастей", "Готов" и т.д.). Такие статусы никогда не
меняются и имеют логическую связь между собой. Enum создается как обычный класс в Java, только нужно выбрать
соответствующее значение enum. Перечисление может объявляться отдельно, а может быть объявлено в другом классе в виде
внутреннего класса. Если enum вложен в другой класс, он может быть как public, так и private. Если же enum не является
внутренним классом, то он может иметь только модификатор public. Перечисление (enum) наследуется от `java.lang.Enum`,
поэтому он не может наследовать другие классы. Перечисление может реализовывать интерфейсы. Перечисление может содержать
поля, методы и конструкторы. Конструктор `enum` неявно имеет модификатор `private`, поэтому создать объект перечисления
мы
можем только внутри него самого. Каждый из экземпляров перечисления создаётся только при первом обращении к нему. Каждое
значение (константа) нашего перечисления - это объект анонимного класса. Отсюда следует, что перечисление - это список
неизменяемых готовых объектов, которыми можно пользоваться.

Когда применять enum:
- Для работы с фиксированными наборами значений: Например, дни недели, месяцы, состояния объектов, возможные режимы работы
приложения и т.д.
Пример:
```java
enum Status {
ACTIVE, INACTIVE, DELETED;
}
```

- Когда нужно сделать код более читаемым и безопасным: Перечисления помогают ограничить возможные значения переменной, что
снижает риск ошибок. Это делает код более понятным,
особенно в контексте, где допустимы только определённые значения.
- Для улучшения производительности и структуры кода: Перечисления позволяют заменять строки или числовые константы на
удобные именованные константы, что упрощает работу с
данными.
- Для создания типов, связанных с состоянием: Например, перечисления можно использовать для управления состояниями
объектов (состояние задачи, пользовательский статус
и т.д.).

[К оглавлению](#OOP)

# 52. Что такое record? Когда можно его применять?

Record дает возможность записать стандартную модель данных в виде одной строки, то есть с помощью record можно
избавиться от шаблонного кода, который приходится писать в каждой модели данных.
Поля, переданные в параметрах, являются private и final по умолчанию.
Код имеет канонический конструктор, параметры которого - это все поля данного класса.
Доступ к полям осуществляется через методы типа имя_поля(). Тот же геттер, только без слова get в имени метода.
Методов типа set класс record не имеет, так как все поля объявлены как final, поэтому record является неизменяемым.
Определены методы equals() и hashcode(), включающие все поля класса.
Определен шаблонный метод toString() для вывода полей класса на печать.
Если всё же нужно изменить поле, то потребуется создать новый объект record. Скопировать в него значения полей
которые не менялись. Указать новое значение в поле которое нужно изменить. Есть небольшая разница в каком виде
выводится объект на печать, потому что в record для вывода объекта на печать используется StringJoiner, а в обычном
классе мы используем стандартную реализацию toString(). Точно так же можно переопределять в record свои реализации
конструкторов и методов, если это необходимо. В record можно добавлять только статические переменные (как константы,
так и обычные статические переменные). В record можно добавлять свои методы, как нестатические, так и статические.
Record является final, поэтому наследование этого класса невозможно. Сам record наследовать другие классы не может,
так он унаследован от `java.lang.Record`, но record может реализовывать интерфейсы. Record удобно применять,
когда
у модели могут добавляться или удаляться поля. Достаточно просто вписать новое поле в запись record и в класс
автоматически будут внесены изменения. В случае же с обычным классом нужно будет вручную вписывать поле в модель, менять
конструктор, методы equals(), hashcode(), toString(), добавлять или удалять геттеры.

Конструктор record:

- По умолчанию record имеет канонический конструктор - это конструктор, принимающий все поля класса в качестве
  параметров. Конструктор по умолчанию при объявлении явного канонического конструктора создан не будет.
- Если нам нужен конструктор с какой-то логикой помимо обычной инициализации полей, можно создать компактный
  конструктор. Данный конструктор называется компактным, так как в нем поля не инициализируются явным образом.
  Инициализация проходит неявно перед выполнением команд, находящихся внутри конструктора. Данная инициализация
  автоматически будет проходить в любом переопределенном конструкторе. Это гарантирует, что все поля будут
  инициализированы.
- Если в record уже объявлен компактный конструктор, то явно объявить еще и канонический конструктор в этом классе
  невозможно, так как при объявлении компактного конструктора автоматически создается конструктор по умолчанию, чтобы
  провести инициализацию всех полей перед выполнением команд компактного конструктора, поэтому нельзя еще раз
  объявить в классе такой же конструктор с теми же параметрами.

[К оглавлению](#OOP)

# 53. Зачем нужны StringBuilder, StringBuffer, StringJoiner? Что они делают?

String - это неизменяемый класс. После создания объект этого класса изменить нельзя. Строка - это неизменяемая
последовательность символов. При любых операциях изменения строки типа String будет создан новый объект String с
результирующим содержимым. Конкатенация(объединение строк) при помощи оператора `+` является плохим решением с точки
зрения производительности программы, т.к. каждые объекты строк будут создаваться отдельно и храниться в памяти. Для
решения проблемы разработали классы StringBuilder, StringJoiner, StringBuffer.

StringBuilder - это класс, являющийся
изменяемой последовательностью символов. Он дает возможность создать объект класса StringBuilder, и добавлять в него
другие строки без создания новых объектов. StringBuilder спроектирован на основе динамического массива(когда
заканчивается место для записи в существующем массиве символов создается новый массив в 2 раза большей длинны и в него
копируется все содержимое старого массива. Теперь мы не создаем новый объект при каждом проходе в цикле, а просто
добавляем новую строку к уже имеющейся). Благодаря этой системе значительно уменьшается количество операций по созданию
новых объектов, такая программа работает быстрее.

Когда использовать StringBuilder:
- Когда нужно многократно изменять строку: Если требуется многократное добавление, удаление или изменение частей строки, StringBuilder значительно быстрее и
эффективнее, чем String.
Пример использования в цикле:
```java
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 10; i++) {
        sb.append(i).append(" ");
}
        System.out.println(sb.toString());  // 0 1 2 3 4 5 6 7 8 9
```
- Для улучшения производительности: В ситуациях, когда строки часто изменяются (например, в циклах), StringBuilder позволяет избежать создания множества
временных объектов строк, что улучшает производительность программы.
- Когда важна работа с изменяемыми строками: Если вам нужно изменять содержимое строки, не создавая новых объектов, StringBuilder — идеальный выбор.

StringJoiner - класс для составления строк. StringJoiner базируется на StringBuilder и имеет удобную
возможность соединять строки через разделитель, а также добавлять префикс и/или суффикс к результирующей строке.
StringJoiner и StringBuilder имеют переопределенные методы toString(). Классы StringBuilder и StringJoiner не
синхронизированы.

Когда использовать StringJoiner:
- Когда нужно собрать строки с разделителем: Если у вас есть коллекция строк, и вам нужно их объединить с конкретным разделителем (например, запятой, пробелом или другим символом), StringJoiner упрощает этот процесс. Это лучше, чем вручную добавлять разделители, что может привести к ошибкам, особенно при работе с пустыми коллекциями.
```java
StringJoiner sj = new StringJoiner(", ");
sj.add("Tom");
sj.add("Jerry");
sj.add("Spike");
System.out.println(sj.toString());  // Tom, Jerry, Spike
```
- Когда необходимо добавить префикс и суффикс к итоговой строке: StringJoiner позволяет легко добавлять префиксы и суффиксы, что упрощает форматирование строк. Например, если нужно объединить элементы списка и обернуть их в квадратные скобки.
```java
StringJoiner sj = new StringJoiner(", ", "[", "]");
sj.add("Java");
sj.add("Python");
System.out.println(sj.toString());  // [Java, Python]
```
- Когда нужно обработать пустые коллекции: StringJoiner может быть настроен для обработки пустых значений с помощью метода setEmptyValue(). Это полезно, когда нужно указать особое значение для пустых наборов данных.
```java
StringJoiner sj = new StringJoiner(", ");
sj.setEmptyValue("No data available");
System.out.println(sj.toString());  // No data available
```
- Когда нужно объединить два объекта StringJoiner: Если есть два объекта StringJoiner, их можно объединить с помощью метода merge(), что облегчает сбор строк из нескольких источников.
```java
StringJoiner sj1 = new StringJoiner(", ").add("Item1").add("Item2");
StringJoiner sj2 = new StringJoiner(", ").add("Item3").add("Item4");
sj1.merge(sj2);
System.out.println(sj1.toString());  // Item1, Item2, Item3, Item4
```

StringBuffer - это аналог StringBuilder, только с синхронизированными методами для работы в многопоточном окружении.

Когда использовать StringBuffer:
- В многопоточных приложениях:Если ваша программа использует несколько потоков, которые могут одновременно изменять одну и ту же строку, то StringBuffer — правильный выбор, так как он обеспечивает безопасность при доступе к данным.

Пример: если несколько потоков одновременно собирают и изменяют строки в логах или буферах, лучше использовать StringBuffer для обеспечения целостности данных

Еще способы: Когда нам нужно объединить 2 и более строки с каким-либо разделителем, например, пробелом, то можно
использовать метод join() класса String.

String.concat() - удобно пользоваться, если у нас уже есть готовые строки, которые мы просто хотим объединить и получит
результат. Метод
concat() класса String возвращает объект String. Метод concat() можно объединять в цепочку, в результате работы которой
будет возвращена новая строка без накладных расходов в виде создания промежуточных строк.

[К оглавлению](#OOP)

# 54. Чем отличаются StringBuffer и StringBuilder?

StringBuilder и StringJoiner - не синхронизированы. Они будут некорректно работать в многопоточной среде. StringBuffer -
аналог StringBuilder, только с синхронизированными методами для работы в многопоточной среде.

[К оглавлению](#OOP)

# 55. Каким образом производится экранирование символов и зачем это нужно?

Экранирование символов производится с помощью управляющих последовательностей.
В Java экранирование символов применяется для того, чтобы использовать в строках символы, имеющие специальное
значение, или символы, которые сложно вставить напрямую. Экранирование осуществляется с помощью обратного слэша. Это
позволяет интерпретатору Java распознавать специальные символы и выполнять их как команды или отображать их в строках.

[К оглавлению](#OOP)

# 56. Что такое управляющие последовательности?

Комбинация в виде обратного слэша и экранируемого им символа называется управляющей последовательностью. Все управляющие
последовательности подсвечиваются в IDEA синим цветом. Это означает, что эти
символы расцениваются как единый символ. В Java существует 8 видов управляющих последовательностей:

- \\' - Добавляет одинарную кавычку. Аналогично выводу двойной кавычки, выводит одиночную кавычку. Имеет смысл при
  выводе символа одинарной кавычки в одинарных кавычках (аналогично двойной кавычке среди двойных).
- \\" - Добавляет двойную кавычку
- \\ - Добавляет обратный слэш
- \r - Возврат каретки в начало строки. Возвращает каретку в начало строки, "обнуляя" её. Если в строке были данные, они
  пропадут.
- \n - Перевод каретки на новую строку.
- \f - Прогон страницы. Переводит документ на новую страницу. Неиспользуемый спецсимвол.
- \b - Возврат каретки на одну позицию назад. Работает как BackSpace - стирает один символ позади текущего положения
  каретки.
- \uXXXX - Unicode-символ

- [К оглавлению](#OOP)

# 57. Зачем нужно форматирование данных? Метод format()

Форматирование данных — это процесс преобразования данных в более читабельный или удобный формат для представления, вывода или дальнейшей обработки. В Java форматирование данных необходимо для структурированного вывода текста, чисел, дат и других типов данных в требуемом виде. Это помогает улучшить читабельность, точность, а также представление данных для пользователя.

За создание форматированного текстового вывода отвечает класс `java.util.Formatter`. Метод format() этого класса
позволяет
выводить различные данные - строки, числа, даты, время в желаемом виде, т.е. преобразует данные в тот формат, который
нам нужен.

Метод format() класса String внутри он создает объект класса Formatter, вызывает у него метод format() с заданными нами
аргументами, и после возвращает строковое представление объекта Formatter. Метод format() класса Formatter получает
данные и преобразует их в определенный строковый формат. Отформатированные данные возвращаются в виде объекта типа
Formatter, который выводится в строковом представлении в методе format() класса String. Методы format() специально
определены в классе String и еще, например, в классах PrintStream и PrintWriter, т.е. в классах, которые работают с
выводом строк, чтобы не нужно было отдельно работать с классом Formatter - это удобно и получается меньше кода. А в
классах PrintStream и PrintWriter определён еще и метод printf(), который результат форматирования сразу выводит в
консоль аналогично методам print() или println().

Различия методов format() и printf():
Метод format() выполняет форматирование и возвращает новую строку. Её можно сохранить и использовать в дальнейшем. Метод
printf() выполняет форматирование и выводит данные в консоль без сохранения.

[К оглавлению](#OOP)

# 58. Что такое varargs? В каких случаях стоит его применять?

Varargs (Variable Arguments) — это возможность в Java передавать переменное количество аргументов одного и того же типа
в метод. Это удобно, когда вы не знаете заранее, сколько аргументов нужно передать, или хотите передавать произвольное
количество аргументов в метод. С помощью varargs можно избежать создания перегруженных методов для разного количества
параметров. Нужно помнить что использование varargs может привести к риску столкнуться с
неоднозначностью и вопросом понимания какой из перегруженных методов вызывается, а так же к снижению производительности
из-за дополнительных затрат на создание массива аргументов. Поэтому их стоит использовать с осторожностью и только там,
где это необходимо.

[К оглавлению](#OOP)

# 59. В каких случаях может возникнуть неоднозначность при работе с varargs?

Неоднозначность при работе с Varargs в Java возникает, когда сигнатура метода содержит переменное количество
аргументов (varargs), и есть несколько перегруженных версий этого метода с различным числом аргументов. В данном случае,
компилятор не может определить, какую версию метода вызвать, так как обе версии принимают переменное число аргументов, а
сигнатуры методов идентичны. Чтобы устранить эту неоднозначность, можно использовать явное приведение типов для
аргументов.

Так же если я перегружаю метод с разными типами. Неоднозначность проявится, когда попробую выполнить метод не указывая в
нем параметров. Не имея параметров, компилятор не сможет понять, какой из вариантов метода ему выбрать, т.к. оба будут
подходить. Такую неоднозначность можно разрешить путем отказа от перегрузки и объявления такого же метода, но с другим
именем. В целом появление неоднозначности может говорить о неидеальном решении поставленной задачи.

[К оглавлению](#OOP)

# 60. Что такое форматированный вывод? Какие механизмы позволяют осуществить форматированный вывод?

Форматированный вывод — это способ вывода данных, при котором их представление на экране или в файле управляется с
помощью специальных правил форматирования. Это позволяет отображать данные в удобной для чтения и структурированной
форме.

Основные характеристики форматированного вывода:
-Использование спецификаторов — для форматирования данных используются специальные символы и спецификаторы (например, %d,
%s, %f), которые определяют, как именно должны быть выведены числа, строки, даты и другие данные.
- Точность — можно задать количество знаков после запятой для чисел с плавающей точкой, минимальную ширину полей,
выравнивание текста и чисел.
- Гибкость — позволяет выводить разные типы данных в одном и том же формате с разным уровнем детализации и структуры.
- Применение в методах — в Java форматированный вывод осуществляется через методы System.out.printf(), String.format(), и
другие, которые принимают строку формата и аргументы для подстановки.

Пример форматированного вывода:
```java
System.out.printf("Name: %s, Age: %d, Balance: %.2f", "Alice", 30, 1234.567);
Вывод:

Name: Alice, Age: 30, Balance: 1234.57
```

В Java есть несколько механизмов для форматированного вывода, которые позволяют управлять представлением данных, используя специальные спецификаторы формата. Эти механизмы дают возможность выводить строки, числа, даты и другие типы данных в заданной структуре.

Основные механизмы форматированного вывода в Java:
- Метод printf(): Используется для вывода форматированной строки в консоль. Принимает строку формата и аргументы, которые подставляются в эту строку согласно спецификаторам.
```java
Формат:
System.out.printf(String format, Object... args);
Пример:
System.out.printf("Name: %s, Age: %d, Balance: %.2f%n", "Alice", 30, 1234.567);
Вывод:
Name: Alice, Age: 30, Balance: 1234.57
```
- Метод format(): Работает аналогично методу printf(), но возвращает строку, а не выводит её напрямую в консоль. Применяется для создания строк с заданным форматом, которые можно использовать для дальнейшей обработки.
```java
Формат:
String.format(String format, Object... args);
```
```java
String result = String.format("Hello, %s! You have %d new messages.", "Bob", 5);
System.out.println(result);
```
- Класс Formatter: Это более универсальный инструмент для форматированного вывода. Класс Formatter может выводить данные в разные потоки (например, в файл, строку или консоль).
```java
Formatter formatter = new Formatter();
formatter.format("Formatted number: %d", 123);
System.out.println(formatter);
```
Метод StringBuilder.append() с форматом: Для работы со строками можно использовать StringBuilder с методом append() и форматированием через format().
```java
StringBuilder sb = new StringBuilder();
sb.append(String.format("Total: %.2f", 123.456));
System.out.println(sb.toString());
```
- Метод MessageFormat: Используется для интернационализации и работы с форматированием текста, в основном для локализованных строк.
Пример:
```java
import java.text.MessageFormat;
String message = MessageFormat.format("User {0} has {1} messages.", "John", 5);
System.out.println(message);
```
Спецификаторы для форматирования:
- %d — для целых чисел (десятичные числа).
- %f — для чисел с плавающей точкой.
- %s — для строк.
- %x — для шестнадцатеричных чисел.
- %t — для дат и времени.

Особенности форматирования:
- Указание точности: Для чисел с плавающей запятой можно указать количество знаков после запятой.
```java
System.out.printf("Balance: %.2f%n", 1234.567);  // Balance: 1234.57
```
- Ширина поля и выравнивание: Можно задать минимальную ширину поля для вывода данных и указать, должны ли данные выравниваться вправо или влево.
```java
System.out.printf("|%10s|%n", "Java");   // |      Java|
System.out.printf("|%-10s|%n", "Java");  // |Java      |
```
[К оглавлению](#OOP)

# 61. Объясните отличие анонимного класса от локального класса?

Анонимные классы
- Определение: Анонимные классы создаются на месте, без имени, и используются для создания одноразовых объектов, которые
обычно реализуют интерфейс или расширяют класс.
- Синтаксис: Они объявляются в месте создания объекта, с использованием ключевого слова new. Например:
```java
Runnable runnable = new Runnable() {
    public void run() {
        System.out.println("Hello from an anonymous class!");
    }
};
```
- Область видимости: Анонимные классы могут обращаться к финальным (или эффективно финальным) переменным и параметрам
метода, в котором они созданы.
- Использование: Чаще всего используются для обработки событий или в качестве параметров для методов, где требуется быстро
создать объект.

Локальные классы
- Определение: Локальные классы имеют имя и могут быть определены внутри метода, конструктора или блока инициализации.
- Синтаксис: Они объявляются так же, как обычные классы, но внутри другого класса или метода. Например:

```java
class Outer {
    void outerMethod() {
        class LocalClass {
            void display() {
                System.out.println("Hello from a local class!");
            }
        }
        LocalClass local = new LocalClass();
        local.display();
    }
}
```
- Область видимости: Локальные классы также могут обращаться к финальным (или эффективно финальным) переменным и
параметрам метода, в котором они определены.
- Использование: Локальные классы подходят для более сложных случаев, когда требуется создать класс, который будет
использоваться только в пределах метода.

Краткое резюме
- Анонимные классы: безымянные, создаются на месте, используются для простых и одноразовых объектов.
- Локальные классы: имеют имя, объявляются внутри методов или блоков, и лучше подходят для более сложных задач, где может
потребоваться использование метода и дополнительная логика.

[К оглавлению](#OOP)

# 62. Расскажите про методы в классе?

Методы в классе — это функции, которые определяют поведение объектов класса. Они позволяют объектам выполнять действия,
манипулировать данными и взаимодействовать с другими объектами. Методы обеспечивают инкапсуляцию логики и предоставляют
интерфейс для работы с внутренними данными класса (полями).

Основные элементы метода:
- Возвращаемый тип — указывает, какой тип данных метод возвращает. Если метод не возвращает значения, используется
ключевое слово void.
- Имя метода — должно быть уникальным для класса и отражать выполняемое действие (например, calculateTotal(), getName()).
- Список параметров — указывает переменные, передаваемые методу при его вызове. Каждый параметр имеет тип данных и имя.
- Тело метода — блок кода, который выполняется при вызове метода.
- Модификаторы доступа — определяют, кто может вызывать метод (например, public, private, protected).
- Ключевое слово static — используется для создания статических методов, которые принадлежат классу, а не конкретному
объекту.

Виды методов:
- Экземплярные методы — это методы, которые принадлежат объектам класса. Для их вызова нужно создать экземпляр (объект)
класса. Например:
```java
Calculator calc = new Calculator();
calc.add(10, 5); // Вызов экземплярного метода
```
- Статические методы — это методы, которые принадлежат классу и могут быть вызваны без создания объекта. Они обозначаются
ключевым словом static. Например:
```java
Calculator.multiply(5, 2); // Вызов статического метода
```
- Геттеры и сеттеры — специальные методы, которые позволяют получить (геттер) или изменить (сеттер) значение поля класса.
Они обеспечивают инкапсуляцию, давая доступ к приватным полям через контролируемые методы.
```java
public int getValue() {
    return this.value;
}

public void setValue(int value) {
    this.value = value;
}
```
- Перегруженные методы — это методы с одним и тем же именем, но с разными параметрами (различный тип или количество
аргументов). Это позволяет вызывать метод с разными наборами данных.
```java
public void printInfo(String name) {
    System.out.println("Name: " + name);
}

public void printInfo(String name, int age) {
    System.out.println("Name: " + name + ", Age: " + age);
}
```
- Методы с переменным количеством аргументов (Varargs) — позволяют передавать в метод переменное количество аргументов:
```java
public void printNumbers(int... numbers) {
    for (int num : numbers) {
        System.out.println(num);
    }
}
// Вызов метода
printNumbers(1,2,3,4); // Выводит 1, 2, 3, 4
```
Возвращаемые значения:
- Методы могут возвращать значения (например, тип int, String, или любой другой тип данных).
- Если метод ничего не возвращает, используется ключевое слово void.
- Для завершения метода и возврата значения используется оператор return.

Модификаторы доступа для методов:
- public — метод доступен из любой части программы.
- private — метод доступен только внутри класса, в котором он определён.
- protected — доступен внутри пакета и у классов-наследников.
- Package-private (без модификатора) — доступен только внутри пакета.

[К оглавлению](#OOP)
