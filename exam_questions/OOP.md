## OOP

[1. Что такое ООП?](#1-Что-такое-ООП)

[2. Базовые концепции ООП?](#2-Базовые-концепции-ООП)

[3. Укажите из каких элементов состоит класс. Расскажите о каждом из них.](#3-Укажите-из-каких-элементов-состоит-класс-Расскажите-о-каждом-из-них)

[4. Что такое конструктор?](#4-Что-такое-конструктор)

[5. Можно ли наследовать конструктор?](#5-Можно-ли-наследовать-конструктор)

[6. Что такое перегрузка конструктора?](#6-Что-такое-перегрузка-конструктора)

[7. Что такое статический метод?](#7-Что-такое-статический-метод)

[8. Что такое не статический метод?](#8-Что-такое-не-статический-метод)

[9. Для чего используется ключевое слово this?](#9-Для-чего-используется-ключевое-слово-this)

[10. Какой класс является базовым родительским классом для всех классов?](#10-Какой-класс-является-базовым-родительским-классом-для-всех-классов)

[11. Что такое наследование? Приведите примеры из реальной жизни.](#11-Что-такое-наследование-Приведите-примеры-из-реальной-жизни)

[12. Опишите процесс создания нового объекта.](#12-Опишите-процесс-создания-нового-объекта)

[13. Как вызвать метод из родительского класса?](#13-Как-вызвать-метод-из-родительского-класса)

[14. Что такое переопределение метода?](#14-Что-такое-переопределение-метода)

[15. Можно ли переопределить статический метод?](#15-Можно-ли-переопределить-статический-метод)

[16. Что такое сокрытие метода?](#16-Что-такое-сокрытие-метода)

[17. Что такое виртуальная функция и используются ли они в Java?](#17-Что-такое-виртуальная-функция-и-используются-ли-они-в-Java)

[18. Что такое перегрузка метода?](#18-Что-такое-перегрузка-метода)

[19. Можно ли изменить тип возвращаемых данных при перегрузке метода?](#19-Можно-ли-изменить-тип-возвращаемых-данных-при-перегрузке-метода)

[20. Что такое множественное наследование? Как его можно реализовать в Java.](#20-Что-такое-множественное-наследование-Как-его-можно-реализовать-в-Java)

[21. Что такое полиморфизм? Приведите примеры из реальной жизни.](#21-Что-такое-полиморфизм-Приведите-примеры-из-реальной-жизни)

[22. Что такое инкапсуляция?](#22-Что-такое-инкапсуляция)

[23. Как реализована инкапсуляция в Java? ](#23-Как-реализована-инкапсуляция-в-Java)

[24. Можно ли применить модификаторы доступа к конструкторам?](#24-Можно-ли-применить-модификаторы-доступа-к-конструкторам)

[25. Что такое интерфейс?](#25-Что-такое-интерфейс)

[26. Перечислите элементы, которые может содержать интерфейс.](#26-Перечислите-элементы-которые-может-содержать-интерфейс)

[27. Можно ли создать объект интерфейса? Если да, то как?](#27-Можно-ли-создать-объект-интерфейса-Если-да-то-как)

[28. Может ли интерфейс содержать какие-либо методы с реализацией? Если да, то какие?](#28-Может-ли-интерфейс-содержать-какие-либо-методы-с-реализацией-Если-да-то-какие)

[29. Что такое абстракция?](#29-Что-такое-абстракция)

[30. Что такое абстрактный класс?](#30-Что-такое-абстрактный-класс)

[31. Сколько абстрактных методов должен и может содержать абстрактный класс?](#31-Сколько-абстрактных-методов-должен-и-может-содержать-абстрактный-класс)

[32. Может ли абстрактный класс содержать обычные методы?](#32-Может-ли-абстрактный-класс-содержать-обычные-методы)

[33. Сколько объектов абстрактного класса можно создать в программе?](#33-Сколько-объектов-абстрактного-класса-можно-создать-в-программе)

[34. Что нужно делать, если наследник абстрактного класса не переопределяет все абстрактные методы родителя?](#34-Что-нужно-делать-если-наследник-абстрактного-класса-не-переопределяет-все-абстрактные-методы-родителя)

[35. Чем отличается интерфейс от абстрактного класса?](#35-Чем-отличается-интерфейс-от-абстрактного-класса)

[36. Что такое вложенные классы? Зачем они нужны?](#36-Что-такое-вложенные-классы-Зачем-они-нужны)

[37. Какие типы вложенных классов существуют в Java?](#37-Какие-типы-вложенных-классов-существуют-в-Java)

[38. Что такое внутренний класс? Когда он применяется?](#38-Что-такое-внутренний-класс-Когда-он-применяется)

[39. Что такое статический вложенный класс? Когда он применяется?](#39-Что-такое-статический-вложенный-класс-Когда-он-применяется)

[40. Сколько объектов статического вложенного класса можно создать в программе?](#40-Сколько-объектов-статического-вложенного-класса-можно-создать-в-программе)

[41. Что такое локальный класс? Когда он применяется?](#41-Что-такое-локальный-класс-Когда-он-применяется)

[42. Что такое анонимный класс? Когда он применяется?](#42-Что-такое-анонимный-класс-Когда-он-применяется)

[43. Сколько объектов анонимного класса можно создать в программе?](#43-Сколько-объектов-анонимного-класса-можно-создать-в-программе)

[44. Что такое исключения? Какие типы исключительных ситуаций бывают?](#44-Что-такое-исключения-Какие-типы-исключительных-ситуаций-бывают)

[45. Назовите основные методы класса Object?](#45-Назовите-основные-методы-класса-Object)

[46. Что такое шаблоны проектирования?](#46-Что-такое-шаблоны-проектирования)

[47. Объясните шаблон декоратор. Придумайте пример, не относящийся к технике.](#47-Объясните-шаблон-декоратор-Придумайте-пример-не-относящийся-к-технике)

[48. Объясните шаблон стратегия. Придумайте пример, не относящийся к технике.](#48-Объясните-шаблон-стратегия-Придумайте-пример-не-относящийся-к-технике)

[49. Объясните шаблон синглтон. Придумайте пример, не относящийся к технике.](#49-Объясните-шаблон-синглтон-Придумайте-пример-не-относящийся-к-технике)

[50. Объясните шаблон фабричный метод. Придумайте пример, не относящийся к технике.](#50-Объясните-шаблон-фабричный-метод-Придумайте-пример-не-относящийся-к-технике)

[51. Что такое enum? Когда можно его применять?](#51-Что-такое-enum-Когда-можно-его-применять)

[52. Что такое record? Когда можно его применять?](#52-Что-такое-record-Когда-можно-его-применять)

[53. Зачем нужны StringBuilder, StringBuffer, StringJoiner? Что они делают?](#53-Зачем-нужны-StringBuilder-StringBuffer-StringJoiner-Что-они-делают)

[54. Чем отличаются StringBuffer и StringBuilder?](#54-Чем-отличаются-StringBuffer-и-StringBuilder)

[55. Каким образом производится экранирование символов и зачем это нужно?](#55-Каким-образом-производится-экранирование-символов-и-зачем-это-нужно)

[56. Что такое управляющие последовательности?](#56-Что-такое-управляющие-последовательности)

[57. Зачем нужно форматирование данных? Метод format()](#57-Зачем-нужно-форматирование-данных-Метод-format)

[58. Что такое varargs? В каких случаях стоит его применять?](#58-Что-такое-varargs-В-каких-случаях-стоит-его-применять)

[59. В каких случаях может возникнуть неоднозначность при работе с varargs?](#59-В-каких-случаях-может-возникнуть-неоднозначность-при-работе-с-varargs)

[60. Что такое форматированный вывод? Какие механизмы позволяют осуществить форматированный вывод?](#60-Что-такое-форматированный-вывод-Какие-механизмы-позволяют-осуществить-форматированный-вывод)

[61. Объясните отличие анонимного класса от локального класса?](#61-Объясните-отличие-анонимного-класса-от-локального-класса)

[62. Расскажите про методы в классе](#62-Расскажите-про-методы-в-классе)

# 1. Что такое ООП?

Объектно-ориентированное программирование (ООП) — методология программирования, основанная на представлении программы в
виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию
наследования.

Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием,
единственный способ изменить состояние объекта - послать ему сообщение, в ответ на которое, объект может изменить
собственное состояние.

Суть ООП - с помощью абстракций организовать данные компьютерной программы в виде объектов, а последовательность этапов
ее выполнения — в совокупность сообщений, передаваемых между этими объектами. Т.е. каждый из этих объектов описывает
свое особое поведение. Эти объекты можно считать конкретными сущностями, реагирующими на сообщения, предписывающие им
выполнить конкретное действие.

[К оглавлению](#OOP)

# 2. Базовые концепции ООП?

+ Инкапсуляция - сокрытие реализации.
+ Наследование - создание новой сущности на базе уже существующей.
+ Полиморфизм - способность объектов разных классов реагировать по-разному на один и тот же вызов метода.
+ Абстракция - набор общих характеристик.

[К оглавлению](#OOP)

# 3. Укажите из каких элементов состоит класс. Расскажите о каждом из них.

Класс - это своеобразный шаблон, по которому создаются объекты. Класс - логическая конструкция, объект - физическое
воплощение. Например: форма для запекания леденцов - класс, леденец, который мы изготовили из этой формы - объект. Класс
состоит из:

+ название класса (Имя класса)
+ конструкторы (специальные методы для создания объекта)
+ полей(переменных), то что объект про себя знает.
+ методов(функции для работы с полями), то что объект умеет делать.

Поля — это переменные, которые определяют состояние или свойства объекта, созданного на основе класса. Они хранят
данные, с которыми работают методы класса. Поля относятся к состоянию объектов и определяются внутри класса, но за его
пределами методов.
Поля бывают:

+ локальные переменные. Объявляются внутри методов. Уничтожаются по завершении работы метода, в котором объявлены.
+ переменные экземпляра. Доступны в пределах класса, из любого метода или иных блоков кода конкретного класса.
+ статические переменные. Такие переменные привязаны к классу, а не к объекту.

[К оглавлению](#OOP)

# 4. Что такое конструктор?

Конструктор — это специальный метод, у которого отсутствует возвращаемый тип и который имеет то же имя, что и класс, в
котором он используется. Конструктор вызывается при создании нового объекта класса и определяет действия необходимые для
его инициализации.

[К оглавлению](#OOP)

# 5. Можно ли наследовать конструктор?

Конструктор не является полем класса, поэтому его нельзя наследовать, но его можно вызвать с помощью ключевого
слова `super`. Если в наследнике не указан конструктор, то конструктор по умолчанию вызывает конструктор по умолчанию
своего родителя.

[К оглавлению](#OOP)

# 6. Что такое перегрузка конструктора?

**Перегрузка конструктора** - это создание конструкторов с другим набором аргументов (как по количеству, так и по
порядку следования). Перегрузка конструктора позволяет установить различные способы начальной инициализации объектов
класса. Если был создан конструктор, принимающий аргументы, а нам нужен конструктор по умолчанию (без аргументов), то
его нужно создать явно.

[К оглавлению](#OOP)

# 7. Что такое статический метод?

Статический метод в Java - это метод, который принадлежит классу, а не объекту конкретного класса. Он может быть вызван
без создания экземпляра класса и обычно используется для выполнения общих операций, которые не зависят от конкретного
объекта. Переменные, к которым обращается такой метод, тоже должны быть статическими.

```java
public class MathHelper {
    public static int sum(int a, int b) {
        return a + b;
    }

    public static void main(String[] args) {
        int result = MathHelper.sum(5, 3);
        System.out.println("Sum is: " + result); // Выведет: Sum is: 8
    }
}
```

[К оглавлению](#OOP)

# 8. Что такое не статический метод?

**Не статический метод** - это метод, для работы которого необходим объект. Т.е. он принадлежит объекту класса и
может быть вызван с помощью ссылки на данный объект. Не статические методы могут обращаться к полям класса, к
статическим так и не статическим.

[К оглавлению](#OOP)

# 9. Для чего используется ключевое слово this?

Ключевое слово `this` используется в Java для указания на текущий экземпляр объекта. Например, если мы хотим обратиться
к полю или методу текущего объекта внутри метода, мы можем использовать `this`.

`this` используется:

+ в теле любого метода для ссылки на текущий объект, чтобы обращаться к полям и методам данного класса.
  Например, когда у переменной экземпляра и переменной метода\конструктора одинаковые имена.

+ когда нужно вызвать один конструктор из другого (например, конструктор по умолчанию вызывается в параметризованном).
  Вызов `this` может находиться только в первой строке конструктора.

[К оглавлению](#OOP)

# 10. Какой класс является базовым родительским классом для всех классов?

`Object` - корневой класс в иерархии классов Java. Все не примитивные типы, включая массивы, наследуют прямо или
косвенно от него. Поэтому ссылочная переменная класса `Object` может ссылаться на объект любого другого класса.

[К оглавлению](#OOP)

# 11. Что такое наследование? Приведите примеры из реальной жизни.

Наследование – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или
полностью заимствующейся функциональностью.

[К оглавлению](#OOP)

# 12. Опишите процесс создания нового объекта.

Объявляем переменную класса с именем и типом объекта -> с помощью ключевого слова `new` резервируем память для объекта,
происходит вызов конструктора, который инициализирует новый объект.

[К оглавлению](#OOP)

# 13. Как вызвать метод из родительского класса?

Чтобы вызвать метод из родительского класса в классе-наследнике, в Java используется ключевое слово super. Оно позволяет
обращаться к методам и конструкторам родительского класса. Вызов метода через super обычно применяется, если нужно
вызвать метод родителя, который был переопределён в классе-наследнике, или просто использовать родительскую реализацию.

[К оглавлению](#OOP)

# 14. Что такое переопределение метода?

Переопределение метода - это механизм, который позволяет подклассу изменять реализацию метода, определенного в
супер классе. Это позволяет подклассу контролировать поведение метода, не изменяя его сигнатуру или имя. Имя метода,
порядок параметров, параметры, тип возвращаемого значения должны совпадать с базовым классом. IDEA позволяет с помощью
аннотации `@Override` проверить правильность кода на стадии его компиляции. Этим уменьшает возникновение
непредвиденных ошибок. Переопределять можно только нестатические методы. Если же попытаемся переопределить
статический метод, это будет называться "сокрытием метода из супер класса".

[К оглавлению](#OOP)

# 15. Можно ли переопределить статический метод?

Нет, нельзя переопределить статический метод в Java. Переопределение методов возможно только для нестатических методов.
Статические методы связаны с классом, а не с экземпляром класса, поэтому они не могут быть переопределены.

[К оглавлению](#OOP)

# 16. Что такое сокрытие метода?

Сокрытие метода - это когда дочерний класс определяет статический метод с такой же сигнатурой, что содержится в
родительском классе. Статические методы можно наследовать, но переопределить их нельзя. Обычный статический метод может
быть вызван из своего класса, аналогично скрытый статический метод также вызывается из своего класса. Если в дочернем
классе требуется изменить статический метод из родительского класса, это называется "Сокрытием статического метода" в
отличие от "переопределения" для нестатического метода `@overriding`. Во время компиляции статические методы связаны с
типом объявленной переменной, то есть какой класс объявлен в типе, статический метод того класса и будет вызван.

[К оглавлению](#OOP)

# 17. Что такое виртуальная функция и используются ли они в Java?

Виртуальная функция - это функция (метод), которая может быть переопределена наследником. То есть почти все
нестатические методы Java - это виртуальные функции (кроме private-методов, так как они не могут быть переопределены в
связи с правами видимости). Статические методы принадлежат классу и не могут быть переопределены, поэтому они не
являются виртуальными функциями.

[К оглавлению](#OOP)

# 18. Что такое перегрузка метода?

Это механизм позволяющий создавать методы с одинаковыми именами, но разными входными параметрами. При вызове
перегруженного метода компилятор автоматически определяет нужный вариант метода по его параметрам, которые указаны при
вызове.

[К оглавлению](#OOP)

# 19. Можно ли изменить тип возвращаемых данных при перегрузке метода?

Можно, если списки аргументов отличаются, иначе JVM не поймет какой метод ей нужно вызвать. Т.е. если меняем тип
возвращаемого значения, то мы также должны изменить список аргументов перегружаемого метода.

[К оглавлению](#OOP)

# 20. Что такое множественное наследование? Как его можно реализовать в Java.

Множественное наследование — это концепция в объектно-ориентированном программировании, при которой класс может
наследовать поведение и свойства более чем одного супер класса. В Java множественное наследование классов не
поддерживается напрямую. Это означает, что класс может иметь только одного непосредственного супер класса. Это
ограничение введено, чтобы избежать сложности и неоднозначности, связанные с "алмазной проблемой".
Множественное наследование в java можно реализовать, или через интерфейсы,
или используя агрегацию, или композицию - т.е. подключить нужные нам классы
через переменную или параметр.

Композиция - отношения "часть целое" между двумя объектами, когда один из них включает в себя другой. Особенность этого
отношения заключается в том, что компонент может существовать только как часть контейнера. Например: Университет состоит
из кафедр.

Агрегация - менее строгий вариант композиции, когда один объект имеет ссылку на другой объект. Здесь контейнер не
управляет жизненным циклом компонента. Компонент может существовать отдельно от контейнера. Например: кафедра состоит из
профессоров.

Ассоциация - когда объект использует другой объект, либо зависит от него. Возможна двухсторонняя ассоциация между
объектами. Например: профессор взаимодействует со студентами.

[К оглавлению](#OOP)

# 21. Что такое полиморфизм? Приведите примеры из реальной жизни.

Полиморфизм — это одна из ключевых концепций объектно-ориентированного программирования (ООП), которая позволяет
объектам разных типов реагировать на одни и те же вызовы методов по-разному.
Основная идея полиморфизма заключается в том, что один и тот же метод может вести себя по-разному в зависимости от
типа объекта, который вызывает этот метод. Это обеспечивает гибкость и расширяемость кода, так как мы можем работать с
объектами через их родительские типы, но при этом они будут выполнять специфичные для них действия.

Например: собачье обоняние - полиморфное свойство. Если собака учует запах кота - она залает и погонится за
ним. Если собака учует запах своего корма, у нее начнется слюноотделение и она побежит к своей миске. В обоих случаях
действует одно и тоже-чувство обоняния, отличие в том, что именно издает запах, т.е. в типе данных воздействующих на нос
собаки.

[К оглавлению](#OOP)

# 22. Что такое инкапсуляция?

Инкапсуляция — это один из принципов объектно-ориентированного программирования (ООП), который заключается в сокрытии
внутренних деталей объекта и предоставлении доступа к ним только через публичные методы (геттеры и сеттеры). Это
помогает защитить данные от некорректного использования и модификации извне.

Краткие характеристики инкапсуляции:
- Сокрытие данных — поля объекта обычно помечаются как private, чтобы их нельзя было изменить напрямую из других классов.
- Геттеры и сеттеры — публичные методы (get и set), которые обеспечивают контролируемый доступ к приватным полям объекта.
- Упрощение управления доступом — класс может управлять тем, какие данные доступны извне, и как они могут изменяться.
- Улучшение безопасности и устойчивости — скрытие деталей реализации предотвращает некорректное изменение состояния
объекта извне.

[К оглавлению](#OOP)

# 23. Как реализована инкапсуляция в Java?

В Java инкапсуляция реализуется с помощью модификаторов доступа (public, private, protected), и специальными методами
для их изменения(get и set) Поля объявляются с
модификатором private, а методы, осуществляющие доступ к этим полям, — public.

- public - доступен везде в программе.
- private - доступен внутри класса.
- default - доступен внутри пакета.
- protected - доступен внутри пакета и в наследниках.

[К оглавлению](#OOP)

# 24. Можно ли применить модификаторы доступа к конструкторам?

Да, модификаторы доступа можно применить к:

- классу.
- конструктору.
- методу.
- поля класса.

Модификаторы доступа нельзя применить только к локальным переменным.

[К оглавлению](#OOP)

# 25. Что такое интерфейс?

Это набор правил, которые должны быть реализованны в классе. Интерфейс содержит объявление методов, но не содержит
реализации этих методов. Интерфейс определяет, что должен делать класс, но не знает как. Интерфейс позволяет создавать
общий тип данных для различных объектов, т.е. использование интерфейса гарантирует наличие определенного метода у
объекта. При реализации интерфейса класс должен реализовывать все его методы, иначе он должен быть помечен,
как `abstract`

[К оглавлению](#OOP)

# 26. Перечислите элементы, которые может содержать интерфейс.

**Поля** - только `public static final`, т.е. константы.

**Методы:**

- Абстрактные методы - методы без реализации, которые реализуются в имплементирующих этот интерфейс классах.
- Статические методы - принадлежат только интерфейсу,  котором объявлены. Не наследуются. Необходимы, когда мы хотим сохранить какие-то данные на уровне интерфейса, а уже потом использовать в классе-реализации.
- Дефолтные методы - имеют реализацию, ключевое слово `default`, может быть унаследован как интерфесом-наследником, так и классом-реализацией. Упрощает написание кода, если какая-то реализация присуща всем или большинству наследников. Можно переопределять.
- Приватные методы - можно использовать в качестве вспомогательных для дефолтных.

**Вложенные/внутренние классы**

**Enum (перечисления)**

**НЕ содержит конструкторов, т.к. является абсолютной абстракцией.**

[К оглавлению](#OOP)

# 27. Можно ли создать объект интерфейса? Если да, то как?

Нет, нельзя напрямую создать объект интерфейса в Java, так как интерфейс — это абстрактный тип, и он не содержит полной
реализации методов. Однако, есть способы, которые позволяют работать с объектами интерфейса косвенно.

Как можно работать с объектами интерфейса:
- Реализация интерфейса в классе — класс, который реализует интерфейс, может быть использован для создания объекта, и этот
объект может быть ссылкой на интерфейс. Это основной способ работы с интерфейсами.
- Анонимные классы — можно создать объект интерфейса с помощью анонимного класса (это полезно, когда нужен одноразовый
объект с минимальной реализацией).
- Лямбда-выражения — начиная с Java 8, интерфейсы с одним методом (функциональные интерфейсы) могут быть реализованы с
помощью лямбда-выражений.

[К оглавлению](#OOP)

# 28. Может ли интерфейс содержать какие-либо методы с реализацией? Если да, то какие?

Начиная с Java 8 мы можем включать в интерфейсы методы с реализацией - статические или дефолтные, а начиная с Java 9 еще
приватные и статические.

[К оглавлению](#OOP)

# 29. Что такое абстракция?

Абстракция — это одна из ключевых концепций объектно-ориентированного программирования (ООП). Она позволяет нам скрыть
детали реализации и сосредоточиться на том, как объекты используются, а не на том, как они работают внутри.

[К оглавлению](#OOP)

# 30. Что такое абстрактный класс?

Класс, описывающий общее состояние и поведение будущих наследников. В нем определяется базовый функционал, 
который будет реализован в классах-наследниках.

[К оглавлению](#OOP)

# 31. Сколько абстрактных методов должен и может содержать абстрактный класс?

Не ограниченно, но если много абстрактных методов это, может быть, сигналом о том, что мой класс слишком сложен и его
следует разделить на несколько более простых классов.

[К оглавлению](#OOP)

# 32. Может ли абстрактный класс содержать обычные методы?

Да. Такие методы должны быть обязательно реализованы в подклассах, иначе класс так же становится абстрактным.

[К оглавлению](#OOP)

# 33. Сколько объектов абстрактного класса можно создать в программе?

Невозможно создать объекты абстрактного класса напрямую. Абстрактные классы предназначены для предоставления частичной
или общей функциональности для классов-наследников и служат в качестве шаблона. Таким образом, количество объектов
абстрактного класса, которые можно создать напрямую, — всегда 0.
- Абстрактный класс — это нечто вроде шаблона или конструкции, которая предоставляет частичную реализацию и общую
функциональность для своих подклассов.
- Объекты абстрактных классов напрямую создать нельзя, но можно создать объекты классов-наследников, которые реализуют все
абстрактные методы.

[К оглавлению](#OOP)

# 34. Что нужно делать, если наследник абстрактного класса не переопределяет все абстрактные методы родителя?

Если наследник этого не делает, то он так же становится абстрактным. Если класс должен обязательно иметь реализацию всех
абстрактных методов его следует пометить как `final`

[К оглавлению](#OOP)

# 35. Чем отличается интерфейс от абстрактного класса?

Основное отличие между интерфейсом и абстрактным классом в Java заключается в том, что интерфейс представляет собой
чистый контракт, определяющий методы и их сигнатуры, но не содержит реализации. В то время как абстрактный класс может
содержать как абстрактные методы, которые требуется переопределить в подклассах, так и конкретные методы с реализацией.

Другие отличия:

+ Класс может реализовывать несколько интерфейсов, в то время как наследовать только один абстрактный класс.
+ Абстрактный класс может иметь переменные экземпляра, конструкторы и блоки инициализации, в то время как интерфейс может
иметь только статические переменные и методы-константы (final).
+ Подкласс, реализующий интерфейс, обязан реализовать все его методы, в то время как для абстрактного класса можно
реализовать только неабстрактные методы.
+ Интерфейс может использоваться для достижения полиморфизма в Java, так как в нем могут быть объявлены методы без
реализации, которые могут быть переопределены в подклассах.
+ Интерфейс может быть удобен для реализации различных API и реализации множественного наследования, хотя Java не
поддерживает множественное наследование классов.

[К оглавлению](#OOP)

# 36. Что такое вложенные классы? Зачем они нужны?

**Вложенные классы в Java** - это классы, которые объявлены внутри другого класса. Они могут быть статическими или
нестатическими.

Вложенные классы могут быть полезны в следующих случаях:

1. Логическая связь: вложенные классы могут использоваться, когда один класс логически связан с другим классом и будет
   использоваться только внутри этого класса.
2. Удобство: вложенные классы могут упростить организацию кода, особенно если класс имеет относительно небольшой размер
   и используется только внутри другого класса.
3. Инкапсуляция: вложенные классы могут улучшить инкапсуляцию, ограничив доступ к вложенному классу только из внешнего
   класса.
4. Сокрытие реализации: вложенные классы могут использоваться для сокрытия реализации, что помогает скрыть детали
   реализации от внешнего мира.

Таким образом, вложенные классы в Java предоставляют удобный способ организации кода и повышения инкапсуляции и
модульности программы.

[К оглавлению](#OOP)

# 37. Какие типы вложенных классов существуют в Java?

- Статические вложенные классы (static nested classes) — это вложенные классы, которые могут существовать независимо от
экземпляра внешнего класса. Они ведут себя как обычные классы, но помещаются внутри другого класса.
- Внутренние классы (inner classes) — это вложенные классы, которые существуют внутри экземпляра внешнего класса и имеют
доступ ко всем его членам (включая приватные). Зависят от экземпляра внешнего класса и могут обращаться к его
нестатическим и приватным полям и методам
- Локальные классы (local classes) — это классы, которые объявляются внутри метода внешнего класса. Имеют доступ к
локальным переменным метода, если они помечены как final или эффективно final.
- Анонимные классы (anonymous classes) — это классы без имени, которые обычно используются для создания одноразовых
объектов с минимальной реализацией, и их создание происходит непосредственно при объявлении.

[К оглавлению](#OOP)

# 38. Что такое внутренний класс? Когда он применяется?

**Внутренний класс в Java** - это класс, объявленный внутри другого класса. Он имеет доступ ко всем членам внешнего
класса, включая приватные поля и методы. Внутренние классы применяются, когда нам нужно создать класс, который связан с
определенным объектом и не имеет смысла без него. Например, внутренние классы могут быть использованы для реализации
интерфейсов обработчиков событий, для организации логики обработки данных или для создания сложных структур данных.
Также внутренние классы могут быть использованы, если нужен только один объект данного класса и он не используется в
других частях программы.

Применяется для:

- логической группировки классов, использующихся в одном месте;
- повышения уровня инкапсуляции;
- читаемости и удобства поддержки кода.

Например: представим класс авто с полями марка и модель, а так же с двумя внутренними классами: тормоза и трансмиссия, в
которых определены методы ускорения и торможения. В данном случает трансмиссия и тормоза это внутренние системы авто. В
контексте авто они не могут существовать отдельно от него.

```java
class OuterClass {
    private String outerField = "I am an outer class field";

    // Вложенный класс
    class InnerClass {
        void display() {
            // Вложенный класс может обращаться к членам внешнего класса
            System.out.println("Accessing outer class field: " + outerField);
        }
    }

    void createInnerClass() {
        // Создание объекта вложенного класса
        InnerClass inner = new InnerClass();
        inner.display();
    }
}
```

[К оглавлению](#OOP)

# 39. Что такое статический вложенный класс? Когда он применяется?

Статический вложенный класс в Java - это класс, объявленный внутри другого класса и помеченный ключевым словом "static".
Он используется для группирования классов по смыслу и уменьшения загрязнения пространства имен, а также для повышения
читаемости кода.

Статический вложенный класс имеет доступ к статическим членам внешнего класса, но не имеет доступа к его нестатическим
членам. Он может быть создан без создания экземпляра внешнего класса.

Применение статического вложенного класса включает в себя реализацию вспомогательных классов, используемых только внутри
одного класса, упрощение управления кодом и улучшение модульности.

```java
class OuterClass {
    private static String outerStaticField = "I am a static outer class field";

    // Статический вложенный класс
    static class StaticNestedClass {
        void display() {
            // Статический вложенный класс может обращаться только к статическим членам внешнего класса
            System.out.println("Accessing outer static field: " + outerStaticField);
        }
    }

    static void createStaticNestedClass() {
        // Создание объекта статического вложенного класса
        StaticNestedClass nested = new StaticNestedClass();
        nested.display();
    }
}
```

[К оглавлению](#OOP)

# 40. Сколько объектов статического вложенного класса можно создать в программе?

Сколько угодно, это не статическая переменная, которая создается одна на все программу.

[К оглавлению](#OOP)

# 41. Что такое локальный класс? Когда он применяется?

Локальный класс в Java - это класс, объявленный внутри другого класса или метода. Он может быть использован только
внутри контекста, в котором он был объявлен. Локальные классы используются, когда необходимо создать специализированный
класс, который будет использоваться только в одном методе или части кода. Они обычно используются для улучшения
структуры кода, сокращения размера класса или для ухода от создания большого количества маленьких классов.

```java
class OuterClass {

    void createInnerClass() {
        final String localVar = "I am a local variable";

        // Локальный вложенный класс
        class LocalInnerClass {
            void display() {
                System.out.println("Accessing local variable: " + localVar);
            }
        }

        // Создание объекта локального вложенного класса
        LocalInnerClass localInner = new LocalInnerClass();
        localInner.display();
    }
}
```

[К оглавлению](#OOP)

# 42. Что такое анонимный класс? Когда он применяется?

Анонимный класс в Java - это специальный вид внутреннего класса, который не имеет имени. Он создается и используется в
месте объявления, без создания отдельного класса.

Анонимные классы обычно применяются, когда требуется создать класс одноразово, например, когда нужно реализовать
интерфейс или абстрактный метод внутри другого класса. Они удобны для реализации обратного вызова (callback) или
создания объектов без создания отдельного класса.

```java
interface Greetable {
    void greet();
}

public class Main {
    public static void main(String[] args) {
        // Создание анонимного вложенного класса, реализующего интерфейс Greetable
        Greetable greeting = new Greetable() {
            @Override
            public void greet() {
                System.out.println("Hello from anonymous inner class!");
            }
        };

        greeting.greet();
    }
}
```

[К оглавлению](#OOP)

# 43. Сколько объектов анонимного класса можно создать в программе?

Мы можем создать любое количество объектов анонимного класса, но следует помнить, что каждый анонимный класс создает
новый экземпляр внутреннего класса, что может привести к увеличению потребления памяти.

[К оглавлению](#OOP)

# 44. Что такое исключения? Какие типы исключительных ситуаций бывают?

Исключения (exceptions) в Java — это события, которые происходят во время выполнения программы и нарушают нормальный
поток её выполнения. Исключения представляют собой ошибки или непредвиденные ситуации, которые возникают в процессе
выполнения программы и требуют специальной обработки. Когда исключение возникает, оно прерывает нормальный ход программы
и передаёт управление обработчику исключений. Исключения делятся на несколько классов, но все они имеют общего предка -
класс `Throwable`,
потомками которого являются классы `Exception` и `Error`

`Error`  ошибки представляют собой серьезные проблемы которые не следует обрабатывать,
поскольку они связанны с проблемами уровня JVM. Например: закончилась память, доступная JVM(StackOverflow
error).

`Exceptions` исключения являются результатом проблем в программе - которые в принципе решаемы, предсказуемы, последствия
их возможно устранить внутри программы. Исключения делятся на проверяемые и не проверяемые.

- Проверяемые исключения. Проверяются во время компиляции программы и если такие исключения не обработать - программа не
  скомпилируется. Для обработки исключения используется блок `try-catch` и ключевое слово `throws` после сигнатуры
  метода. К таким исключениям относятся: готовые исключения подклассов IOException, SQLException, а так же все
  пользовательские исключения, которые наследуются от класса `Exception`.
- Не проверяемые исключения. Проверяются во время запуска программы, т.е. если их не обработать с помощью
  конструкции `try-catch`, то код скомпилируется без проблем. К непроверяемым исключениям относятся все наследники
  класса `RunTimeException`

[К оглавлению](#OOP)

# 45. Назовите основные методы класса Object?

public native int hashCode() — возвращает хеш-код объекта.

public boolean equals(Object obj) — сравнивает объекты.

public String toString() — возвращает строковое представление объекта.

public final native Class getClass() — возвращает в рантайме класс данного объекта.

protected native Object clone() throws CloneNotSupportedException — клонирование объекта

public final native void notify() — просыпается один поток, который ждет на "мониторе" данного объекта.

public final native void notifyAll() — просыпаются все потоки, которые ждут на "мониторе" данного объекта.

public final native void wait(long timeout) throws InterruptedException — поток переходит в режим ожидания в течение
указанного времени.

public final void wait() throws InterruptedException — приводит данный поток в ожидание, пока другой поток не вызовет
notify() или notifyAll() методы для этого объекта.

public final void wait(long timeout, int nanos) throws InterruptedException — приводит данный поток в ожидание, пока
другой поток не вызовет notify() или notifyAll() для этого метода, или пока не истечет указанный промежуток времени.

protected void finalize() throws Throwable — вызывается сборщиком мусора, когда garbage collector определил, что ссылок
на объект больше нет.

Модификатор native сигнализирует о том, что метод реализован в платформ-зависимом коде, часто на языке С.

[К оглавлению](#OOP)

# 46. Что такое шаблоны проектирования?

Шаблоны проектирования (design patterns) — это типовые решения часто встречающихся задач в разработке программного
обеспечения. Это готовые структуры или схемы, которые описывают, как организовать код для решения определённых проблем с
учётом гибкости, масштабируемости и поддерживаемости программы.

Основные характеристики шаблонов проектирования:
- Повторяемость — шаблоны проектирования представляют собой проверенные временем подходы, которые можно многократно
использовать в разных проектах и ситуациях.
- Оптимизация разработки — применение шаблонов помогает избежать распространённых ошибок и упрощает процесс разработки,
предоставляя готовые решения типичных задач.
- Повышение читаемости и поддержки — шаблоны проектирования стандартизируют способы решения задач, что делает код более
понятным для других разработчиков и упрощает его поддержку.
- Гибкость и расширяемость — шаблоны помогают создать код, который легко адаптируется к изменяющимся требованиям без
необходимости в серьёзных изменениях.

Классификация шаблонов проектирования:
- Порождающие шаблоны (Creational Patterns):
Отвечают за создание объектов, оптимизируя процесс их инстанцирования и управления. Эти шаблоны помогают избежать
создания объекта напрямую, предоставляя гибкие механизмы создания объектов.
Примеры: Singleton, Factory Method, Builder, Prototype, Abstract Factory.
- Структурные шаблоны (Structural Patterns):
Определяют, как объекты и классы могут быть связаны и организованы для формирования более крупных структур. Эти шаблоны
помогают организовать код и упростить его структуру.
Примеры: Adapter, Facade, Decorator, Composite, Bridge, Proxy.
- Поведенческие шаблоны (Behavioral Patterns):
Описывают взаимодействие между объектами и способ их координации. Эти шаблоны помогают управлять сложными
взаимодействиями между объектами, определяя способы передачи данных и команд.
Примеры: Observer, Strategy, Command, State, Chain of Responsibility, Mediator, Visitor.

Важные моменты:
- Шаблоны проектирования — это не конкретные классы или библиотеки, а скорее общие решения, которые могут быть реализованы
по-разному в зависимости от требований проекта.
- Повышение гибкости и поддерживаемости кода — использование шаблонов проектирования помогает структурировать код и
упрощает добавление новых функций.
- Универсальность и стандартизация — разработчики, использующие шаблоны проектирования, могут легко понимать и
адаптировать код, поскольку многие шаблоны стандартны и общеизвестны.

- [К оглавлению](#OOP)

# 47. Объясните шаблон декоратор. Придумайте пример, не относящийся к технике

Декоратор (Decorator) — это структурный шаблон проектирования, который позволяет добавлять новую функциональность
объектам динамически (во время выполнения) без изменения их структуры или создания подклассов. Шаблон предоставляет
гибкий механизм для расширения поведения объекта за счёт обёртывания его в другой объект (декоратор), который добавляет
или изменяет его функциональность.

Основные характеристики шаблона Декоратор:
Динамическое расширение функциональности — шаблон позволяет добавлять новое поведение объектам в процессе выполнения
программы, не изменяя их исходный код.

Использование композиции — вместо наследования декоратор использует композицию для добавления нового поведения. В этом
случае объект обёртывается другим объектом-декоратором, который добавляет свою функциональность, а затем делегирует
вызовы основному объекту.

Гибкость — можно оборачивать объект в несколько декораторов, добавляя несколько уровней поведения.

Как работает шаблон Декоратор:
Есть компонент (базовый интерфейс или класс), который определяет общий интерфейс для объекта.
Декоратор реализует тот же интерфейс и содержит ссылку на объект компонента. Все вызовы методов декоратора делегируются
обёрнутому объекту, и при необходимости добавляется дополнительное поведение.
Основной объект оборачивается в декоратор, чтобы добавить новые функции.
Структура:

- Компонент (Component) — общий интерфейс для основного объекта и его декораторов.
- Конкретный компонент (ConcreteComponent) — реализация компонента, которая будет декорироваться.
- Декоратор (Decorator) — класс, реализующий интерфейс компонента и содержащий ссылку на обёрнутый объект.
- Конкретный декоратор (ConcreteDecorator) — класс, расширяющий поведение объекта.

Пример реализации шаблона Декоратор:
Предположим, у нас есть базовый интерфейс Notifier для отправки уведомлений, и мы хотим добавить к нему возможность
отправки уведомлений через Email и SMS.

```java
// Компонент
interface Notifier {
    void send(String message);
}

// Конкретный компонент
class BasicNotifier implements Notifier {
    @Override
    public void send(String message) {
        System.out.println("Sending basic notification: " + message);
    }
}

// Декоратор
class NotifierDecorator implements Notifier {
    protected Notifier wrappedNotifier;

    public NotifierDecorator(Notifier notifier) {
        this.wrappedNotifier = notifier;
    }

    @Override
    public void send(String message) {
        wrappedNotifier.send(message);  // Делегируем вызов основному объекту
    }
}

// Конкретный декоратор (Email уведомление)
class EmailNotifier extends NotifierDecorator {
    public EmailNotifier(Notifier notifier) {
        super(notifier);
    }

    @Override
    public void send(String message) {
        super.send(message);
        System.out.println("Sending email notification: " + message);
    }
}

// Конкретный декоратор (SMS уведомление)
class SMSNotifier extends NotifierDecorator {
    public SMSNotifier(Notifier notifier) {
        super(notifier);
    }

    @Override
    public void send(String message) {
        super.send(message);
        System.out.println("Sending SMS notification: " + message);
    }
}

// Пример использования
public class Main {
    public static void main(String[] args) {
        // Базовое уведомление
        Notifier notifier = new BasicNotifier();

        // Добавляем функциональность отправки Email через декоратор
        Notifier emailNotifier = new EmailNotifier(notifier);

        // Добавляем функциональность отправки SMS через декоратор
        Notifier smsAndEmailNotifier = new SMSNotifier(emailNotifier);

        // Отправляем уведомление, используя оба декоратора
        smsAndEmailNotifier.send("Hello!");
        // Вывод:
        // Sending basic notification: Hello!
        // Sending email notification: Hello!
        // Sending SMS notification: Hello!
    }
}
```

Как работает этот пример:

1) У нас есть базовый класс BasicNotifier, который отправляет простые уведомления.

2) Сначала мы оборачиваем его в EmailNotifier, который добавляет возможность отправки email-уведомлений.

3) Затем мы оборачиваем его в SMSNotifier, который добавляет возможность отправки SMS-уведомлений.

4) В результате вызов метода send() сначала выполняет базовую функциональность, а затем добавляет дополнительные
   действия по отправке email и SMS.
   Когда применять шаблон Декоратор:
   Когда нужно динамически добавлять поведение — если требуется добавить новую функциональность объекту без изменения
   его исходного кода.

Когда использование наследования не подходит — наследование создаёт жёсткие связи между классами. Декоратор позволяет
более гибко изменять поведение объекта.

Для работы с библиотеками и классами, которые нельзя изменять — декоратор позволяет расширить функциональность классов,
не изменяя их исходный код.

Преимущества:
- Гибкость — поведение объектов можно изменять на лету, комбинируя различные декораторы.
- Композиция вместо наследования — это позволяет избежать создания множества подклассов и делает систему более гибкой.
- Упрощение кода — можно добавлять функциональность через декораторы, не изменяя существующий код.
- 
Недостатки:
- Сложность при многократном оборачивании — при большом количестве декораторов может стать сложно отслеживать порядок их
применения.
- Дополнительные объекты — каждый новый декоратор создаёт новый объект, что увеличивает использование памяти.

[К оглавлению](#OOP)

# 48. Объясните шаблон стратегия. Придумайте пример, не относящийся к технике.

Стратегия (Strategy) — это поведенческий шаблон проектирования, который определяет семейство алгоритмов, инкапсулирует
каждый из них и делает их взаимозаменяемыми. Шаблон позволяет динамически изменять поведение объекта на основе выбранной
стратегии (алгоритма) во время выполнения программы, не изменяя код самого объекта.

Основные характеристики шаблона Стратегия:
- Инкапсуляция алгоритмов — различные алгоритмы (или поведения) инкапсулируются в отдельных классах, которые реализуют
общий интерфейс. Это делает алгоритмы независимыми друг от друга и от клиента, который их использует.
- Динамическая замена — алгоритмы можно легко заменять во время выполнения программы, просто изменив объект стратегии, что
позволяет гибко адаптировать поведение объекта без изменения его кода.
- Снижение дублирования кода — шаблон помогает избавиться от сложных условных конструкций (например, if-else или switch) и
изолировать каждый алгоритм в своём классе.

Структура:
- Контекст (Context) — класс, который использует стратегию (алгоритм). Он содержит ссылку на объект стратегии и вызывает
его методы для выполнения конкретной задачи.
- Интерфейс стратегии (Strategy) — общий интерфейс для всех алгоритмов (стратегий), который определяет метод или методы,
которые каждая стратегия должна реализовать.
- Конкретные стратегии (ConcreteStrategy) — конкретные классы, которые реализуют различные алгоритмы, соответствующие
интерфейсу стратегии.

Пример реализации шаблона Стратегия:

Предположим, у нас есть система расчёта стоимости товаров с различными стратегиями скидок. Мы можем менять алгоритмы
расчёта скидок в зависимости от контекста (например, скидка для VIP-клиентов или сезонная скидка).
```java
// Интерфейс стратегии
interface DiscountStrategy {
double applyDiscount(double price);
}

// Конкретная стратегия - Сезонная скидка
class SeasonalDiscount implements DiscountStrategy {
@Override
public double applyDiscount(double price) {
return price * 0.9; // Скидка 10%
}
}

// Конкретная стратегия - Скидка для VIP-клиентов
class VIPDiscount implements DiscountStrategy {
@Override
public double applyDiscount(double price) {
return price * 0.8; // Скидка 20%
}
}

// Конкретная стратегия - Без скидки
class NoDiscount implements DiscountStrategy {
@Override
public double applyDiscount(double price) {
return price; // Нет скидки
}
}

// Контекст - класс, который использует стратегии
class PriceCalculator {
private DiscountStrategy discountStrategy;

    // Установка стратегии
    public void setDiscountStrategy(DiscountStrategy discountStrategy) {
        this.discountStrategy = discountStrategy;
    }

    // Расчёт цены с учётом выбранной стратегии скидки
    public double calculatePrice(double price) {
        return discountStrategy.applyDiscount(price);
    }

}

// Пример использования
public class Main {
public static void main(String[] args) {
PriceCalculator calculator = new PriceCalculator();

        // Применяем сезонную скидку
        calculator.setDiscountStrategy(new SeasonalDiscount());
        System.out.println("Price with seasonal discount: " + calculator.calculatePrice(100));

        // Применяем скидку для VIP-клиентов
        calculator.setDiscountStrategy(new VIPDiscount());
        System.out.println("Price with VIP discount: " + calculator.calculatePrice(100));

        // Применяем стратегию без скидки
        calculator.setDiscountStrategy(new NoDiscount());
        System.out.println("Price without discount: " + calculator.calculatePrice(100));
    }

}
```
Как это работает:
- Контекст — класс PriceCalculator, который использует объект стратегии для расчёта цены с учётом скидки.
- Стратегии — три конкретные стратегии: SeasonalDiscount, VIPDiscount и NoDiscount, каждая из которых реализует свою
логику расчёта скидки.
- Динамическая замена — объект PriceCalculator может динамически менять стратегию во время выполнения программы, вызывая
  метод setDiscountStrategy().

Когда применять шаблон Стратегия:

- Когда нужно выбирать поведение (алгоритм) во время выполнения программы: Шаблон "Стратегия" полезен, когда объект
  должен изменять своё поведение в зависимости от ситуации (например, различные
  способы сортировки данных, различные стратегии скидок).
- Когда нужно избежать сложных условных конструкций: Стратегия позволяет избавиться от громоздких if-else или switch
  конструкций, переместив каждый алгоритм в отдельный
  класс.
- Когда нужно сделать алгоритмы взаимозаменяемыми: Стратегии можно легко заменять и комбинировать без изменения
  основного кода программы.

Преимущества:

- Гибкость — можно легко добавлять новые алгоритмы, не изменяя существующий код.
- Чистота кода — каждый алгоритм изолирован в своём классе, что делает код более поддерживаемым и чистым.
- Легко расширяем — добавление новых стратегий не требует изменения существующих классов, что упрощает развитие системы.

Недостатки:

- Усложнение системы — создание множества классов для каждой стратегии может усложнить код и сделать его более
  громоздким.
- Необходимость использования интерфейсов — для реализации каждой стратегии требуется создание интерфейсов или
  абстрактных
  классов.

Важные моменты:

- Контекст и стратегия — контекст хранит ссылку на стратегию и делегирует выполнение задач этому объекту, не зная
  деталей
  его реализации.
- Гибкость замены алгоритмов — алгоритмы можно изменять во время выполнения программы.
- Меньше условных операторов — шаблон помогает избежать множества условных выражений, улучшая читаемость кода.

[К оглавлению](#OOP)

# 49. Объясните шаблон синглтон. Придумайте пример, не относящийся к технике.

Синглтон (Singleton) — это порождающий шаблон проектирования, который гарантирует, что у класса будет только один
экземпляр, и предоставляет глобальную точку доступа к этому экземпляру. Шаблон часто используется, когда необходимо,
чтобы какой-либо ресурс, объект или сервис был единственным в системе.

Основные характеристики шаблона Синглтон:

- Единичность — шаблон гарантирует, что для данного класса будет создан только один объект на протяжении всего времени
  выполнения программы.
- Глобальная точка доступа — шаблон предоставляет глобальный доступ к объекту синглтона, позволяя получать его экземпляр
  в любом месте программы.
- Контроль над созданием объекта — создание экземпляра синглтона строго контролируется самим классом. Обычно объект
  создаётся при первом запросе и больше не создаётся повторно.

Структура:

- Приватный конструктор — предотвращает создание объектов снаружи класса.
- Статическое поле — для хранения единственного экземпляра класса.
- Статический метод — для получения экземпляра класса (часто называется getInstance()).

Пример классического синглтона в Java:

```java
public class Singleton {

    // Единственный экземпляр класса (ленивая инициализация)
    private static Singleton instance;

    // Приватный конструктор, чтобы предотвратить создание объекта извне
    private Singleton() {
        System.out.println("Singleton instance created");
    }

    // Метод для получения единственного экземпляра класса
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();  // Экземпляр создается при первом вызове
        }
        return instance;
    }
}

public class Main {
    public static void main(String[] args) {
// Получение экземпляра синглтона
        Singleton s1 = Singleton.getInstance();
        Singleton s2 = Singleton.getInstance();

        // Проверка: оба объекта указывают на один и тот же экземпляр
        System.out.println(s1 == s2);  // true
    }
}
```

Как работает эта реализация:

- Приватный конструктор предотвращает создание объекта класса напрямую через оператор new.
- Статическое поле instance хранит единственный экземпляр класса.
- Метод getInstance() возвращает этот экземпляр. Если объект ещё не создан, он создаётся при первом вызове метода (
  ленивая инициализация).

Варианты реализации:

- Ленивая инициализация (как в примере выше): Экземпляр синглтона создаётся только при первом обращении к методу
  getInstance().
- Ранняя инициализация:
- Экземпляр создаётся сразу при загрузке класса, что гарантирует, что он будет доступен всегда, но даже если он не
  нужен, он всё равно будет создан.

```java
public class Singleton {

    // Экземпляр создается сразу при загрузке класса
    private static final Singleton instance = new Singleton();

    // Приватный конструктор
    private Singleton() {
    }

    // Метод для получения экземпляра
    public static Singleton getInstance() {
        return instance;
    }
}
```

- Потокобезопасная реализация (синхронизация): В многопоточной среде необходимо убедиться, что только один поток создаёт
  объект синглтона. Это достигается синхронизацией метода getInstance().

```java
-

public class Singleton {

    private static Singleton instance;

    private Singleton() {
    }

    // Синхронизированный метод для обеспечения потокобезопасности
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

- "Double-checked locking" (двойная проверка): Этот метод улучшает производительность за счёт минимизации использования
  синхронизации, проверяя наличие экземпляра перед и после синхронизации.

```java
public class Singleton {

    private static volatile Singleton instance;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (instance == null) {  // Первая проверка
            synchronized (Singleton.class) {
                if (instance == null) {  // Вторая проверка
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

Когда применять Синглтон:

- Когда нужен единственный экземпляр класса — например, для работы с базами данных, настройками приложения, логированием
  или пулом подключений.
- Когда нужен глобальный доступ — если класс предоставляет глобальный сервис (например, менеджер конфигураций), и
  необходимо, чтобы к нему был доступ из разных частей программы.
- Для управления ресурсами — например, при работе с сетевыми соединениями или файловыми потоками, когда необходимо,
  чтобы все использовали один и тот же экземпляр.

Преимущества:

- Контроль над созданием объекта — гарантируется, что существует только один экземпляр класса.
- Глобальная точка доступа — объекты синглтона могут использоваться из любой части программы.
- Экономия ресурсов — особенно полезно для ресурсов, которые должны быть созданы только один раз (например, подключение
  к базе данных).

Недостатки:

- Нарушение принципа единственной ответственности — синглтон отвечает и за управление своим единственным экземпляром, и
  за свои прямые обязанности.
- Тестирование — синглтоны могут усложнить модульное тестирование, так как они создают жёсткие зависимости между
  классами.
- Проблемы с многопоточностью — если синглтон реализован неправильно, это может привести к проблемам в многопоточных
  приложениях.

Важные моменты:

- Приватный конструктор — предотвращает создание экземпляров извне.
- Статическое поле — хранит единственный экземпляр класса.
- Потокобезопасность — в многопоточных приложениях следует обеспечивать корректное создание экземпляра в условиях
  параллельного доступа.

[К оглавлению](#OOP)

# 50. Объясните шаблон фабричный метод. Придумайте пример, не относящийся к технике.

Фабричный метод (Factory Method) — это порождающий шаблон проектирования, который предоставляет интерфейс для создания
объектов в суперклассе, но позволяет подклассам изменять тип создаваемого объекта. Этот шаблон позволяет делегировать
процесс создания объектов классам-наследникам, обеспечивая гибкость и возможность изменения логики создания объектов в
будущем.

Основные характеристики шаблона Фабричный метод:

- Делегирование создания объектов — суперкласс (или интерфейс) определяет метод для создания объекта, но фактическое
  создание объектов перекладывается на подклассы.
- Гибкость — шаблон позволяет подклассам выбирать или изменять тип создаваемых объектов. Это удобно, если нужно
  предоставить разные реализации без изменения кода суперкласса.
- Поддержка полиморфизма — суперклассы используют созданные объекты через общий интерфейс, не зная конкретный тип
  создаваемого объекта. Это позволяет легко добавлять новые типы объектов.

Структура:

- Продукт (Product) — общий интерфейс для создаваемых объектов.
- Конкретные продукты (ConcreteProduct) — классы, реализующие интерфейс продукта. Они представляют собой различные виды
  объектов, которые могут быть созданы фабричным методом.
- Создатель (Creator) — класс, содержащий метод фабрики, который возвращает объект типа продукта. Этот класс может быть
  абстрактным или содержать реализацию по умолчанию фабричного метода.
- Конкретные создатели (ConcreteCreator) — подклассы, которые реализуют фабричный метод и создают конкретные объекты
  продуктов.

Пример реализации шаблона Фабричный метод: Предположим, у нас есть программа, которая создаёт различные типы
уведомлений (Email, SMS, Push). Используем фабричный метод для делегирования создания разных типов уведомлений.

Шаги:

- Определим интерфейс продукта (уведомления).
- Реализуем конкретные классы для каждого типа уведомления.
- Определим фабричный метод в базовом классе, который будет создавать объекты уведомлений.
- Подклассы будут реализовывать этот метод для создания конкретных уведомлений.

```java
// Продукт - интерфейс для всех типов уведомлений
interface Notification {
    void notifyUser();
}

// Конкретные продукты - разные типы уведомлений
class EmailNotification implements Notification {
    @Override
    public void notifyUser() {
        System.out.println("Sending an email notification");
    }
}

class SMSNotification implements Notification {
    @Override
    public void notifyUser() {
        System.out.println("Sending an SMS notification");
    }
}

class PushNotification implements Notification {
    @Override
    public void notifyUser() {
        System.out.println("Sending a push notification");
    }
}

// Создатель - базовый класс с фабричным методом
abstract class NotificationCreator {
    // Фабричный метод
    public abstract Notification createNotification();

    // Метод для отправки уведомления, использующий созданное уведомление
    public void notifyUser() {
        Notification notification = createNotification();
        notification.notifyUser();
    }
}

// Конкретные создатели - классы, которые создают конкретные уведомления
class EmailNotificationCreator extends NotificationCreator {
    @Override
    public Notification createNotification() {
        return new EmailNotification();
    }
}

class SMSNotificationCreator extends NotificationCreator {
    @Override
    public Notification createNotification() {
        return new SMSNotification();
    }
}

class PushNotificationCreator extends NotificationCreator {
    @Override
    public Notification createNotification() {
        return new PushNotification();
    }
}

// Пример использования фабричного метода
public class Main {
    public static void main(String[] args) {
// Создание фабрик для разных типов уведомлений
        NotificationCreator emailCreator = new EmailNotificationCreator();
        NotificationCreator smsCreator = new SMSNotificationCreator();
        NotificationCreator pushCreator = new PushNotificationCreator();

        // Отправка уведомлений
        emailCreator.notifyUser();  // Sending an email notification
        smsCreator.notifyUser();    // Sending an SMS notification
        pushCreator.notifyUser();   // Sending a push notification
    }
}
```

Как работает этот пример:

- Продукты — классы EmailNotification, SMSNotification и PushNotification, которые реализуют интерфейс Notification и
  представляют собой разные типы уведомлений.
- Фабричный метод — метод createNotification() в классе NotificationCreator, который возвращает объект типа
  Notification.
- Конкретные создатели — классы EmailNotificationCreator, SMSNotificationCreator, и PushNotificationCreator, которые
  реализуют фабричный метод для создания конкретных типов уведомлений.
- Полиморфизм — клиент использует объекты типа NotificationCreator для создания и отправки уведомлений, не зная деталей
  о конкретных продуктах (уведомлениях).

Когда применять шаблон Фабричный метод:

- Когда класс не знает, какие конкретные подклассы ему предстоит создавать — например, если процесс создания объекта
  может изменяться в зависимости от контекста или условий выполнения программы.
- Когда класс делегирует создание объектов своим подклассам — если родительский класс хочет предоставить общий интерфейс
  для создания объектов, но фактическое создание оставить подклассам.
- Для расширяемости системы — фабричный метод позволяет легко добавлять новые типы продуктов, не меняя существующий код.

Преимущества:

- Гибкость — классы не зависят от конкретных типов создаваемых объектов, что упрощает расширение системы.
- Расширяемость — можно легко добавлять новые типы продуктов, просто создавая новые классы с реализацией фабричного
  метода.
- Поддержка полиморфизма — клиентский код работает с интерфейсом продукта, а не с конкретными реализациями, что делает
  код более гибким и модульным.

Недостатки:

- Усложнение кода — добавление фабричного метода требует создания дополнительных классов, что может усложнить код при
  простых сценариях.
- Требует наследования — фабричный метод обычно требует создания подклассов для каждой конкретной реализации, что может
  привести к избыточному числу классов.

Важные моменты:

- Фабричный метод делегирует создание объектов — это позволяет подклассам выбирать, какие объекты создавать.
- Расширяемость и гибкость — новые типы продуктов можно добавлять без изменения существующего кода.

[К оглавлению](#OOP)

# 51. Что такое enum? Когда можно его применять?

Enum в Java является классом, который представляет набор предопределенных констант. Enum используется для определения
неизменяемых списков констант, которые являются одним объектом в программе.

Enum может применяться, когда у вас есть небольшой, но фиксированный набор констант, которые объединены общей тематикой.
Например, дни недели, месяцы года и т. д.

Некоторые из методов, которые можно использовать с Enum классом:

1. values() - возвращает массив всех констант в порядке, в котором они были объявлены
2. valueOf(String name) - возвращает соответствующую константу по имени
3. name() - возвращает имя константы
4. ordinal() - возвращает порядковый номер константы в списке
5. compareTo(Enum e) - сравнивает данную константу с другой константой
6. toString() - возвращает имя константы как строку

Кроме того, вы можете переопределить методы в Enum классе, что позволит вам добавить дополнительную функциональность для
ваших констант.

Класс Enum может объявляться как отдельно, так и внутри другого класса. Переменные являются неявно final static.

[К оглавлению](#OOP)

# 52. Что такое record? Когда можно его применять?

Record в Java — это новая особенность, которая добавлена в Java 14. Record представляет собой
упрощенный способ определения данных, который автоматически генерирует несколько методов, таких как equals(), hashCode()
и toString(), а также геттеры и сеттеры для всех параметров.

Record можно применять в случаях, когда нужно создать небольшой класс, представляющий данные, которые не изменяются.
Record упрощает написание кода, так как автоматически создает методы доступа к полям, методы equals(), hashCode() и
toString(). Это особенно удобно, если нужно создать много классов для хранения данных.

Пример использования Record:

```java
public record Person(String name, int age) {
    // Конструктор и дополнительные методы не нужно писать, они будут автоматически сгенерированы
}

public class Main {
    public static void main(String[] args) {
        Person person = new Person("Alice", 30);
        System.out.println(person); // Выведет: Person[name=Alice, age=30]
    }
}
```

[К оглавлению](#OOP)

# 53. Зачем нужны StringBuilder, StringBuffer, StringJoiner? Что они делают?

StringBuilder, StringBuffer и StringJoiner в Java используются для эффективной работы с изменяемыми строками.

StringBuilder и StringBuffer представляют собой изменяемые строки, которые позволяют выполнять операции добавления,
удаления и замены символов в строке без создания новых объектов String. Отличие между ними заключается в том, что
StringBuilder является несинхронизированным и предназначен для использования в однопоточном окружении, в то время как
StringBuffer является синхронизированным и безопасным для использования в многопоточном окружении.

StringJoiner представляет собой удобный способ объединения нескольких строк с заданным разделителем. Он имеет методы для
добавления новых элементов в строку и указания разделителя между ними.

В целом, StringBuilder, StringBuffer и StringJoiner позволяют эффективно работать с изменяемыми строками, что может быть
полезно при выполнении большого количества операций с текстом.

[К оглавлению](#OOP)

# 54. Чем отличаются StringBuffer и StringBuilder?

StringBuilder и StringJoiner - не синхронизированы. Они будут некорректно работать в многопоточной среде. StringBuffer -
аналог StringBuilder, только с синхронизированными методами для работы в многопоточной среде.

[К оглавлению](#OOP)

# 55. Каким образом производится экранирование символов и зачем это нужно?

Экранирование символов производится с помощью управляющих последовательностей.
В Java экранирование символов применяется для того, чтобы использовать в строках символы, имеющие специальное
значение, или символы, которые сложно вставить напрямую. Экранирование осуществляется с помощью обратного слэша. Это
позволяет интерпретатору Java распознавать специальные символы и выполнять их как команды или отображать их в строках.

[К оглавлению](#OOP)

# 56. Что такое управляющие последовательности?

Комбинация в виде обратного слэша и экранируемого им символа называется управляющей последовательностью. Все управляющие
последовательности подсвечиваются в IDEA синим цветом. Это означает, что эти
символы расцениваются как единый символ. В Java существует 8 видов управляющих последовательностей:

- \\' - Добавляет одинарную кавычку. Аналогично выводу двойной кавычки, выводит одиночную кавычку. Имеет смысл при
  выводе символа одинарной кавычки в одинарных кавычках (аналогично двойной кавычке среди двойных).
- \\" - Добавляет двойную кавычку
- \\ - Добавляет обратный слэш
- \r - Возврат каретки в начало строки. Возвращает каретку в начало строки, "обнуляя" её. Если в строке были данные, они
  пропадут.
- \n - Перевод каретки на новую строку.
- \f - Прогон страницы. Переводит документ на новую страницу. Неиспользуемый спецсимвол.
- \b - Возврат каретки на одну позицию назад. Работает как BackSpace - стирает один символ позади текущего положения
  каретки.
- \uXXXX - Unicode-символ

- [К оглавлению](#OOP)

# 57. Зачем нужно форматирование данных? Метод format()

Форматирование данных — это процесс преобразования данных в более читабельный или удобный формат для представления,
вывода или дальнейшей обработки. В Java форматирование данных необходимо для структурированного вывода текста, чисел,
дат и других типов данных в требуемом виде. Это помогает улучшить читабельность, точность, а также представление данных
для пользователя.

За создание форматированного текстового вывода отвечает класс `java.util.Formatter`. Метод format() этого класса
позволяет
выводить различные данные - строки, числа, даты, время в желаемом виде, т.е. преобразует данные в тот формат, который
нам нужен.

Метод format() класса String внутри он создает объект класса Formatter, вызывает у него метод format() с заданными нами
аргументами, и после возвращает строковое представление объекта Formatter. Метод format() класса Formatter получает
данные и преобразует их в определенный строковый формат. Отформатированные данные возвращаются в виде объекта типа
Formatter, который выводится в строковом представлении в методе format() класса String. Методы format() специально
определены в классе String и еще, например, в классах PrintStream и PrintWriter, т.е. в классах, которые работают с
выводом строк, чтобы не нужно было отдельно работать с классом Formatter - это удобно и получается меньше кода. А в
классах PrintStream и PrintWriter определён еще и метод printf(), который результат форматирования сразу выводит в
консоль аналогично методам print() или println().

Различия методов format() и printf():
Метод format() выполняет форматирование и возвращает новую строку. Её можно сохранить и использовать в дальнейшем. Метод
printf() выполняет форматирование и выводит данные в консоль без сохранения.

[К оглавлению](#OOP)

# 58. Что такое varargs? В каких случаях стоит его применять?

Varargs (variable arguments) в Java - это механизм, позволяющий передавать переменное количество аргументов методу. Он
представлен в виде троеточия (…) после типа данных последнего аргумента в объявлении метода.

Varargs следует применять в случаях, когда количество аргументов, передаваемых в метод, может быть различным на разных
вызовах метода. Например, метод, который выполняет сумму неопределенного количества чисел, может быть объявлен с
использованием varargs.

Преимущества использования varargs включают возможность передачи списка аргументов без необходимости создания массива,
более гибкое использование, а также удобство в случаях, когда точное количество аргументов заранее неизвестно.

```java
public class Example {

    public static void main(String[] args) {
        printNumbers(1, 2, 3, 4, 5);
        printNumbers(10, 20, 30);
        printNumbers(100, 200, 300, 400, 500, 600);
    }
    
    public static void printNumbers(int... numbers) {
        System.out.print("Numbers: ");
        for (int number : numbers) {
            System.out.print(number + " ");
        }
        System.out.println();
    }

}
```

[К оглавлению](#OOP)

# 59. В каких случаях может возникнуть неоднозначность при работе с varargs?

1. Когда есть методы с одинаковым числом параметров, но разными типами данных. В таком случае компилятор может не смочь определить, какой из методов следует вызвать.
2. Если varargs используется вместе с другими параметрами метода и необходимо определить, какие аргументы передавать varargs и какие – другим параметрам.
3. Неоднозначность может возникнуть при передаче массива в метод, который принимает varargs. Компилятор может не понять, что нужно передавать элементы массива как аргументы varargs.

Для разрешения неоднозначностей при работе с varargs в Java рекомендуется явное приведение типов данных и использование перегрузки методов.

```java
public class VarArgsExample {

    public static void main(String[] args) {
        printValues(1, "hello", 2.0);
    }

    public static void printValues(Object... values) {
        for (Object value : values) {
            System.out.println(value);
        }
    }

    // Этот метод вызовет ошибку компиляции, так как уже есть метод с varargs и компилятор не может определить, какой метод вызывать
    /*public static void printValues(Integer... values) {
        for (Integer value : values) {
            System.out.println(value);
        }
    }*/
}
```
[К оглавлению](#OOP)

# 60. Что такое форматированный вывод? Какие механизмы позволяют осуществить форматированный вывод?

Форматированный вывод в Java - это способ вывода данных, при котором можно контролировать и задавать формат вывода
чисел, строк, дат и других типов данных.

Для осуществления форматированного вывода в Java используются следующие механизмы:

1. Метод System.out.printf(): данный метод позволяет выводить данные с заданным форматом и использованием спецификаторов
   формата (%d для чисел, %s для строк, %f для чисел с плавающей точкой и др.). Пример:

```java
int num = 10;
System.out.printf("Число: %d",num);
```

2. Класс String.format(): данный класс позволяет создавать отформатированную строку без вывода на консоль. Пример:

```java
double num = 10.5;
String formattedString = String.format("Число: %.2f", num);
System.out.println(formattedString);
```

3. Класс Formatter: данный класс позволяет выполнять форматированный вывод с использованием методов format и printf.
   Пример:

```java
Formatter formatter = new Formatter();
int num = 10;
formatter.format("Число: %d",num);
System.out.println(formatter);
formatter.close();
``` 

Эти механизмы позволяют более гибко управлять выводом данных и представлением информации для пользователя.

[К оглавлению](#OOP)

# 61. Объясните отличие анонимного класса от локального класса?
- Анонимные классы: безымянные, создаются на месте, используются для простых и одноразовых объектов.
- Локальные классы: имеют имя, объявляются внутри методов или блоков, и лучше подходят для более сложных задач, где может
потребоваться использование метода и дополнительная логика.

[К оглавлению](#OOP)

# 62. Расскажите про методы в классе?

Методы в классе — это функции, которые определяют поведение объектов класса. Они позволяют объектам выполнять действия,
манипулировать данными и взаимодействовать с другими объектами. Методы обеспечивают инкапсуляцию логики и предоставляют
интерфейс для работы с внутренними данными класса (полями).

[К оглавлению](#OOP)
