## Web

[1. Расскажите, чем отличается UDP от TCP/IP.](#1-расскажите-чем-отличается-udp-от-tcpip)

[2. Расскажите о методах HTTP протокола. Подробно рассказать отличие в заголовке и теле запросов: GET, POST, PUT, DELETE.](#2-расскажите-о-методах-http-протокола-подробно-рассказать-отличие-в-заголовке-и-теле-запросов-get-post-put-delete)

[3. Расскажите о статусах HTTP протокола.](#3-расскажите-о-статусах-http-протокола)

[4. Расскажите о mime-type HTTP протокола.](#4-расскажите-о-mime-type-http-протокола)

[5. Что такое сервлет?](#5-что-такое-сервлет)

[6. Какова структура веб-проекта?](#6-какова-структура-веб-проекта)

[7. Что такое контейнер сервлетов?](#7-что-такое-контейнер-сервлетов)

[8. Каковы задачи, функциональность контейнера сервлетов?](#8-каковы-задачи-функциональность-контейнера-сервлетов)

[9. Что вы знаете о сервлет фильтрах?](#9-что-вы-знаете-о-сервлет-фильтрах)

[10. Зачем нужны слушатели в сервлетах?](#10-зачем-нужны-слушатели-в-сервлетах)

[11. Когда вы будете использовать фильтры, а когда слушатели?](#11-когда-вы-будете-использовать-фильтры-а-когда-слушатели)

[12. Как обработать исключения, выброшенные другим сервлетом в приложении?](#12-как-обработать-исключения-выброшенные-другим-сервлетом-в-приложении)

[13. Что такое дескриптор развертывания?](#13-что-такое-дескриптор-развертывания)

[14. Как реализовать запуск сервлета с запуском приложения?](#14-как-реализовать-запуск-сервлета-с-запуском-приложения)

[15. Что представляет собой объект ServletConfig?](#15-что-представляет-собой-объект-servletconfig)

[16. Что представляет собой объект ServletContext?](#16-что-представляет-собой-объект-servletcontext)

[17. В чем отличия ServletContext и ServletConfig?](#17-в-чем-отличия-servletcontext-и-servletconfig)

[18. Что такое Request Dispatcher?](#18-что-такое-request-dispatcher)

[19. Расскажите о назначении Thymeleaf?](#19-расскажите-о-назначении-thymeleaf)

[20. Расскажите про тег th:text.](#20-расскажите-про-тег-thtext)

[21. Расскажите про тег th:if.](#21-расскажите-про-тег-thif)

[22. Расскажите про тег th:href.](#22-расскажите-про-тег-thhref)

[23. Расскажите про тег th:each.](#23-расскажите-про-тег-theach)

[24. Расскажите про тег th:object.](#24-расскажите-про-тег-thobject)

[25. Расскажите про тег th:action.](#25-расскажите-про-тег-thaction)

[26. Опишите из каких компонентов состоит Spring boot?](#26-опишите-из-каких-компонентов-состоит-spring-boot)

[27. Что такое контроллер и как он связан с DispatcherServlet.](#27-что-такое-контроллер-и-как-он-связан-с-dispatcherservlet)

[28. Что такое стереотипные аннотации? Какие они бывают?](#28-что-такое-стереотипные-аннотации-какие-они-бывают)

[29. Что такое DI? Как он реализован в Spring?](#29-что-такое-di-как-он-реализован-в-spring)

[30. Опишите аннотации @ModelAttribute, @PathVariable, @RequestParam](#30-опишите-аннотации-modelattribute-pathvariable-requestparam)

[31. Опишите аннотации @GetMapping, @PostMapping.](#31-опишите-аннотации-getmapping-postmapping)

[32. Объясните, где в веб приложении появляется многопоточность?](#32-объясните-где-в-веб-приложении-появляется-многопоточность)

[33. Как избежать проблем в многопоточности?](#33-как-избежать-проблем-в-многопоточности)

[34. Как можно создать блокировку (deadlock) в сервлете?](#34-как-можно-создать-блокировку-deadlock-в-сервлете)

[35. Как решать проблемы многопоточности на уровне базы данных?](#35-как-решать-проблемы-многопоточности-на-уровне-базы-данных)

[36. Объясните слоеную архитектуру.](#36-объясните-слоеную-архитектуру)

[37. Объясните шаблон MVC на примере Servlet.](#37-объясните-шаблон-mvc-на-примере-servlet)

[38. Объясните шаблон MVC на примере Spring boot.](#38-объясните-шаблон-mvc-на-примере-spring-boot)

[39. Зачем нужен пул соединений?](#39-зачем-нужен-пул-соединений)

[40. Что такое HttpSession?](#40-что-такое-httpsession)

[41. Что такое авторизация?](#41-что-такое-авторизация)

[42. Что такое аутентификация?](#42-что-такое-аутентификация)

[43. Что такое cookie?](#43-что-такое-cookie)

# 1. Расскажите, чем отличается UDP от TCP/IP.

UDP (User Datagram Protocol) и TCP (Transmission Control Protocol) — это два разных транспортных протокола, которые
работают поверх IP (Internet Protocol). Разница между ними можно описать в следующих аспектах:

1. Способ доставки данных

   TCP:
   обеспечивает надежную доставку данных. Он использует механизм установки соединения (handshake), контроля потерь,
   подтверждений и повторной передачи. Данные передаются в определенном порядке, гарантируя их целостность.

   UDP:
   не обеспечивает надежности. Он отправляет данные без установки соединения, не ждет подтверждений, и нет гарантии,
   что данные достигнут адресата. Пакеты могут прийти не в том порядке или потеряться.

2. Скорость

   TCP:
   Медленнее, так как тратится время на установку соединения, контроль ошибок и подтверждения.

   UDP:
   Быстрее, поскольку нет дополнительных проверок и установок соединения.

3. Применение

   TCP:
   Используется для приложений, где важна надежность и порядок доставки данных, например:
   Веб-сайты (HTTP/HTTPS)
   Электронная почта (SMTP, IMAP, POP3)
   Передача файлов (FTP)
   UDP:
   Применяется там, где важна скорость, а потеря данных некритична, например:
   Видеоконференции
   Онлайн-игры
   Потоковая передача мультимедиа (VoIP, IPTV)

4. Установка соединения

   TCP:
   Требуется предварительная установка соединения через трехстороннее рукопожатие (three-way handshake).

   UDP:
   Соединение не устанавливается. Данные отправляются напрямую.

5. Контроль ошибок

   TCP:
   Встроенные механизмы контроля ошибок и повторной передачи данных.

   UDP:
   Минимальный контроль ошибок. Ответственность за обработку ошибок лежит на приложении.

#### Итог

+ TCP: Надежный, но медленный. Для приложений, требующих гарантированной доставки данных.
+ UDP: Быстрый, но ненадежный. Для приложений, где потеря пакетов допустима.

[К оглавлению](#Web)

# 2. Расскажите о методах HTTP протокола. Подробно рассказать отличие в заголовке и теле запросов: GET, POST, PUT, DELETE.

+ `GET` — получение ресурса
+ `POST` — создание ресурса
+ `PUT` — обновление ресурса
+ `DELETE` — удаление ресурса

`GET`:

• GET-запрос отправляется с минимальной информацией в заголовках. Заголовок содержит основную информацию, такую как:

+ Request-Line: указывает метод (GET), путь к ресурсу и версию протокола HTTP.
+ Host: указывает домен сервера.
+ User-Agent: информация о клиенте, который делает запрос.
+ Accept: указывает типы данных, которые клиент может обработать (например, text/html, application/json).
+ Cache-Control: директивы управления кэшированием.
+ Authorization: если требуется аутентификация, заголовок будет содержать данные для авторизации.
+ Cookies: отправка сессий или другой информации в виде куки-файлов.

- Тело:
  GET-запросы не имеют тела. Вся информация, необходимая для обработки запроса, передается через URL
  (например, параметры в строке запроса ?key=value).

`POST`:

• POST-запросы имеют более сложные заголовки, так как предполагается передача данных на сервер. Основные заголовки:

+ Request-Line: метод (POST), путь и версия HTTP.
+ Host, User-Agent, Accept: те же, что и в GET-запросах.
+ Content-Type: определяет тип данных, передаваемых в теле запроса
  (например, application/json, application/x-www-form-urlencoded, multipart/form-data).
+ Content-Length: указывает длину тела запроса.
+ Authorization, Cookies: аналогично GET-запросу, если требуется.

- Тело:

+ В теле POST-запроса передаются данные, которые сервер должен обработать. Это может быть:
+ JSON: { “key”: “value” }
+ Форма (application/x-www-form-urlencoded): key=value&key2=value2
+ Файлы (multipart/form-data): используется для отправки файлов на сервер.

`PUT`:

• Заголовки PUT-запроса схожи с заголовками POST-запроса, поскольку PUT также используется для передачи данных на
сервер.

+ Request-Line: метод (PUT), путь и версия HTTP.
+ Host, User-Agent, Accept, Content-Type, Content-Length, Authorization, Cookies: аналогично POST-запросу.

- Тело:

+ PUT-запрос обычно используется для обновления существующего ресурса или создания нового.
  В теле запроса передаются данные ресурса, которые будут заменены или созданы на сервере.
  Структура данных такая же, как в POST (JSON, XML, и т.д.).
+ В отличие от POST, PUT-запрос предполагает идемпотентность, то есть повторный запрос с одинаковыми данными
  не должен менять состояние ресурса.

`DELETE`:

• Заголовки DELETE-запроса минимальны и аналогичны GET-запросу:

+ Request-Line: метод (DELETE), путь и версия HTTP.
+ Host, User-Agent, Accept, Authorization, Cookies: стандартные заголовки, как в GET-запросах.

- Тело:

+ DELETE-запрос обычно не имеет тела. Вся информация для удаления ресурса передается через URL
  (например, идентификатор ресурса в пути).

[К оглавлению](#Web)

# 3. Расскажите о статусах HTTP протокола.

Статусов очень много, поэтому приведу основные:

- 200 OK
- 201 - часто используют вместо 200
- 301 - если используется перенаправление
- 400 - Bad Request
- 401 - Unauthorized
- 403 - Forbidden
- 404 - Not Found
- 405 - Method Not Allowed
- 418 - крутая штука для сокрытия реальной кода
- 500 - Internal Server Error
- 502 - Bad Gateway
- 503 - Service Unavailable
- 504 - Gateway Timeout

[К оглавлению](#Web)

# 4. Расскажите о mime-type HTTP протокола.

MIME-type (Multipurpose Internet Mail Extensions) — это стандартный способ обозначения типа содержимого передаваемых
данных в HTTP-протоколе. Он используется для того, чтобы сервер сообщал клиенту (например, браузеру), как обрабатывать
полученные данные.

Я сталкивался только с двумя:
application/json для отправки json и multipart/mixed - для отправки email

Вообще их вот столько:
application;
audio;
example;
image;
message;
model;
multipart;
text;
video.

[К оглавлению](#Web)

# 5. Что такое сервлет?

Это интерфейс в java, взаимодействует с клиентами посредством принципа запрос-ответ.

Жизненный цикл сервлета состоит из следующих шагов:

- В случае отсутствия сервлета в контейнере.

1) Класс сервлета загружается контейнером.
2) Контейнер создаёт экземпляр класса сервлета.
3) Контейнер вызывает метод init(). Этот метод инициализирует сервлет и вызывается в первую очередь, до того, как
   сервлет сможет обслуживать запросы.
   За весь жизненный цикл метод init() вызывается только один раз.

- Обслуживание клиентского запроса:
  Каждый запрос обрабатывается в своём отдельном потоке. Контейнер вызывает метод service() для каждого запроса.
  Этот метод определяет тип пришедшего запроса и распределяет его в соответствующий этому типу метод для обработки
  запроса.
  Разработчик сервлета должен предоставить реализацию для этих методов. Если поступил запрос, метод для которого не
  реализован,
  вызывается метод родительского класса и обычно завершается возвращением ошибки инициатору запроса.
- В случае если контейнеру необходимо удалить сервлет, он вызывает метод destroy(), который снимает сервлет из
  эксплуатации.
  Подобно методу init(), этот метод тоже вызывается единожды за весь цикл сервлета.

[К оглавлению](#Web)

# 6. Какова структура веб-проекта?

```java
db/
src/main/
java/*/
            config
            controller
            model
            repository
            service
        resources/
            static
            templates
            props
    src/test
        java/*/packetsForTests
resources/prop
```

[К оглавлению](#Web)

# 7. Что такое контейнер сервлетов?

Это часть сервера приложений или веб-сервера, которая управляет жизненным циклом сервлетов,
обеспечивает их взаимодействие с клиентами и окружением, а также предоставляет различные возможности для разработки
веб-приложений на Java.

Популярные реализации контейнеров сервлетов:

• Apache Tomcat

• Jetty

• GlassFish

• WildFly (бывший JBoss)

[К оглавлению](#Web)

# 8. Каковы задачи, функциональность контейнера сервлетов?

Основные функции контейнера сервлетов:

1. Управление жизненным циклом сервлетов: Контейнер создает, инициализирует, обрабатывает запросы и уничтожает сервлеты.
   Он контролирует все этапы работы сервлета — от его создания до завершения работы.
2. Обработка HTTP-запросов: Контейнер принимает HTTP-запросы от клиента (например, веб-браузера), передает их
   соответствующему сервлету для обработки и возвращает ответ клиенту.
3. Управление потоками: Контейнер автоматически создает потоки для обработки каждого запроса, что позволяет сервлетам
   обрабатывать несколько запросов одновременно.
4. Управление безопасностью: Контейнер может контролировать доступ к веб-ресурсам через различные механизмы
   аутентификации и авторизации (например, использование SSL, ограничение доступа к страницам и т.д.).
5. Поддержка сессий: Контейнер сервлетов может управлять сессиями пользователей, отслеживая информацию о пользователях
   между различными запросами (например, используя cookies или идентификаторы сессий).
6. Портируемость и стандарт: Сервлеты работают в соответствии с Java Servlet API, что обеспечивает переносимость
   веб-приложений между различными сервлет-контейнерами.

[К оглавлению](#Web)

# 9. Что вы знаете о сервлет фильтрах?

Это компоненты Java Servlet API, которые позволяют перехватывать и обрабатывать запросы и ответы, проходящие через
веб-приложение, до того, как они достигают сервлетов или других конечных точек.
Фильтры используются для выполнения различных задач, таких как аутентификация, логирование, сжатие данных и другие
операции, которые должны выполняться до или после основного процесса обработки запроса.

#### Основные характеристики и задачи фильтров:

1. Предобработка запросов: Фильтры могут изменять или логировать данные запроса, например, проверять заголовки,
   параметры или содержимое тела запроса, прежде чем передать его сервлету.
   Постобработка ответов: После того как сервлет завершил обработку, фильтры могут изменять или анализировать ответ,
   например, сжимать данные, добавлять заголовки или вести аудит.
   Цепочка фильтров: Несколько фильтров могут быть связаны друг с другом в цепочку. Каждый фильтр может передавать
   запрос следующему фильтру в цепочке или напрямую конечному компоненту (например, сервлету).
   Это позволяет организовывать обработку в несколько этапов.

#### Жизненный цикл фильтров:

1. Инициализация (init): Фильтр инициализируется контейнером при запуске приложения.
   Это метод, в котором можно настроить начальные параметры.
2. Фильтрация запроса (doFilter): Это основной метод фильтра, который вызывается при каждом запросе. Фильтр может:
   • изменить запрос,
   • отклонить его,
   • передать дальше по цепочке фильтров или непосредственно в сервлет,
   • обработать ответ после вызова сервлета.
3. Уничтожение (destroy): Этот метод вызывается, когда фильтр выгружается из памяти. Обычно это используется для очистки
   ресурсов.

#### Основные задачи фильтров:

1. Аутентификация и авторизация: Проверка, имеет ли пользователь права на доступ к ресурсу.
2. Логирование и аудит: Сбор информации о запросах и ответах (время, параметры и т.д.).
3. Сжатие данных: Сжатие ответов сервера для оптимизации передачи данных (например, использование GZIP).
4. Кэширование: Управление кэшированием данных для оптимизации производительности.
5. Перенаправление и изменение запросов: Изменение маршрута запроса, добавление или изменение параметров.

[К оглавлению](#Web)

# 10. Зачем нужны слушатели в сервлетах?

Это компоненты, которые отслеживают события в жизненном цикле веб-приложения и выполняют определенные действия в
ответ на эти события.

#### Основные задачи слушателей:

1. Инициализация ресурсов: Слушатели могут инициализировать необходимые ресурсы при запуске веб-приложения (например,
   соединение с базой данных, пул потоков).
2. Освобождение ресурсов: При завершении работы приложения слушатели могут закрывать соединения, освобождать память или
   выполнять другие операции очистки.
3. Мониторинг сессий: Слушатели могут отслеживать создание и уничтожение пользовательских сессий, что полезно для
   управления данными сессий, аутентификацией и персонализацией контента.
4. Логирование событий: Слушатели можно использовать для ведения логов ключевых событий приложения, таких как запросы,
   изменения в сессиях или изменения атрибутов.
5. Обработка событий в запросах: Можно отслеживать моменты начала и окончания обработки запросов для выполнения задач,
   связанных с безопасностью или оптимизацией.

#### Типы слушателей:

1. ServletContextListener: Отслеживает события, связанные с жизненным циклом контекста веб-приложения (инициализация и
   завершение работы).
2. HttpSessionListener: Отслеживает создание и завершение сессий пользователей.
3. ServletRequestListener: Отслеживает события, связанные с жизненным циклом запросов.
4. ServletContextAttributeListener: Отслеживает добавление, изменение и удаление атрибутов в контексте веб-приложения.
5. HttpSessionAttributeListener: Отслеживает изменения атрибутов сессий.
6. ServletRequestAttributeListener: Отслеживает добавление, изменение и удаление атрибутов в запросах.

[К оглавлению](#Web)

# 11. Когда вы будете использовать фильтры, а когда слушатели?

+ Используйте фильтры, когда необходимо вмешаться в поток запросов и ответов: изменять, проверять или логировать запросы
  и ответы на уровне обработки HTTP.
+ Используйте слушатели, когда нужно отслеживать события на уровне приложения, сессий или запросов, особенно для задач
  инициализации или управления состоянием.

[К оглавлению](#Web)

# 12. Как обработать исключения, выброшенные другим сервлетом в приложении?

1. try catch внутри сервлета
2. фильтр для перехвата исключений
3. Использование аннотации @WebServlet и атрибута errorPage

[К оглавлению](#Web)

# 13. Что такое дескриптор развертывания?

Это конфигурационный файл в Java веб-приложениях, который определяет, как веб-приложение должно быть развернуто и
настроено в контейнере сервлетов (например, в Tomcat или Jetty).
Этот файл (web.xml) содержит информацию, которая используется сервером приложений для правильной настройки и работы
веб-приложения.

[К оглавлению](#Web)

# 14. Как реализовать запуск сервлета с запуском приложения?

1. В файле web.xml можно настроить параметр <load-on-startup>, который определяет порядок загрузки сервлета при старте
   приложения.
2. Использование аннотации @WebServlet с параметром loadOnStartup

[К оглавлению](#Web)

# 15. Что представляет собой объект ServletConfig?

Это интерфейс, который предоставляет конфигурационную информацию о конкретном сервлете. Объект ServletConfig передается
контейнером сервлетов (например, Tomcat или Jetty) при инициализации сервлета и используется для передачи параметров
инициализации, определенных для конкретного сервлета.

[К оглавлению](#Web)

# 16. Что представляет собой объект ServletContext?

это объект, предоставляемый контейнером сервлетов (например, Tomcat, Jetty), который представляет собой глобальную
конфигурацию веб-приложения.
Он позволяет сервлетам взаимодействовать с общими ресурсами и информацией, доступной всему веб-приложению, а не только
одному конкретному сервлету

[К оглавлению](#Web)

# 17. В чем отличия ServletContext и ServletConfig?

+ ServletConfig: Предоставляет информацию и параметры для конкретного сервлета. Каждый сервлет имеет свой объект
  ServletConfig.
+ ServletContext: Представляет все веб-приложение и предоставляет доступ к общим ресурсам и параметрам, которые могут
  использоваться всеми сервлетами в приложении.

[К оглавлению](#Web)

# 18. Что такое Request Dispatcher?

Это интерфейс в Java Servlet API, который позволяет сервлетам взаимодействовать друг с другом.
Он используется для перенаправления запросов или передачи управления другим сервлетам или ресурсам на сервере.

#### Основные функции RequestDispatcher:

1.	Перенаправление запроса (forward):
+ Текущий сервлет может передать управление другому ресурсу (сервлету, JSP или статическому ресурсу) на сервере.
При этом управление полностью передается другому ресурсу, а клиент не будет знать, что запрос был перенаправлен.
2. Включение содержимого другого ресурса (include):
+ Можно включить результат обработки другого ресурса (например, другой сервлет или JSP-страница) в текущий ответ.
Это позволяет объединять результаты разных ресурсов в один ответ.


- SP (JavaServer Pages) — это технология для создания динамических веб-страниц на Java, которая позволяет встраивать Java-код прямо в HTML-страницы.
- JSP страницы компилируются в сервлеты и обрабатываются сервером, что позволяет динамически генерировать HTML-контент на основе запросов пользователей и данных с сервера.

[К оглавлению](#Web)

# 19. Расскажите о назначении Thymeleaf?

Удобный инструмент шаблонизации, явно удобнее чем рисовать страницы с JS

[К оглавлению](#Web)

# 20. Расскажите про тег th:text.

[К оглавлению](#Web)

# 21. Расскажите про тег th:if.

[К оглавлению](#Web)

# 22. Расскажите про тег th:href.

[К оглавлению](#Web)

# 23. Расскажите про тег th:each.

[К оглавлению](#Web)

# 24. Расскажите про тег th:object.

[К оглавлению](#Web)

# 25. Расскажите про тег th:action.

[К оглавлению](#Web)

# 26. Опишите из каких компонентов состоит Spring boot?

[К оглавлению](#Web)

# 27. Что такое контроллер и как он связан с DispatcherServlet.

[К оглавлению](#Web)

# 28. Что такое стереотипные аннотации? Какие они бывают?

[К оглавлению](#Web)

# 29. Что такое DI? Как он реализован в Spring?

[К оглавлению](#Web)

# 30. Опишите аннотации @ModelAttribute, @PathVariable, @RequestParam

[К оглавлению](#Web)

# 31. Опишите аннотации @GetMapping, @PostMapping.

[К оглавлению](#Web)

# 32. Объясните, где в веб приложении появляется многопоточность?

[К оглавлению](#Web)

# 33. Как избежать проблем в многопоточности?

[К оглавлению](#Web)

# 34. Как можно создать блокировку (deadlock) в сервлете?

[К оглавлению](#Web)

# 35. Как решать проблемы многопоточности на уровне базы данных?

[К оглавлению](#Web)

# 36. Объясните слоеную архитектуру.

[К оглавлению](#Web)

# 37. Объясните шаблон MVC на примере Servlet.

[К оглавлению](#Web)

# 38. Объясните шаблон MVC на примере Spring boot.

[К оглавлению](#Web)

# 39. Зачем нужен пул соединений?

[К оглавлению](#Web)

# 40. Что такое HttpSession?

[К оглавлению](#Web)

# 41. Что такое авторизация?

[К оглавлению](#Web)

# 42. Что такое аутентификация?

[К оглавлению](#Web)

# 43. Что такое cookie?

[К оглавлению](#Web)


