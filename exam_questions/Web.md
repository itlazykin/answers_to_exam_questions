## Web

[1. Расскажите, чем отличается UDP от TCP/IP.](#1-расскажите-чем-отличается-udp-от-tcpip)

[2. Расскажите о методах HTTP протокола. Подробно рассказать отличие в заголовке и теле запросов: GET, POST, PUT, DELETE.](#2-расскажите-о-методах-http-протокола-подробно-рассказать-отличие-в-заголовке-и-теле-запросов-get-post-put-delete)

[3. Расскажите о статусах HTTP протокола.](#3-расскажите-о-статусах-http-протокола)

[4. Расскажите о mime-type HTTP протокола.](#4-расскажите-о-mime-type-http-протокола)

[5. Что такое сервлет?](#5-что-такое-сервлет)

[6. Какова структура веб-проекта?](#6-какова-структура-веб-проекта)

[7. Что такое контейнер сервлетов?](#7-что-такое-контейнер-сервлетов)

[8. Каковы задачи, функциональность контейнера сервлетов?](#8-каковы-задачи-функциональность-контейнера-сервлетов)

[9. Что вы знаете о сервлет фильтрах?](#9-что-вы-знаете-о-сервлет-фильтрах)

[10. Зачем нужны слушатели в сервлетах?](#10-зачем-нужны-слушатели-в-сервлетах)

[11. Когда вы будете использовать фильтры, а когда слушатели?](#11-когда-вы-будете-использовать-фильтры-а-когда-слушатели)

[12. Как обработать исключения, выброшенные другим сервлетом в приложении?](#12-как-обработать-исключения-выброшенные-другим-сервлетом-в-приложении)

[13. Что такое дескриптор развертывания?](#13-что-такое-дескриптор-развертывания)

[14. Как реализовать запуск сервлета с запуском приложения?](#14-как-реализовать-запуск-сервлета-с-запуском-приложения)

[15. Что представляет собой объект ServletConfig?](#15-что-представляет-собой-объект-servletconfig)

[16. Что представляет собой объект ServletContext?](#16-что-представляет-собой-объект-servletcontext)

[17. В чем отличия ServletContext и ServletConfig?](#17-в-чем-отличия-servletcontext-и-servletconfig)

[18. Что такое Request Dispatcher?](#18-что-такое-request-dispatcher)

[19. Расскажите о назначении Thymeleaf?](#19-расскажите-о-назначении-thymeleaf)

[20. Расскажите про тег th:text.](#20-расскажите-про-тег-thtext)

[21. Расскажите про тег th:if.](#21-расскажите-про-тег-thif)

[22. Расскажите про тег th:href.](#22-расскажите-про-тег-thhref)

[23. Расскажите про тег th:each.](#23-расскажите-про-тег-theach)

[24. Расскажите про тег th:object.](#24-расскажите-про-тег-thobject)

[25. Расскажите про тег th:action.](#25-расскажите-про-тег-thaction)

[26. Опишите из каких компонентов состоит Spring boot?](#26-опишите-из-каких-компонентов-состоит-spring-boot)

[27. Что такое контроллер и как он связан с DispatcherServlet.](#27-что-такое-контроллер-и-как-он-связан-с-dispatcherservlet)

[28. Что такое стереотипные аннотации? Какие они бывают?](#28-что-такое-стереотипные-аннотации-какие-они-бывают)

[29. Что такое DI? Как он реализован в Spring?](#29-что-такое-di-как-он-реализован-в-spring)

[30. Опишите аннотации @ModelAttribute, @PathVariable, @RequestParam](#30-опишите-аннотации-modelattribute-pathvariable-requestparam)

[31. Опишите аннотации @GetMapping, @PostMapping.](#31-опишите-аннотации-getmapping-postmapping)

[32. Объясните, где в веб приложении появляется многопоточность?](#32-объясните-где-в-веб-приложении-появляется-многопоточность)

[33. Как избежать проблем в многопоточности?](#33-как-избежать-проблем-в-многопоточности)

[34. Как можно создать блокировку (deadlock) в сервлете?](#34-как-можно-создать-блокировку-deadlock-в-сервлете)

[35. Как решать проблемы многопоточности на уровне базы данных?](#35-как-решать-проблемы-многопоточности-на-уровне-базы-данных)

[36. Объясните слоеную архитектуру.](#36-объясните-слоеную-архитектуру)

[37. Объясните шаблон MVC на примере Servlet.](#37-объясните-шаблон-mvc-на-примере-servlet)

[38. Объясните шаблон MVC на примере Spring boot.](#38-объясните-шаблон-mvc-на-примере-spring-boot)

[39. Зачем нужен пул соединений?](#39-зачем-нужен-пул-соединений)

[40. Что такое HttpSession?](#40-что-такое-httpsession)

[41. Что такое авторизация?](#41-что-такое-авторизация)

[42. Что такое аутентификация?](#42-что-такое-аутентификация)

[43. Что такое cookie?](#43-что-такое-cookie)

# 1. Расскажите, чем отличается UDP от TCP/IP.

UDP (User Datagram Protocol) и TCP (Transmission Control Protocol) — это два разных транспортных протокола, которые
работают поверх IP (Internet Protocol). Разница между ними можно описать в следующих аспектах:

1. Способ доставки данных

   TCP:
   обеспечивает надежную доставку данных. Он использует механизм установки соединения (handshake), контроля потерь,
   подтверждений и повторной передачи. Данные передаются в определенном порядке, гарантируя их целостность.

   UDP:
   не обеспечивает надежности. Он отправляет данные без установки соединения, не ждет подтверждений, и нет гарантии,
   что данные достигнут адресата. Пакеты могут прийти не в том порядке или потеряться.

2. Скорость

   TCP:
   Медленнее, так как тратится время на установку соединения, контроль ошибок и подтверждения.

   UDP:
   Быстрее, поскольку нет дополнительных проверок и установок соединения.

3. Применение

   TCP:
   Используется для приложений, где важна надежность и порядок доставки данных, например:
   Веб-сайты (HTTP/HTTPS)
   Электронная почта (SMTP, IMAP, POP3)
   Передача файлов (FTP)
   UDP:
   Применяется там, где важна скорость, а потеря данных некритична, например:
   Видеоконференции
   Онлайн-игры
   Потоковая передача мультимедиа (VoIP, IPTV)

4. Установка соединения

   TCP:
   Требуется предварительная установка соединения через трехстороннее рукопожатие (three-way handshake).

   UDP:
   Соединение не устанавливается. Данные отправляются напрямую.

5. Контроль ошибок

   TCP:
   Встроенные механизмы контроля ошибок и повторной передачи данных.

   UDP:
   Минимальный контроль ошибок. Ответственность за обработку ошибок лежит на приложении.

#### Итог

+ TCP: Надежный, но медленный. Для приложений, требующих гарантированной доставки данных.
+ UDP: Быстрый, но ненадежный. Для приложений, где потеря пакетов допустима.

[К оглавлению](#Web)

# 2. Расскажите о методах HTTP протокола. Подробно рассказать отличие в заголовке и теле запросов: GET, POST, PUT, DELETE.

+ `GET` — получение ресурса
+ `POST` — создание ресурса
+ `PUT` — обновление ресурса
+ `DELETE` — удаление ресурса

`GET`:

• GET-запрос отправляется с минимальной информацией в заголовках. Заголовок содержит основную информацию, такую как:

+ Request-Line: указывает метод (GET), путь к ресурсу и версию протокола HTTP.
+ Host: указывает домен сервера.
+ User-Agent: информация о клиенте, который делает запрос.
+ Accept: указывает типы данных, которые клиент может обработать (например, text/html, application/json).
+ Cache-Control: директивы управления кэшированием.
+ Authorization: если требуется аутентификация, заголовок будет содержать данные для авторизации.
+ Cookies: отправка сессий или другой информации в виде куки-файлов.

- Тело:
  GET-запросы не имеют тела. Вся информация, необходимая для обработки запроса, передается через URL
  (например, параметры в строке запроса ?key=value).

`POST`:

• POST-запросы имеют более сложные заголовки, так как предполагается передача данных на сервер. Основные заголовки:

+ Request-Line: метод (POST), путь и версия HTTP.
+ Host, User-Agent, Accept: те же, что и в GET-запросах.
+ Content-Type: определяет тип данных, передаваемых в теле запроса
  (например, application/json, application/x-www-form-urlencoded, multipart/form-data).
+ Content-Length: указывает длину тела запроса.
+ Authorization, Cookies: аналогично GET-запросу, если требуется.

- Тело:

+ В теле POST-запроса передаются данные, которые сервер должен обработать. Это может быть:
+ JSON: { “key”: “value” }
+ Форма (application/x-www-form-urlencoded): key=value&key2=value2
+ Файлы (multipart/form-data): используется для отправки файлов на сервер.

`PUT`:

• Заголовки PUT-запроса схожи с заголовками POST-запроса, поскольку PUT также используется для передачи данных на
сервер.

+ Request-Line: метод (PUT), путь и версия HTTP.
+ Host, User-Agent, Accept, Content-Type, Content-Length, Authorization, Cookies: аналогично POST-запросу.

- Тело:

+ PUT-запрос обычно используется для обновления существующего ресурса или создания нового.
  В теле запроса передаются данные ресурса, которые будут заменены или созданы на сервере.
  Структура данных такая же, как в POST (JSON, XML, и т.д.).
+ В отличие от POST, PUT-запрос предполагает идемпотентность, то есть повторный запрос с одинаковыми данными
  не должен менять состояние ресурса.

`DELETE`:

• Заголовки DELETE-запроса минимальны и аналогичны GET-запросу:

+ Request-Line: метод (DELETE), путь и версия HTTP.
+ Host, User-Agent, Accept, Authorization, Cookies: стандартные заголовки, как в GET-запросах.

- Тело:

+ DELETE-запрос обычно не имеет тела. Вся информация для удаления ресурса передается через URL
  (например, идентификатор ресурса в пути).

[К оглавлению](#Web)

# 3. Расскажите о статусах HTTP протокола.

Статусов очень много, поэтому приведу основные:

- 200 OK
- 201 - часто используют вместо 200
- 301 - если используется перенаправление
- 400 - Bad Request
- 401 - Unauthorized
- 403 - Forbidden
- 404 - Not Found
- 405 - Method Not Allowed
- 418 - крутая штука для сокрытия реальной кода
- 500 - Internal Server Error
- 502 - Bad Gateway
- 503 - Service Unavailable
- 504 - Gateway Timeout

[К оглавлению](#Web)

# 4. Расскажите о mime-type HTTP протокола.

MIME-type (Multipurpose Internet Mail Extensions) — это стандартный способ обозначения типа содержимого передаваемых
данных в HTTP-протоколе. Он используется для того, чтобы сервер сообщал клиенту (например, браузеру), как обрабатывать
полученные данные.

Я сталкивался только с двумя:
application/json для отправки json и multipart/mixed - для отправки email

Вообще их вот столько:
application;
audio;
example;
image;
message;
model;
multipart;
text;
video.

[К оглавлению](#Web)

# 5. Что такое сервлет?

Это интерфейс в java, взаимодействует с клиентами посредством принципа запрос-ответ.

Жизненный цикл сервлета состоит из следующих шагов:

- В случае отсутствия сервлета в контейнере.

1) Класс сервлета загружается контейнером.
2) Контейнер создаёт экземпляр класса сервлета.
3) Контейнер вызывает метод init(). Этот метод инициализирует сервлет и вызывается в первую очередь, до того, как
   сервлет сможет обслуживать запросы.
   За весь жизненный цикл метод init() вызывается только один раз.

- Обслуживание клиентского запроса:
  Каждый запрос обрабатывается в своём отдельном потоке. Контейнер вызывает метод service() для каждого запроса.
  Этот метод определяет тип пришедшего запроса и распределяет его в соответствующий этому типу метод для обработки
  запроса.
  Разработчик сервлета должен предоставить реализацию для этих методов. Если поступил запрос, метод для которого не
  реализован,
  вызывается метод родительского класса и обычно завершается возвращением ошибки инициатору запроса.
- В случае если контейнеру необходимо удалить сервлет, он вызывает метод destroy(), который снимает сервлет из
  эксплуатации.
  Подобно методу init(), этот метод тоже вызывается единожды за весь цикл сервлета.

[К оглавлению](#Web)

# 6. Какова структура веб-проекта?

```java
db/
src/main/
java/*/
            config
            controller
            model
            repository
            service
        resources/
            static
            templates
            props
    src/test
        java/*/packetsForTests
resources/prop
```

[К оглавлению](#Web)

# 7. Что такое контейнер сервлетов?

Это часть сервера приложений или веб-сервера, которая управляет жизненным циклом сервлетов,
обеспечивает их взаимодействие с клиентами и окружением, а также предоставляет различные возможности для разработки
веб-приложений на Java.

Популярные реализации контейнеров сервлетов:

• Apache Tomcat

• Jetty

• GlassFish

• WildFly (бывший JBoss)

[К оглавлению](#Web)

# 8. Каковы задачи, функциональность контейнера сервлетов?

Основные функции контейнера сервлетов:

1. Управление жизненным циклом сервлетов: Контейнер создает, инициализирует, обрабатывает запросы и уничтожает сервлеты.
   Он контролирует все этапы работы сервлета — от его создания до завершения работы.
2. Обработка HTTP-запросов: Контейнер принимает HTTP-запросы от клиента (например, веб-браузера), передает их
   соответствующему сервлету для обработки и возвращает ответ клиенту.
3. Управление потоками: Контейнер автоматически создает потоки для обработки каждого запроса, что позволяет сервлетам
   обрабатывать несколько запросов одновременно.
4. Управление безопасностью: Контейнер может контролировать доступ к веб-ресурсам через различные механизмы
   аутентификации и авторизации (например, использование SSL, ограничение доступа к страницам и т.д.).
5. Поддержка сессий: Контейнер сервлетов может управлять сессиями пользователей, отслеживая информацию о пользователях
   между различными запросами (например, используя cookies или идентификаторы сессий).
6. Портируемость и стандарт: Сервлеты работают в соответствии с Java Servlet API, что обеспечивает переносимость
   веб-приложений между различными сервлет-контейнерами.

[К оглавлению](#Web)

# 9. Что вы знаете о сервлет фильтрах?

Это компоненты Java Servlet API, которые позволяют перехватывать и обрабатывать запросы и ответы, проходящие через
веб-приложение, до того, как они достигают сервлетов или других конечных точек.
Фильтры используются для выполнения различных задач, таких как аутентификация, логирование, сжатие данных и другие
операции, которые должны выполняться до или после основного процесса обработки запроса.

#### Основные характеристики и задачи фильтров:

1. Предобработка запросов: Фильтры могут изменять или логировать данные запроса, например, проверять заголовки,
   параметры или содержимое тела запроса, прежде чем передать его сервлету.
   Постобработка ответов: После того как сервлет завершил обработку, фильтры могут изменять или анализировать ответ,
   например, сжимать данные, добавлять заголовки или вести аудит.
   Цепочка фильтров: Несколько фильтров могут быть связаны друг с другом в цепочку. Каждый фильтр может передавать
   запрос следующему фильтру в цепочке или напрямую конечному компоненту (например, сервлету).
   Это позволяет организовывать обработку в несколько этапов.

#### Жизненный цикл фильтров:

1. Инициализация (init): Фильтр инициализируется контейнером при запуске приложения.
   Это метод, в котором можно настроить начальные параметры.
2. Фильтрация запроса (doFilter): Это основной метод фильтра, который вызывается при каждом запросе. Фильтр может:
   • изменить запрос,
   • отклонить его,
   • передать дальше по цепочке фильтров или непосредственно в сервлет,
   • обработать ответ после вызова сервлета.
3. Уничтожение (destroy): Этот метод вызывается, когда фильтр выгружается из памяти. Обычно это используется для очистки
   ресурсов.

#### Основные задачи фильтров:

1. Аутентификация и авторизация: Проверка, имеет ли пользователь права на доступ к ресурсу.
2. Логирование и аудит: Сбор информации о запросах и ответах (время, параметры и т.д.).
3. Сжатие данных: Сжатие ответов сервера для оптимизации передачи данных (например, использование GZIP).
4. Кэширование: Управление кэшированием данных для оптимизации производительности.
5. Перенаправление и изменение запросов: Изменение маршрута запроса, добавление или изменение параметров.

[К оглавлению](#Web)

# 10. Зачем нужны слушатели в сервлетах?

Это компоненты, которые отслеживают события в жизненном цикле веб-приложения и выполняют определенные действия в
ответ на эти события.

#### Основные задачи слушателей:

1. Инициализация ресурсов: Слушатели могут инициализировать необходимые ресурсы при запуске веб-приложения (например,
   соединение с базой данных, пул потоков).
2. Освобождение ресурсов: При завершении работы приложения слушатели могут закрывать соединения, освобождать память или
   выполнять другие операции очистки.
3. Мониторинг сессий: Слушатели могут отслеживать создание и уничтожение пользовательских сессий, что полезно для
   управления данными сессий, аутентификацией и персонализацией контента.
4. Логирование событий: Слушатели можно использовать для ведения логов ключевых событий приложения, таких как запросы,
   изменения в сессиях или изменения атрибутов.
5. Обработка событий в запросах: Можно отслеживать моменты начала и окончания обработки запросов для выполнения задач,
   связанных с безопасностью или оптимизацией.

#### Типы слушателей:

1. ServletContextListener: Отслеживает события, связанные с жизненным циклом контекста веб-приложения (инициализация и
   завершение работы).
2. HttpSessionListener: Отслеживает создание и завершение сессий пользователей.
3. ServletRequestListener: Отслеживает события, связанные с жизненным циклом запросов.
4. ServletContextAttributeListener: Отслеживает добавление, изменение и удаление атрибутов в контексте веб-приложения.
5. HttpSessionAttributeListener: Отслеживает изменения атрибутов сессий.
6. ServletRequestAttributeListener: Отслеживает добавление, изменение и удаление атрибутов в запросах.

[К оглавлению](#Web)

# 11. Когда вы будете использовать фильтры, а когда слушатели?

+ Используйте фильтры, когда необходимо вмешаться в поток запросов и ответов: изменять, проверять или логировать запросы
  и ответы на уровне обработки HTTP.
+ Используйте слушатели, когда нужно отслеживать события на уровне приложения, сессий или запросов, особенно для задач
  инициализации или управления состоянием.

[К оглавлению](#Web)

# 12. Как обработать исключения, выброшенные другим сервлетом в приложении?

1. try catch внутри сервлета
2. фильтр для перехвата исключений
3. Использование аннотации @WebServlet и атрибута errorPage

[К оглавлению](#Web)

# 13. Что такое дескриптор развертывания?

Это конфигурационный файл в Java веб-приложениях, который определяет, как веб-приложение должно быть развернуто и
настроено в контейнере сервлетов (например, в Tomcat или Jetty).
Этот файл (web.xml) содержит информацию, которая используется сервером приложений для правильной настройки и работы
веб-приложения.

[К оглавлению](#Web)

# 14. Как реализовать запуск сервлета с запуском приложения?

1. В файле web.xml можно настроить параметр <load-on-startup>, который определяет порядок загрузки сервлета при старте
   приложения.
2. Использование аннотации @WebServlet с параметром loadOnStartup

[К оглавлению](#Web)

# 15. Что представляет собой объект ServletConfig?

Это интерфейс, который предоставляет конфигурационную информацию о конкретном сервлете. Объект ServletConfig передается
контейнером сервлетов (например, Tomcat или Jetty) при инициализации сервлета и используется для передачи параметров
инициализации, определенных для конкретного сервлета.

[К оглавлению](#Web)

# 16. Что представляет собой объект ServletContext?

это объект, предоставляемый контейнером сервлетов (например, Tomcat, Jetty), который представляет собой глобальную
конфигурацию веб-приложения.
Он позволяет сервлетам взаимодействовать с общими ресурсами и информацией, доступной всему веб-приложению, а не только
одному конкретному сервлету

[К оглавлению](#Web)

# 17. В чем отличия ServletContext и ServletConfig?

+ ServletConfig: Предоставляет информацию и параметры для конкретного сервлета. Каждый сервлет имеет свой объект
  ServletConfig.
+ ServletContext: Представляет все веб-приложение и предоставляет доступ к общим ресурсам и параметрам, которые могут
  использоваться всеми сервлетами в приложении.

[К оглавлению](#Web)

# 18. Что такое Request Dispatcher?

Это интерфейс в Java Servlet API, который позволяет сервлетам взаимодействовать друг с другом.
Он используется для перенаправления запросов или передачи управления другим сервлетам или ресурсам на сервере.

#### Основные функции RequestDispatcher:

1. Перенаправление запроса (forward):

+ Текущий сервлет может передать управление другому ресурсу (сервлету, JSP или статическому ресурсу) на сервере.
  При этом управление полностью передается другому ресурсу, а клиент не будет знать, что запрос был перенаправлен.

2. Включение содержимого другого ресурса (include):

+ Можно включить результат обработки другого ресурса (например, другой сервлет или JSP-страница) в текущий ответ.
  Это позволяет объединять результаты разных ресурсов в один ответ.


- SP (JavaServer Pages) — это технология для создания динамических веб-страниц на Java, которая позволяет встраивать
  Java-код прямо в HTML-страницы.
- JSP страницы компилируются в сервлеты и обрабатываются сервером, что позволяет динамически генерировать HTML-контент
  на основе запросов пользователей и данных с сервера.

[К оглавлению](#Web)

# 19. Расскажите о назначении Thymeleaf?

Thymeleaf - это движок шаблонов (Template engine), который создаёт из них динамические таблицы с помощью специальных
атрибутов. Он позволяет удобно контролировать процесс передачи данных из БД на вид (View), а также выбирать способ
обработки этих данных. Основная цель Thymeleaf - обработка HTML, XML, JavaScript, CSS и обычного текста для создания с
их помощью пользовательского интерфейса, то есть это простой и удобный способ шаблонизации. На основе выражений в файле
он генерирует статическое содержимое. Thymeleaf основывается на концепции natural templates - логика Thymeleaf
внедряется в шаблоны способом, не нарушающим структуру файла.

[К оглавлению](#Web)

# 20. Расскажите про тег th:text.

`th:text` предназначен для динамической подстановки текста (или других данных) в HTML-элемент.
В отличие от стандартного HTML-тега, который может выводить текст статически, th:text позволяет внедрить данные из
контроллера или модели Spring, заменяя содержимое HTML-элемента.

#### Как работает th:text:

1. Статический контент заменяется динамическим: Содержимое тега, где используется th:text, заменяется на значение,
   переданное в модель из контроллера. Это важно для предотвращения вывода статического содержимого и подмены его
   динамическими данными.
2. Обработка данных на стороне сервера: Тег th:text интерпретируется и заполняется на стороне сервера, а не клиента.
   Когда клиент получает готовую страницу, она уже содержит данные, сгенерированные на сервере.

[К оглавлению](#Web)

# 21. Расскажите про тег th:if.

Используется для условного отображения элементов на веб-странице.
Он позволяет вывести элемент только в том случае, если заданное условие является истинным. Это аналог оператора if в
java.

Тег `th:unless`, он является противоположностью `th:if`, т.е. производит проверку на false. т.е. отображает
элемент если условие false.

#### Особенности th:if:

• Полное удаление элемента: Если условие в `th:if` не выполняется (т.е. ложное), элемент полностью удаляется из
DOM-структуры.
Это делает его более производительным и удобным для использования, когда нужно скрыть элементы, которые не должны
присутствовать на странице.

[К оглавлению](#Web)

# 22. Расскажите про тег th:href.

Используется для динамического формирования значений атрибута href в HTML-элементах, таких как ссылки `(<a>)` и другие
теги,
где требуется указать URL. Это позволяет подставлять URL-адреса на основе данных, полученных с сервера, или на основе
логики,
определенной в шаблоне.

[К оглавлению](#Web)

# 23. Расскажите про тег th:each.

Используется для работы с коллекциями.

```java
<h1> Список продуктов</h1>
<ul>
<li th:each="product : ${products}"th:text="${product}">Продукт</li>
</ul>
```

В js с этм иначе, там рисование тэга оборачивается в цикл, а тут не недо оборачивать тэг циклом.

[К оглавлению](#Web)

# 24. Расскажите про тег th:object.

Используется для удобной работы с полями объекта. Нет необходимости каждый раз указывать объект.

```java
    <form th:object="${someObject}">
        <input type="text"th:field="*{fieldName}"/>
    </form>
```

[К оглавлению](#Web)

# 25. Расскажите про тег th:action.

Атрибут action определяет, куда будет отправлен запрос при отправке формы.
Так же можно передавать динамические параметры в URL.

[К оглавлению](#Web)

# 26. Опишите из каких компонентов состоит Spring boot?

В обучении используем:

spring-boot-starter-thymeleaf

spring-boot-starter-web

spring-boot-devtools

spring-boot-starter-actuator

spring-boot-starter-test

[К оглавлению](#Web)

# 27. Что такое контроллер и как он связан с DispatcherServlet.

Вся логика работы Spring MVC построена вокруг DispatcherServlet, который принимает и обрабатывает все HTTP-запросы (из
UI) и ответы на них.

- После получения HTTP-запроса DispatcherServlet обращается к интерфейсу HandlerMapping, который определяет, какой
  Контроллер должен быть вызван, после чего, отправляет запрос в нужный Контроллер.
- Контроллер принимает запрос и вызывает соответствующий служебный метод, основанный на GET или POST.
  Вызванный метод определяет данные Модели, основанные на определённой бизнес-логике и возвращает в DispatcherServlet
  имя Вида (View).
- При помощи интерфейса ViewResolver DispatcherServlet определяет, какой Вид нужно использовать на основании полученного
  имени.
- После того, как Вид (View) создан, DispatcherServlet отправляет данные Модели в виде атрибутов в Вид,
  который в конечном итоге отображается в браузере.

Все вышеупомянутые компоненты, а именно, HandlerMapping, Controller и ViewResolver, являются частями интерфейса
WebApplicationContext extends ApplicationContext, с некоторыми дополнительными особенностями, необходимыми для создания
web-приложений.

[К оглавлению](#Web)

# 28. Что такое стереотипные аннотации? Какие они бывают?

Стереотипы — это аннотации, обозначающие специальную функциональность.
Все стереотипы включают в себя аннотацию @Component.

+ `@Component` Корневая аннотация, которая помечает класс как кандидат для автовнедрения
+ `@Controller` Указывает, что класс является контроллером для отправления данных на фронт.
+ `@RestController` Указывает, что класс является контроллером для REST.
  Содержит аннотации @Controller и @ResponseBody
+ `@Service` Указывает, что класс является сервисом для выполнения бизнес-логики
+ `@Repository` Указывает, что класс является репозиторием для работы с бд
+ `@Configuration` Указывает, что класс содержит Java-конфигурацию(@Bean-методы)

[К оглавлению](#Web)

# 29. Что такое DI? Как он реализован в Spring?

DI (Dependency Injection) — это шаблон проектирования, который используется для управления зависимостями между объектами.
В контексте DI, зависимость — это объект, от которого зависит другой объект для выполнения своих задач.
DI решает задачу создания и предоставления этих зависимостей через внешние механизмы, а не непосредственно в коде.

В Spring Dependency Injection (DI) — это основополагающий принцип, который реализуется через Inversion of Control (IoC) контейнер.
Контейнер IoC отвечает за создание объектов (бинов), их конфигурацию и управление зависимостями между ними.

#### В Spring DI реализован через 3 основных механизма:

+ Конструкторная инъекция (Constructor Injection)
+ Инъекция через сеттеры (Setter Injection)
+ Инъекция полей через аннотации (Field Injection)

[К оглавлению](#Web)

# 30. Опишите аннотации @ModelAttribute, @PathVariable, @RequestParam

- `@ModelAttribute` : используется для работы с объектами модели и играет важную роль при передаче данных между
  контроллером и представлением (view)

Два основных способа использования @ModelAttribute:

1) Как метод в контроллере.
   Метод, аннотированный @ModelAttribute, добавляет объект в модель перед выполнением любого метода контроллера, чтобы
   этот объект был доступен в представлении.
   Это полезно для подготовки данных, которые будут доступны на всех страницах.

```java

@ModelAttribute("movie")
public Movie createMovie() {
    return new Movie();  // Создаем новый объект Movie, который будет доступен в представлении
}
```

2) Как параметр метода контроллера.
   Автоматически связывает данные из HTTP-запроса (например, параметры формы или параметры URL) с полями объекта.

```java

@PostMapping("/addMovie")
public String addMovie(@ModelAttribute("movie") Movie movie) {
// Данные формы автоматически привязываются к объекту Movie
    movieService.saveMovie(movie);
    return "redirect:/movies";
}
```

- `@PathVariable` : используется для извлечения значений из URL (части пути) и передачи их в метод контроллера.

```java

@GetMapping("/movie/{id}")
public String getMovieById(@PathVariable("id") Long movieId, Model model) {
    Movie movie = movieService.getMovieById(movieId);
    model.addAttribute("movie", movie);
    return "movieDetails";
}
```

- `@RequestParam` : используется для извлечения параметров из строки запроса (query parameters) и передачи их в метод
  контроллера.

````java

@GetMapping("/searchMovie")
public String searchMovie(@RequestParam("title") String title, Model model) {
    List<Movie> movies = movieService.searchByTitle(title);
    model.addAttribute("movies", movies);
    return "searchResults";
}
````
[К оглавлению](#Web)

# 31. Опишите аннотации @GetMapping, @PostMapping.

Аннотации @GetMapping и @PostMapping используются в Spring Framework для упрощения создания RESTful веб-приложений. Они
являются специализированными версиями аннотации @RequestMapping и предназначены для обработки HTTP-запросов методов GET
и POST. 
+ @GetMapping: указываем что на конкретный путь (URI) отправляется GET запрос и в методе под аннотацией указываем что должно возвращаться пользователю 
+ @PostMapping: тоже самое только для POST запросов.

[К оглавлению](#Web)

# 32. Объясните, где в веб приложении появляется многопоточность?

В сервлете, тк он всегда создается в единственном экземпляре. Для каждого нового запроса Servlet Container создает
новый поток для выполнения doGet() или doPost() методов сервлета.

[К оглавлению](#Web)

# 33. Как избежать проблем в многопоточности?

В курсе эта проблема решается с помощью БД, а точнее с помощью параметра unique

[К оглавлению](#Web)

# 34. Как можно создать блокировку (deadlock) в сервлете?

Deadlock возникает, когда два (или более) потока оказываются в состоянии взаимного ожидания: каждый из них блокирует ресурс,
который нужен другому потоку для завершения работы.

[К оглавлению](#Web)

# 35. Как решать проблемы многопоточности на уровне базы данных?

В курсе эта проблема решается с помощью БД, а точнее с помощью параметра unique

[К оглавлению](#Web)

# 36. Объясните слоеную архитектуру.

Слой - это классы имеющую одну функциональную принадлежность

стандартно: controllers -> services -> persistence -> DB
+ Слой контроллеры - это классы для работы с клиентом. Эти классы принимают запросы и отдают ответы от клиента.
+ Слой сервисы - это классы, выполняющие бизнес логику приложения.
+ Слой персистенции - это классы для работы с базами данных.

Слои идут сверху вниз. Верхний слой знает, что под ним, нижний - знает, что над ним. Слой не может перепрыгнуть через
слой. То есть контроллер не может напрямую вызвать слой персистенции - принцп инверсии зависимости из SOLID.

[К оглавлению](#Web)

# 37. Объясните шаблон MVC на примере Servlet.

1.	Пользователь отправляет запрос на URL /users (например, через браузер).
2.	Контроллер (Servlet) получает этот запрос. Он взаимодействует с моделью (UserService) для получения данных (списка пользователей).
3.	Контроллер сохраняет эти данные в атрибутах запроса с помощью req.setAttribute("users", users).
4.	Контроллер перенаправляет запрос на представление (JSP), которое берет данные из атрибутов и отображает их на странице.


[К оглавлению](#Web)

# 38. Объясните шаблон MVC на примере Spring boot.

В Spring Boot MVC реализуется благодаря встроенным аннотациям.

+ Запрос от клиента:
Пользователь обращается по URL /users.

+ Контроллер обрабатывает запрос:
Метод getAllUsers контроллера запрашивает данные у сервиса и передаёт их в модель (Model).

+ Сервис обрабатывает бизнес-логику:
Сервис берёт данные из базы данных через репозиторий и возвращает их контроллеру.

+ View отображает данные:
Контроллер возвращает имя шаблона (user-list), который рендерится в HTML с данными.

[К оглавлению](#Web)

# 39. Зачем нужен пул соединений?

Все запросы от клиентов обрабатываются в отдельных нитях.
По умолчанию в Tomcat используется 200 нитей для обработки запросов.
Если мы будем использовать одно соединение с базой данных, то остальные нити будут ждать завершения работы с базой
данных,
а для - веб приложений такая ситуация неприемлема. Веб приложения - это многопоточные приложения, где блокировать работу
пользователя нельзя.

[К оглавлению](#Web)

# 40. Что такое HttpSession?

Это интерфейс в Java Servlet API, который используется для хранения информации о состоянии между несколькими HTTP-запросами от одного и того же клиента (пользователя). 
#### Особенности:
1) Персистентность данных между запросами: HttpSession позволяет сохранять данные (например, информацию о пользователе, корзину покупок и т.д.) между несколькими запросами от одного клиента.
2) Уникальная сессия для каждого клиента: Для каждого клиента создается уникальная сессия, которая хранится на сервере и идентифицируется по специальному идентификатору сессии (Session ID).
Этот идентификатор обычно хранится в cookie на стороне клиента.
3) Жизненный цикл сессии: Сессия создается, когда клиент впервые обращается к приложению, и существует до тех пор, пока не истечет время бездействия (тайм-аут),
клиент явно не завершит сессию или сервер не закроет сессию.

[К оглавлению](#Web)

# 41. Что такое авторизация?

Проверка, что пользователь вообще есть.

[К оглавлению](#Web)

# 42. Что такое аутентификация?

Подтверждение подлинности пользователя через пароль.

[К оглавлению](#Web)

# 43. Что такое cookie?

Уникальный идентификатор пользователя.
Бывает постоянный и временный.
Используются для удобства пользования ресурсами, тк могут хранить в себе индивидуальные настройки и параметры типа корзины.

[К оглавлению](#Web)


