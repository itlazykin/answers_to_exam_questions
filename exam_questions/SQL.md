## SQL

[1. Что такое SQL?](#1-Что-такое-SQL)

[2. Что такое DML и DDL?](#2-Что-такое-DML-и-DDL)

[3. Что такое первичный ключ?](#3-Что-такое-первичный-ключ)

[4. Что такое внешний ключ?](#4-Что-такое-внешний-ключ)

[5. Какие виды связей между таблицами существуют и как они организуются?](#5-Какие-виды-связей-между-таблицами-существуют-и-как-они-организуются)

[6. Опишите как вставить, удалить, обновить данные в, из таблицы.](#6-опишите-как-вставить-удалить-обновить-данные-в-из-таблицы)

[7. Что такое нормализация БД?](#7-Что-такое-нормализация-БД)

[8. Что такое денормализация БД? Для чего она нужна?](#8-Что-такое-денормализация-БД-Для-чего-она-нужна)

[9. Что такое кластерный и некластерный индексы?](#9-Что-такое-кластерный-и-некластерный-индексы)

[10. Какие типы соединений join таблиц существуют? В чем их разница?](#10-Какие-типы-соединений-join-таблиц-существуют-В-чем-их-разница)

[11. Что такое SQL курсор?](#11-Что-такое-SQL-курсор)

[12. Опишите шаги по созданию и использованию курсора.](#12-Опишите-шаги-по-созданию-и-использованию-курсора)

[13. Что такое транзакция?](#13-Что-такое-транзакция)

[14. Что такое триггер? Какие типы триггеров Вы знаете?](#14-Что-такое-триггер-Какие-типы-триггеров-Вы-знаете)

[15. В чем разница между where и having?](#15-В-чем-разница-между-where-и-having)

[16. Что такое подзапрос sub-query?](#16-Что-такое-подзапрос-sub-query)

[17. Что такое union?](#17-Что-такое-union)

[18. Что такое group by?](#18-Что-такое-group-by)

[19. Что такое хранимые процедуры?](#19-Что-такое-хранимые-процедуры)

[20. Что такое view представление?](#20-Что-такое-view-представление)

[21. Что такое JDBC?](#21-Что-такое-JDBC)

[22. Что нужно для работы с той или иной БД?](#22-Что-нужно-для-работы-с-той-или-иной-БД)

[23. Как зарегистрировать драйвер?](#23-Как-зарегистрировать-драйвер)

[24. Как получить Connection?](#24-Как-получить-Connection)

[25. Что такое Statement, PreparedStatement? В чем разница между ними?](#25-Что-такое-Statement-PreparedStatement-В-чем-разница-между-ними)

[26. Что такое ResultSet?](#26-Что-такое-ResultSet)

[27. В чем разница между методами execute, executeUpdate, executeQuery?](#27-В-чем-разница-между-методами-execute-executeUpdate-executeQuery)

[28. Можно ли использовать возвращаемое значение метода execute для проверки, что что-то обновилось?](#28-Можно-ли-использовать-возвращаемое-значение-метода-execute-для-проверки-что-что-то-обновилось)

[29. Как получить при вставке сгенерированные ключи? Как это сделать на чистом sql?](#29-Как-получить-при-вставке-сгенерированные-ключи-Как-это-сделать-на-чистом-sql)

[30. Для чего используется конструкция try-with-resources?](#30-Для-чего-используется-конструкция-try-with-resources)

# 1. Что такое SQL?

SQL (Structured Query Language) — это язык структурированных запросов, используемый для работы с базами данных. Он предназначен для управления и манипулирования данными в реляционных базах данных (RDBMS), таких как MySQL, PostgreSQL, Oracle, SQL Server и другие.
#### Основные задачи SQL
+ Запрос данных — получение информации из базы данных с помощью SELECT.
+  Вставка данных — добавление новых записей в таблицы базы данных с помощью INSERT.
+  Обновление данных — изменение существующих данных в таблицах с помощью UPDATE.
+  Удаление данных — удаление записей из таблиц с помощью DELETE.
+  Создание структур — создание новых таблиц, баз данных, индексов и других объектов с помощью CREATE.
+  Изменение структур — модификация существующих объектов базы данных с помощью ALTER.
+ Удаление структур — удаление объектов базы данных с помощью DROP.
+  Управление доступом — предоставление или ограничение доступа к базе данных с помощью GRANT и REVOKE.

[К оглавлению](#SQL)

# 2. Что такое DML и DDL?

`DML (Data Manipulation Language)` — запросы для изменения данных:
+ INSERT — добавляет данные в таблицу.
+ UPDATE — обновляет данные.
+ DELETE — удаляет данные.

`DDL (Data Definition Language)` — команды для работы со структурой базы данных:
+ CREATE — создает новые объекты, такие как таблицы или базы данных.
+ ALTER — изменяет структуру существующих объектов.
+ DROP — удаляет объекты, такие как таблицы или базы данных.
+ TRUNCATE — удаляет все записи из таблицы, но сохраняет структуру.

`DCL (Data Control Language)` — управление доступом к данным:
+ GRANT — предоставляет права пользователю или роли.
+ REVOKE — отзывает права у пользователя или роли.

`TCL (Transaction Control Language`) — команды для управления транзакциями:
+ COMMIT — фиксирует изменения в базе данных.
+ ROLLBACK — отменяет изменения, если что-то пошло не так.
+ SAVEPOINT устанавливает точку сохранения внутри транзакции для возможного отката.

[К оглавлению](#SQL)

# 3. Что такое первичный ключ?
Первичный ключ (Primary Key) — это специальное ограничение в реляционных базах данных, которое обозначает уникальный идентификатор каждой записи (строки) в таблице. Первичный ключ гарантирует, что значения в этом столбце (или наборе столбцов) будут уникальными и не будут пустыми (NULL).
#### Зачем нужен первичный ключ?
+ Уникальность: Первичный ключ обеспечивает уникальность каждой записи в таблице, что позволяет легко отличать одну запись от другой.
+ Целостность данных: Значения первичного ключа не могут быть NULL. Это гарантирует, что каждая запись будет иметь уникальный идентификатор.
+ Производительность: Первичный ключ часто используется базой данных для оптимизации поиска данных. Он обычно связан с индексом, что ускоряет операции чтения.
+ Связи между таблицами: Первичный ключ используется для создания связей между таблицами через внешний ключ (Foreign Key), что позволяет строить реляционные структуры и обеспечивать целостность данных.
#### Правила и ограничения первичного ключа
+ Значение должно быть уникальным в пределах таблицы.
+ Значение не может быть NULL.
+ В таблице может быть только один первичный ключ, но он может состоять из нескольких столбцов (так называемый составной первичный ключ).
```java
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,  -- user_id является первичным ключом
    name VARCHAR(100),
    email VARCHAR(100) UNIQUE,
    registration_date DATE
);

В этом примере user_id — это первичный ключ. Он уникален для каждой строки, 
и каждая запись будет иметь свое уникальное значение в этом столбце.
```
#### Составной первичный ключ
В некоторых случаях требуется использовать несколько столбцов для уникальной идентификации строки. В таких ситуациях создают составной первичный ключ:
```java
CREATE TABLE orders (
    order_id INT,
    product_id INT,
    order_date DATE,
    PRIMARY KEY (order_id, product_id)  -- Составной первичный ключ
);
Здесь уникальной записью будет комбинация значений order_id и product_id. Это означает, 
что в одной и той же таблице могут быть несколько записей с одинаковым order_id, 
но они должны отличаться по product_id.
```
#### Преимущества использования первичного ключа
+ Упрощение поиска: Благодаря индексации, поиск по первичному ключу выполняется очень быстро.
+  Защита данных: Первичный ключ предотвращает дублирование данных.
 + Связи между таблицами: Позволяет создавать реляционные связи между таблицами через внешний ключ.

[К оглавлению](#SQL)

# 4. Что такое внешний ключ?
Внешний ключ (Foreign Key) —  это механизм, который помогает поддерживать структурные связи между таблицами в реляционных базах данных и гарантировать целостность данных. Он связывает данные между таблицами, предоставляя надежный способ управления связями и предотвращая ошибки, связанные с некорректными ссылками.
#### Зачем нужен внешний ключ?
+ Обеспечение целостности данных: Внешний ключ гарантирует, что значение в одной таблице (таблице-потомке) должно соответствовать существующему значению в другой таблице (таблице-родителе).
+ Связи между таблицами: Внешние ключи позволяют установить связи между таблицами, что помогает строить сложные реляционные структуры.
+ Поддержка ссылочной целостности: Внешний ключ обеспечивает автоматическую проверку данных, предотвращая удаление или изменение записей в родительской таблице, если они используются в таблице-потомке.
```java
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);

CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    order_date DATE NOT NULL,
    customer_id INT,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);

customer_id в таблице customers — это первичный ключ.
customer_id в таблице orders — это внешний ключ, 
который ссылается на customer_id в таблице customers.
```
#### Правила и ограничения внешнего ключа
+ Ссылочная целостность: Значение внешнего ключа в таблице-потомке должно соответствовать существующему значению первичного ключа в таблице-родителе, или быть NULL.
+ Удаление и обновление: При удалении или обновлении строки в таблице-родителе можно использовать каскадные операции, чтобы изменения автоматически отражались в таблице-потомке.

#### Каскадные операции
При использовании внешних ключей можно настроить каскадные операции для управления связанными данными:
+ ON DELETE CASCADE: Если запись в родительской таблице удаляется, все связанные записи в таблице-потомке также будут удалены.
```java
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    order_date DATE NOT NULL,
    customer_id INT,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id) ON DELETE CASCADE
);
```
ON UPDATE CASCADE: Если значение первичного ключа в родительской таблице обновляется, связанные значения во внешнем ключе также обновляются.
```java
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    order_date DATE NOT NULL,
    customer_id INT,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id) ON UPDATE CASCADE
);
```
```java
Пример использования внешнего ключа с каскадными операциями

CREATE TABLE departments (
        department_id SERIAL PRIMARY KEY,
        name VARCHAR(100)
);

CREATE TABLE employees (
        employee_id SERIAL PRIMARY KEY,
        name VARCHAR(100),
department_id INT,
FOREIGN KEY (department_id) REFERENCES departments(department_id) ON DELETE SET NULL
);

Если удалить запись из таблицы departments, то в таблице employees поле department_id 
для связанных сотрудников будет установлено в NULL, благодаря ON DELETE SET NULL.
```
#### Преимущества использования внешнего ключа
+ Поддержка целостности данных: Внешний ключ предотвращает несогласованные изменения данных, такие как удаление записи, на которую есть ссылки.
+ Упрощение связей между таблицами: Использование внешних ключей позволяет строить сложные реляционные связи между таблицами.
+ Автоматизация действий: Каскадные операции позволяют автоматизировать удаление или обновление данных, связанные с родительскими записями.

[К оглавлению](#SQL)

# 5. Какие виды связей между таблицами существуют и как они организуются?
Связи между таблицами в реляционных базах данных позволяют организовать структуру данных и поддерживать целостность. Основные виды связей включают один к одному, один ко многим, многие ко многим, и каждая из них имеет свои особенности и способы организации.
1. Один к одному (One-to-One) Это связь, при которой одной записи в одной таблице соответствует ровно одна запись в другой таблице.
+ Чаще всего связь "один к одному" реализуется с помощью внешнего ключа в одной из таблиц, который также является первичным ключом.
+ Можно использовать одну таблицу для хранения данных, но иногда данные разделяют для лучшей организации или безопасности.
```java
Представим, что есть таблица users (пользователи) и таблица user_profiles 
(профили пользователей),где каждому пользователю соответствует один профиль

CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(100) NOT NULL
);

CREATE TABLE user_profiles (
    profile_id SERIAL PRIMARY KEY,
    user_id INT UNIQUE,
    bio TEXT,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

Здесь user_id в таблице user_profiles — это внешний ключ, к
оторый также уникален, чтобы связь была "один к одному".
```
2. Один ко многим (One-to-Many) Это наиболее распространённая связь, при которой одной записи в одной таблице соответствует несколько записей в другой таблице.
+ Реализуется с помощью внешнего ключа в дочерней таблице (таблица, содержащая много записей).
+ Обычный пример — связь между таблицей категорий и таблицей товаров, где каждой категории соответствует несколько товаров.
```java
CREATE TABLE categories (
    category_id SERIAL PRIMARY KEY,
    category_name VARCHAR(100) NOT NULL
);

CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL,
    category_id INT,
    FOREIGN KEY (category_id) REFERENCES categories(category_id)
);

Здесь category_id в таблице products — внешний ключ, 
который связывает продукты с категориями.
```
3. Многие ко многим (Many-to-Many) Это связь, при которой нескольким записям в одной таблице соответствуют несколько записей в другой таблице.
+ Реализуется через связующую таблицу (или промежуточную таблицу), которая содержит внешние ключи на обе связанные таблицы.
+ В связующей таблице каждая комбинация внешних ключей описывает связь между двумя записями.
```java
Представим, что у нас есть таблицы students (студенты) и courses (курсы), 
и каждый студент может посещать несколько курсов, 
а каждый курс может иметь несколько студентов

CREATE TABLE students (
    student_id SERIAL PRIMARY KEY,
    student_name VARCHAR(100) NOT NULL
);

CREATE TABLE courses (
    course_id SERIAL PRIMARY KEY,
    course_name VARCHAR(100) NOT NULL
);

CREATE TABLE student_courses (
    student_id INT,
    course_id INT,
    PRIMARY KEY (student_id, course_id),
    FOREIGN KEY (student_id) REFERENCES students(student_id),
    FOREIGN KEY (course_id) REFERENCES courses(course_id)
);

Здесь student_courses — это связующая таблица, которая устанавливает 
связь "многие ко многим" между студентами и курсами.
```
4. Самосвязанная (Self-Referencing) связь. Иногда требуется установить связь внутри одной таблицы, например, для построения иерархий.
+ Используется внешний ключ, который ссылается на первичный ключ в той же таблице.
```java
Предположим, что у нас есть таблица employees (сотрудники), 
где каждый сотрудник может иметь начальника

CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    employee_name VARCHAR(100),
    manager_id INT,
    FOREIGN KEY (manager_id) REFERENCES employees(employee_id)
);

Здесь manager_id — это внешний ключ, который ссылается на employee_id 
в той же таблице, создавая связь между сотрудником и его начальником.
```
#### Сводная таблица: Типы связей и их особенности

| Тип связи              | Пример                    | Организация                                                                  | Характеристики                                                                                                                                                                   |
|------------------------|---------------------------|------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Один к одному          | Пользователь и профиль    | Внешний ключ в одной таблице, уникальный для каждой записи                   | Каждой записи в одной таблице соответствует ровно одна запись в другой. Используется для данных, которые можно разделить на отдельные категории.                                 |
| Один ко многим         | Категория и товары        | Внешний ключ в дочерней таблице                                              | Каждой записи в родительской таблице соответствует несколько записей в дочерней. Самая распространённая связь для организации связанных данных.                                  |
| Многие ко многим       | Студенты и курсы          | Промежуточная таблица с внешними ключами на обе связанные таблицы            | Несколько записей в одной таблице могут быть связаны с несколькими записями в другой. Используется для сложных связей, таких как объединение студентов и курсов, книг и авторов. |
| Самосвязанная          | Сотрудники и начальники   | Внешний ключ в таблице, который ссылается на первичный ключ в той же таблице | Используется для построения иерархических структур, таких как дерево категорий, сотрудники и начальники. Позволяет хранить иерархические отношения внутри одной таблицы.         |


[К оглавлению](#SQL)

# 6. Опишите как вставить, удалить, обновить данные в, из таблицы.

[К оглавлению](#SQL)

# 7. Что такое нормализация БД?

[К оглавлению](#SQL)

# 8. Что такое денормализация БД? Для чего она нужна?

[К оглавлению](#SQL)

# 9. Что такое кластерный и некластерный индексы?

[К оглавлению](#SQL)

# 10. Какие типы соединений join таблиц существуют? В чем их разница?

[К оглавлению](#SQL)

# 11. Что такое SQL курсор?

[К оглавлению](#SQL)

# 12. Опишите шаги по созданию и использованию курсора.

[К оглавлению](#SQL)

# 13. Что такое транзакция?

[К оглавлению](#SQL)

# 14. Что такое триггер? Какие типы триггеров Вы знаете?

[К оглавлению](#SQL)

# 15. В чем разница между where и having?

[К оглавлению](#SQL)

# 16. Что такое подзапрос sub-query?

[К оглавлению](#SQL)

# 17. Что такое union?

[К оглавлению](#SQL)

# 18. Что такое group by?

[К оглавлению](#SQL)

# 19. Что такое хранимые процедуры?

[К оглавлению](#SQL)

# 20. Что такое view представление?

[К оглавлению](#SQL)

# 21. Что такое JDBC?

[К оглавлению](#SQL)

# 22. Что нужно для работы с той или иной БД?

[К оглавлению](#SQL)

# 23. Как зарегистрировать драйвер?

[К оглавлению](#SQL)

# 24. Как получить Connection?

[К оглавлению](#SQL)

# 25. Что такое Statement, PreparedStatement? В чем разница между ними?

[К оглавлению](#SQL)

# 26. Что такое ResultSet?

[К оглавлению](#SQL)

# 27. В чем разница между методами execute, executeUpdate, executeQuery?

[К оглавлению](#SQL)

# 28. Можно ли использовать возвращаемое значение метода execute для проверки, что что-то обновилось?

[К оглавлению](#SQL)

# 29. Как получить при вставке сгенерированные ключи? Как это сделать на чистом sql?

[К оглавлению](#SQL)

# 30. Для чего используется конструкция try-with-resources?

[К оглавлению](#SQL)

