## SQL

[1. Что такое SQL?](#1-Что-такое-SQL)

[2. Что такое DML и DDL?](#2-Что-такое-DML-и-DDL)

[3. Что такое первичный ключ?](#3-Что-такое-первичный-ключ)

[4. Что такое внешний ключ?](#4-Что-такое-внешний-ключ)

[5. Какие виды связей между таблицами существуют и как они организуются?](#5-Какие-виды-связей-между-таблицами-существуют-и-как-они-организуются)

[6. Опишите как вставить, удалить, обновить данные в, из таблицы.](#6-опишите-как-вставить-удалить-обновить-данные-в-из-таблицы)

[7. Что такое нормализация БД?](#7-Что-такое-нормализация-БД)

[8. Что такое денормализация БД? Для чего она нужна?](#8-Что-такое-денормализация-БД-Для-чего-она-нужна)

[9. Что такое кластерный и некластерный индексы?](#9-Что-такое-кластерный-и-некластерный-индексы)

[10. Какие типы соединений join таблиц существуют? В чем их разница?](#10-Какие-типы-соединений-join-таблиц-существуют-В-чем-их-разница)

[11. Что такое SQL курсор?](#11-Что-такое-SQL-курсор)

[12. Опишите шаги по созданию и использованию курсора.](#12-Опишите-шаги-по-созданию-и-использованию-курсора)

[13. Что такое транзакция?](#13-Что-такое-транзакция)

[14. Что такое триггер? Какие типы триггеров Вы знаете?](#14-Что-такое-триггер-Какие-типы-триггеров-Вы-знаете)

[15. В чем разница между where и having?](#15-В-чем-разница-между-where-и-having)

[16. Что такое подзапрос sub-query?](#16-Что-такое-подзапрос-sub-query)

[17. Что такое union?](#17-Что-такое-union)

[18. Что такое group by?](#18-Что-такое-group-by)

[19. Что такое хранимые процедуры?](#19-Что-такое-хранимые-процедуры)

[20. Что такое view представление?](#20-Что-такое-view-представление)

[21. Что такое JDBC?](#21-Что-такое-JDBC)

[22. Что нужно для работы с той или иной БД?](#22-Что-нужно-для-работы-с-той-или-иной-БД)

[23. Как зарегистрировать драйвер?](#23-Как-зарегистрировать-драйвер)

[24. Как получить Connection?](#24-Как-получить-Connection)

[25. Что такое Statement, PreparedStatement? В чем разница между ними?](#25-Что-такое-Statement-PreparedStatement-В-чем-разница-между-ними)

[26. Что такое ResultSet?](#26-Что-такое-ResultSet)

[27. В чем разница между методами execute, executeUpdate, executeQuery?](#27-В-чем-разница-между-методами-execute-executeUpdate-executeQuery)

[28. Можно ли использовать возвращаемое значение метода execute для проверки, что что-то обновилось?](#28-Можно-ли-использовать-возвращаемое-значение-метода-execute-для-проверки-что-что-то-обновилось)

[29. Как получить при вставке сгенерированные ключи? Как это сделать на чистом sql?](#29-Как-получить-при-вставке-сгенерированные-ключи-Как-это-сделать-на-чистом-sql)

[30. Для чего используется конструкция try-with-resources?](#30-Для-чего-используется-конструкция-try-with-resources)

# 1. Что такое SQL?

SQL (Structured Query Language) — это язык структурированных запросов, используемый для работы с базами данных. Он предназначен для управления и манипулирования данными в реляционных базах данных (RDBMS), таких как MySQL, PostgreSQL, Oracle, SQL Server и другие.
#### Основные задачи SQL
+ Запрос данных — получение информации из базы данных с помощью SELECT.
+  Вставка данных — добавление новых записей в таблицы базы данных с помощью INSERT.
+  Обновление данных — изменение существующих данных в таблицах с помощью UPDATE.
+  Удаление данных — удаление записей из таблиц с помощью DELETE.
+  Создание структур — создание новых таблиц, баз данных, индексов и других объектов с помощью CREATE.
+  Изменение структур — модификация существующих объектов базы данных с помощью ALTER.
+ Удаление структур — удаление объектов базы данных с помощью DROP.
+  Управление доступом — предоставление или ограничение доступа к базе данных с помощью GRANT и REVOKE.

[К оглавлению](#SQL)

# 2. Что такое DML и DDL?

`DML (Data Manipulation Language)` — запросы для изменения данных:
+ INSERT — добавляет данные в таблицу.
+ UPDATE — обновляет данные.
+ DELETE — удаляет данные.

`DDL (Data Definition Language)` — команды для работы со структурой базы данных:
+ CREATE — создает новые объекты, такие как таблицы или базы данных.
+ ALTER — изменяет структуру существующих объектов.
+ DROP — удаляет объекты, такие как таблицы или базы данных.
+ TRUNCATE — удаляет все записи из таблицы, но сохраняет структуру.

`DCL (Data Control Language)` — управление доступом к данным:
+ GRANT — предоставляет права пользователю или роли.
+ REVOKE — отзывает права у пользователя или роли.

`TCL (Transaction Control Language`) — команды для управления транзакциями:
+ COMMIT — фиксирует изменения в базе данных.
+ ROLLBACK — отменяет изменения, если что-то пошло не так.
+ SAVEPOINT устанавливает точку сохранения внутри транзакции для возможного отката.

[К оглавлению](#SQL)

# 3. Что такое первичный ключ?
Первичный ключ (Primary Key) — это специальное ограничение в реляционных базах данных, которое обозначает уникальный идентификатор каждой записи (строки) в таблице. Первичный ключ гарантирует, что значения в этом столбце (или наборе столбцов) будут уникальными и не будут пустыми (NULL).
#### Зачем нужен первичный ключ?
+ Уникальность: Первичный ключ обеспечивает уникальность каждой записи в таблице, что позволяет легко отличать одну запись от другой.
+ Целостность данных: Значения первичного ключа не могут быть NULL. Это гарантирует, что каждая запись будет иметь уникальный идентификатор.
+ Производительность: Первичный ключ часто используется базой данных для оптимизации поиска данных. Он обычно связан с индексом, что ускоряет операции чтения.
+ Связи между таблицами: Первичный ключ используется для создания связей между таблицами через внешний ключ (Foreign Key), что позволяет строить реляционные структуры и обеспечивать целостность данных.
#### Правила и ограничения первичного ключа
+ Значение должно быть уникальным в пределах таблицы.
+ Значение не может быть NULL.
+ В таблице может быть только один первичный ключ, но он может состоять из нескольких столбцов (так называемый составной первичный ключ).
```java
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,  -- user_id является первичным ключом
    name VARCHAR(100),
    email VARCHAR(100) UNIQUE,
    registration_date DATE
);

В этом примере user_id — это первичный ключ. Он уникален для каждой строки, 
и каждая запись будет иметь свое уникальное значение в этом столбце.
```
#### Составной первичный ключ
В некоторых случаях требуется использовать несколько столбцов для уникальной идентификации строки. В таких ситуациях создают составной первичный ключ:
```java
CREATE TABLE orders (
    order_id INT,
    product_id INT,
    order_date DATE,
    PRIMARY KEY (order_id, product_id)  -- Составной первичный ключ
);
Здесь уникальной записью будет комбинация значений order_id и product_id. Это означает, 
что в одной и той же таблице могут быть несколько записей с одинаковым order_id, 
но они должны отличаться по product_id.
```
#### Преимущества использования первичного ключа
+ Упрощение поиска: Благодаря индексации, поиск по первичному ключу выполняется очень быстро.
+  Защита данных: Первичный ключ предотвращает дублирование данных.
 + Связи между таблицами: Позволяет создавать реляционные связи между таблицами через внешний ключ.

[К оглавлению](#SQL)

# 4. Что такое внешний ключ?
Внешний ключ (Foreign Key) —  это механизм, который помогает поддерживать структурные связи между таблицами в реляционных базах данных и гарантировать целостность данных. Он связывает данные между таблицами, предоставляя надежный способ управления связями и предотвращая ошибки, связанные с некорректными ссылками.
#### Зачем нужен внешний ключ?
+ Обеспечение целостности данных: Внешний ключ гарантирует, что значение в одной таблице (таблице-потомке) должно соответствовать существующему значению в другой таблице (таблице-родителе).
+ Связи между таблицами: Внешние ключи позволяют установить связи между таблицами, что помогает строить сложные реляционные структуры.
+ Поддержка ссылочной целостности: Внешний ключ обеспечивает автоматическую проверку данных, предотвращая удаление или изменение записей в родительской таблице, если они используются в таблице-потомке.
```java
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);

CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    order_date DATE NOT NULL,
    customer_id INT,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);

customer_id в таблице customers — это первичный ключ.
customer_id в таблице orders — это внешний ключ, 
который ссылается на customer_id в таблице customers.
```
#### Правила и ограничения внешнего ключа
+ Ссылочная целостность: Значение внешнего ключа в таблице-потомке должно соответствовать существующему значению первичного ключа в таблице-родителе, или быть NULL.
+ Удаление и обновление: При удалении или обновлении строки в таблице-родителе можно использовать каскадные операции, чтобы изменения автоматически отражались в таблице-потомке.

#### Каскадные операции
При использовании внешних ключей можно настроить каскадные операции для управления связанными данными:
+ ON DELETE CASCADE: Если запись в родительской таблице удаляется, все связанные записи в таблице-потомке также будут удалены.
```java
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    order_date DATE NOT NULL,
    customer_id INT,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id) ON DELETE CASCADE
);
```
ON UPDATE CASCADE: Если значение первичного ключа в родительской таблице обновляется, связанные значения во внешнем ключе также обновляются.
```java
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    order_date DATE NOT NULL,
    customer_id INT,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id) ON UPDATE CASCADE
);
```
```java
Пример использования внешнего ключа с каскадными операциями

CREATE TABLE departments (
        department_id SERIAL PRIMARY KEY,
        name VARCHAR(100)
);

CREATE TABLE employees (
        employee_id SERIAL PRIMARY KEY,
        name VARCHAR(100),
department_id INT,
FOREIGN KEY (department_id) REFERENCES departments(department_id) ON DELETE SET NULL
);

Если удалить запись из таблицы departments, то в таблице employees поле department_id 
для связанных сотрудников будет установлено в NULL, благодаря ON DELETE SET NULL.
```
#### Преимущества использования внешнего ключа
+ Поддержка целостности данных: Внешний ключ предотвращает несогласованные изменения данных, такие как удаление записи, на которую есть ссылки.
+ Упрощение связей между таблицами: Использование внешних ключей позволяет строить сложные реляционные связи между таблицами.
+ Автоматизация действий: Каскадные операции позволяют автоматизировать удаление или обновление данных, связанные с родительскими записями.

[К оглавлению](#SQL)

# 5. Какие виды связей между таблицами существуют и как они организуются?
Связи между таблицами в реляционных базах данных позволяют организовать структуру данных и поддерживать целостность. Основные виды связей включают один к одному, один ко многим, многие ко многим, и каждая из них имеет свои особенности и способы организации.
1. Один к одному (One-to-One) Это связь, при которой одной записи в одной таблице соответствует ровно одна запись в другой таблице.
+ Чаще всего связь "один к одному" реализуется с помощью внешнего ключа в одной из таблиц, который также является первичным ключом.
+ Можно использовать одну таблицу для хранения данных, но иногда данные разделяют для лучшей организации или безопасности.
```java
Представим, что есть таблица users (пользователи) и таблица user_profiles 
(профили пользователей),где каждому пользователю соответствует один профиль

CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(100) NOT NULL
);

CREATE TABLE user_profiles (
    profile_id SERIAL PRIMARY KEY,
    user_id INT UNIQUE,
    bio TEXT,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

Здесь user_id в таблице user_profiles — это внешний ключ, к
оторый также уникален, чтобы связь была "один к одному".
```
2. Один ко многим (One-to-Many) Это наиболее распространённая связь, при которой одной записи в одной таблице соответствует несколько записей в другой таблице.
+ Реализуется с помощью внешнего ключа в дочерней таблице (таблица, содержащая много записей).
+ Обычный пример — связь между таблицей категорий и таблицей товаров, где каждой категории соответствует несколько товаров.
```java
CREATE TABLE categories (
    category_id SERIAL PRIMARY KEY,
    category_name VARCHAR(100) NOT NULL
);

CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL,
    category_id INT,
    FOREIGN KEY (category_id) REFERENCES categories(category_id)
);

Здесь category_id в таблице products — внешний ключ, 
который связывает продукты с категориями.
```
3. Многие ко многим (Many-to-Many) Это связь, при которой нескольким записям в одной таблице соответствуют несколько записей в другой таблице.
+ Реализуется через связующую таблицу (или промежуточную таблицу), которая содержит внешние ключи на обе связанные таблицы.
+ В связующей таблице каждая комбинация внешних ключей описывает связь между двумя записями.
```java
Представим, что у нас есть таблицы students (студенты) и courses (курсы), 
и каждый студент может посещать несколько курсов, 
а каждый курс может иметь несколько студентов

CREATE TABLE students (
    student_id SERIAL PRIMARY KEY,
    student_name VARCHAR(100) NOT NULL
);

CREATE TABLE courses (
    course_id SERIAL PRIMARY KEY,
    course_name VARCHAR(100) NOT NULL
);

CREATE TABLE student_courses (
    student_id INT,
    course_id INT,
    PRIMARY KEY (student_id, course_id),
    FOREIGN KEY (student_id) REFERENCES students(student_id),
    FOREIGN KEY (course_id) REFERENCES courses(course_id)
);

Здесь student_courses — это связующая таблица, которая устанавливает 
связь "многие ко многим" между студентами и курсами.
```
4. Самосвязанная (Self-Referencing) связь. Иногда требуется установить связь внутри одной таблицы, например, для построения иерархий.
+ Используется внешний ключ, который ссылается на первичный ключ в той же таблице.
```java
Предположим, что у нас есть таблица employees (сотрудники), 
где каждый сотрудник может иметь начальника

CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    employee_name VARCHAR(100),
    manager_id INT,
    FOREIGN KEY (manager_id) REFERENCES employees(employee_id)
);

Здесь manager_id — это внешний ключ, который ссылается на employee_id 
в той же таблице, создавая связь между сотрудником и его начальником.
```
#### Сводная таблица: Типы связей и их особенности

| Тип связи              | Пример                    | Организация                                                                  | Характеристики                                                                                                                                                                   |
|------------------------|---------------------------|------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Один к одному          | Пользователь и профиль    | Внешний ключ в одной таблице, уникальный для каждой записи                   | Каждой записи в одной таблице соответствует ровно одна запись в другой. Используется для данных, которые можно разделить на отдельные категории.                                 |
| Один ко многим         | Категория и товары        | Внешний ключ в дочерней таблице                                              | Каждой записи в родительской таблице соответствует несколько записей в дочерней. Самая распространённая связь для организации связанных данных.                                  |
| Многие ко многим       | Студенты и курсы          | Промежуточная таблица с внешними ключами на обе связанные таблицы            | Несколько записей в одной таблице могут быть связаны с несколькими записями в другой. Используется для сложных связей, таких как объединение студентов и курсов, книг и авторов. |
| Самосвязанная          | Сотрудники и начальники   | Внешний ключ в таблице, который ссылается на первичный ключ в той же таблице | Используется для построения иерархических структур, таких как дерево категорий, сотрудники и начальники. Позволяет хранить иерархические отношения внутри одной таблицы.         |

[К оглавлению](#SQL)

# 6. Опишите как вставить, удалить, обновить данные в, из таблицы.
1. Вставка данных в таблицу (INSERT INTO)
```java
INSERT INTO table_name (column1, column2, column3)
VALUES (value1, value2, value3);


Вставка нескольких записей:

INSERT INTO table_name (column1, column2, column3)
VALUES
(value1_1, value1_2, value1_3),
(value2_1, value2_2, value2_3),
(value3_1, value3_2, value3_3);

```
2. Удаление данных из таблицы (DELETE FROM)
```java
Удаление с условием:

DELETE FROM table_name
WHERE condition;

Удаление всех записей:

DELETE FROM table_name;

Удалим всех сотрудников из департамента HR:

DELETE FROM employees
WHERE department = 'HR';
```
3. Обновление данных в таблице (UPDATE)
```java
Обновление с условием:

UPDATE table_name
SET column1 = value1, column2 = value2
WHERE condition;


Обновление всех записей:

UPDATE table_name
SET column1 = value1, column2 = value2;

Обновим департамент всех сотрудников с фамилией 'Doe' на IT:

UPDATE employees
SET department = 'IT'
WHERE last_name = 'Doe';
```
| Операция                | SQL-команда     | Примерный синтаксис                                                |
|-------------------------|-----------------|--------------------------------------------------------------------|
| Вставка                 | INSERT INTO     | INSERT INTO table_name (column1, column2) VALUES (value1, value2); |
| Удаление                | DELETE FROM     | DELETE FROM table_name WHERE condition;                            |
| Обновление              | UPDATE          | UPDATE table_name SET column1 = value1 WHERE condition;            |
#### Нюансы.
+ Если у таблицы есть поле, которое автоматически увеличивается (например, SERIAL в PostgreSQL или AUTO_INCREMENT в MySQL), то его можно пропустить при вставке
```java
INSERT INTO employees (first_name, last_name, department)
VALUES ('Jane', 'Smith', 'Finance');

employee_id будет автоматически присвоено
```
+ Если требуется удалить все записи из таблицы, лучше использовать команду TRUNCATE, так как она более эффективна и быстрее освобождает ресурсы
```java
TRUNCATE TABLE table_name;
```
+ Чтобы избежать случайных изменений всех записей в таблице, рекомендуется всегда использовать условия (WHERE) при операциях DELETE и UPDATE.
```java
DELETE FROM employees WHERE employee_id = 10;
UPDATE employees SET department = 'Sales' WHERE department = 'Marketing';
```
+ Для критически важных операций, таких как массовые обновления или удаления, лучше использовать транзакции
```java
BEGIN;

-- Операции вставки, удаления или обновления
UPDATE employees SET department = 'Support' WHERE department = 'Customer Service';

COMMIT;

Если что идет не так - отменям транзакцию:

ROLLBACK;

Транзакции помогают обеспечить целостность данных, особенно в случаях, 
когда операции включают несколько связанных изменений.
```

[К оглавлению](#SQL)

# 7. Что такое нормализация БД?
Нормализация базы данных — это процесс организации данных в таблицах базы данных с целью минимизации избыточности данных и улучшения их целостности. Она включает в себя разделение данных на отдельные связанные таблицы и определение правильных связей между ними. Основная цель нормализации — устранить аномалии вставки, обновления и удаления данных.

#### Зачем нужна нормализация?
+ Избегание дублирования данных — уменьшение избыточности помогает уменьшить количество ошибок и объем хранимых данных.
+ Повышение целостности данных — снижение риска несоответствий в данных и улучшение качества информации.
+ Упрощение поддержки и изменения данных — проще обновлять и расширять структуру данных.
+ Оптимизация использования памяти — экономия ресурсов за счет хранения данных в более компактной форме.
#### Формы нормализации.
+ Первая нормальная форма (1NF)
Каждое поле должно содержать только одно значение, а таблица не должна иметь повторяющихся групп.

Требования: Каждая ячейка таблицы содержит только одно значение.
Все строки таблицы должны быть уникальными.
+ Вторая нормальная форма (2NF) Таблица должна быть в 1NF, и все неключевые поля должны зависеть от первичного ключа целиком.

Требования: Устранить частичные зависимости (когда часть составного ключа определяет атрибут).
Если есть составной ключ, неключевые атрибуты должны зависеть от всех частей ключа. 

Пример: Если у нас есть таблица orders, в которой составной первичный ключ состоит из order_id и product_id, но поле product_name зависит только от product_id, нужно вынести информацию о продуктах в отдельную таблицу.
```java
-- Таблица клиентов
        
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    customer_name TEXT,
    customer_phone TEXT
);

-- Таблица продуктов
        
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_name TEXT,
    product_price NUMERIC
);

-- Таблица заказов
        
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES customers(customer_id),
    product_id INT REFERENCES products(product_id),
    quantity INT
);

```
+ Третья нормальная форма (3NF) Таблица должна быть в 2NF, и все неключевые поля должны зависеть только от первичного ключа и не иметь транзитивных зависимостей.

Требования: Устранить транзитивные зависимости (когда одно поле зависит от другого неключевого поля, которое, в свою очередь, зависит от первичного ключа).

Пример: Допустим, мы добавим колонку customer_city в таблицу customers. Если город клиентов зависит от номера телефона, но не от первичного ключа (customer_id), это нарушает 3NF.
```java
Выделяем зависимость customer_phone → customer_city в отдельную таблицу.

        -- Таблица городов клиентов
CREATE TABLE customer_cities (
        phone TEXT PRIMARY KEY,
        city TEXT
);

-- Обновляем таблицу customers
CREATE TABLE customers (
        customer_id SERIAL PRIMARY KEY,
        customer_name TEXT,
        customer_phone TEXT REFERENCES customer_cities(phone)
);

если телефон изменится, город автоматически обновится через связь.
```

[К оглавлению](#SQL)

# 8. Что такое денормализация БД? Для чего она нужна?
Денормализация базы данных — это процесс обратный нормализации, который предполагает намеренное добавление избыточности данных для улучшения производительности чтения. Денормализация используется, чтобы уменьшить количество сложных операций JOIN и ускорить выполнение запросов, особенно когда приоритетом является скорость чтения, а не экономия места.
#### Зачем нужна денормализация?
+ Ускорение чтения данных — уменьшение количества JOIN операций между таблицами, которые могут быть медленными на больших объемах данных.
+ Упрощение запросов — денормализованные данные позволяют составлять более простые и быстрые запросы.
+ Оптимизация для аналитики — в аналитических и отчетных системах важнее быстрее извлекать данные, чем экономить место.
#### Преимущества денормализации
+ Ускорение выборки — уменьшение количества операций JOIN делает запросы быстрее, особенно если данные часто читаются.
+ Упрощение аналитических запросов — доступ к нужным данным напрямую упрощает создание отчетов.
+ Снижение нагрузки на базу — меньшее количество сложных запросов уменьшает нагрузку на сервер базы данных.
#### Недостатки денормализации
+ Избыточность данных — при денормализации те же данные могут храниться в нескольких местах, что увеличивает объем базы данных.
+ Риск несогласованности данных — изменение данных в одном месте требует их обновления во всех местах, что увеличивает риск ошибок.
+ Усложнение операций записи — при изменении данных нужно обновлять несколько таблиц, что может замедлить вставку и обновление.
#### Когда стоит использовать денормализацию?
+ Большие объемы данных — когда база данных содержит миллионы записей, JOIN операции могут замедлить выполнение запросов.
+ Чтение важнее записи — если система ориентирована на чтение данных (например, отчетные и аналитические системы), денормализация может помочь.
+ Отсутствие сложных транзакций — если база данных редко изменяется и не требует частых обновлений, денормализация оправдана.
+ Необходимость в real-time отчетах — в системах, где важно быстро получать аналитические данные, денормализация может упростить жизнь.
#### Баланс между нормализацией и денормализацией
+ Нормализация: хороша для сохранения целостности данных, устранения избыточности и экономии памяти.
+ Денормализация: подходит для случаев, когда требуется высокая скорость чтения, особенно при работе с большими объемами данных.
#### Примеры денормализации в реальной жизни
+ Аналитические базы данных — данные часто денормализуются для отчетов и аналитики, чтобы быстро создавать сводки и отчеты.
+ Кэширование данных — если данные редко меняются, их можно сохранить в денормализованной форме в кэше для ускорения доступа.
+ Системы рекомендаций — в системах, где требуется быстрое агрегирование информации, данные могут быть денормализованы для упрощения получения рекомендаций.
```java
Клиенты:
CREATE TABLE customers (
customer_id SERIAL PRIMARY KEY,
customer_name TEXT,
customer_phone TEXT
);

Продукты:
CREATE TABLE products (
product_id SERIAL PRIMARY KEY,
product_name TEXT,
product_price NUMERIC
);

Заказы:
CREATE TABLE orders (
order_id SERIAL PRIMARY KEY,
customer_id INT REFERENCES customers(customer_id),
product_id INT REFERENCES products(product_id),
quantity INT,
order_date DATE
);

Денормализированная база:
CREATE TABLE denormalized_orders (
        order_id SERIAL PRIMARY KEY,
        customer_name TEXT,
        customer_phone TEXT,
        product_name TEXT,
        product_price NUMERIC,
        quantity INT,
        total_price NUMERIC,
        order_date DATE
);

Пимер запроса:

С денормализованной таблицей:
SELECT customer_name, customer_phone, product_name, total_price, order_date
FROM denormalized_orders
WHERE order_date = '2024-11-27';

нормализованных таблиц:
SELECT c.customer_name, c.customer_phone, p.product_name, (p.product_price * o.quantity) AS total_price, o.order_date
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
JOIN products p ON o.product_id = p.product_id
WHERE o.order_date = '2024-11-27';
```
[К оглавлению](#SQL)

# 9. Что такое кластерный и некластерный индексы?
Кластерный и некластерный индексы — это два типа индексов, используемых в базах данных для ускорения операций поиска и повышения производительности запросов. Они оба влияют на способ хранения и доступа к данным, но различаются по структуре и применению.

1. Кластерный индекс (Clustered Index) определяет физический порядок строк в таблице на диске. Он действует как основная организация данных, поэтому таблица может иметь только один кластерный индекс.
+ Как работает: В таблице с кластерным индексом строки физически хранятся на диске в порядке, соответствующем значениям, по которым создан индекс. Это значит, что строки в таблице отсортированы по ключу кластерного индекса.
 
Пример: Если таблица содержит столбец id, который является кластерным индексом, то данные будут физически отсортированы на диске по значениям этого столбца.
+ Преимущества: Ускоряет доступ к данным при поиске по полю кластерного индекса.
Быстрый доступ к диапазонам данных, так как строки отсортированы.
+ Недостатки: Вставка новых данных может быть медленной, так как они должны вставляться в определенное место, чтобы поддерживать порядок.
Изменение значения кластерного ключа может привести к перемещению данных на диске.
+ Применение: Обычно используется для столбцов, которые часто используются для фильтрации или сортировки данных, например, первичный ключ (PRIMARY KEY), идентификаторы и даты.
```java
CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    employee_name TEXT,
    department_id INT
);
INSERT INTO employees (employee_name, department_id)
VALUES
        ('Иван Иванов', 2),
        ('Мария Смирнова', 1),
        ('Петр Петров', 3),
        ('Анна Васильева', 2),
        ('Сергей Козлов', 1);
Создаем индекс:
CREATE INDEX idx_department_id ON employees(department_id);
Делаем таблицу кластерной:
CLUSTER employees USING idx_department_id;
```
2. Некластерный индекс (Non-Clustered Index) создается отдельно от основного порядка хранения данных. Он содержит указатели на физическое расположение строк в таблице. Таблица может иметь несколько некластерных индексов.
+ Как работает: Некластерный индекс создаёт отдельную структуру, которая хранит значения индекса и ссылки на физическое расположение соответствующих строк в таблице. Данные в таблице не сортируются физически по этому индексу.

Пример: Если в таблице есть некластерный индекс по столбцу name, то создается структура, которая содержит все значения name в отсортированном виде с указателями на строки, где эти значения находятся.
+ Преимущества: Ускоряет поиск по полям, которые не являются частью кластерного индекса.
Можно иметь несколько некластерных индексов, что позволяет оптимизировать запросы под разные условия.
+ Недостатки: Некластерный индекс занимает дополнительное пространство на диске, так как хранит ссылки на данные.
Поиск по некластерному индексу может быть медленнее, чем по кластерному, так как требуется дополнительное обращение к таблице для получения данных.
+ Применение: Используется для столбцов, которые часто используются в WHERE, ORDER BY, GROUP BY запросах, но не для сортировки всей таблицы.
#### Когда использовать кластерный и некластерный индексы?
+ Кластерный индекс подходит, если нужно часто фильтровать или сортировать данные по ключу. Например, по дате или идентификатору.
+ Некластерный индекс полезен для оптимизации поиска по столбцам, которые не связаны с сортировкой всей таблицы.
```java
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_name TEXT,
    product_price NUMERIC
);
INSERT INTO products (product_name, product_price)
VALUES
        ('Хлеб', 50.00),
        ('Молоко', 70.00),
        ('Сыр', 250.00),
        ('Масло', 120.00),
        ('Яйца', 85.00);
Создаем некластерный индекс:
CREATE INDEX idx_product_price ON products(product_price);

Этот индекс ускоряет поиск по цене (product_price). 
Однако физический порядок строк в таблице не меняется.

        SELECT product_name, product_price
        FROM products
        WHERE product_price < 100;
PostgreSQL будет использовать idx_product_price для быстрого поиска строк с ценой ниже 100.
```
#### Основные отличия:
| Критерий                  | Кластерный индекс                                | Некластерный индекс                           |
|---------------------------|--------------------------------------------------|-----------------------------------------------|
| Порядок хранения данных   | Определяет физический порядок строк              | Не влияет на физический порядок данных        |
| Количество индексов       | Один на таблицу                                  | Несколько на таблицу                          |
| Использование места       | Не требует дополнительного места                 | Требует дополнительного места для указателей  |
| Скорость вставки/удаления | Может быть медленнее (из-за поддержания порядка) | Быстрее, так как не меняет физический порядок |
| Поиск диапазонов          | Эффективен, так как данные отсортированы         | Менее эффективен при поиске диапазонов        |
| Примеры использования     | Первичный ключ, уникальные идентификаторы        | Поиск по столбцам в WHERE и ORDER BY          |

[К оглавлению](#SQL)

# 10. Какие типы соединений join таблиц существуют? В чем их разница?
1.  INNER JOIN возвращает только те строки, которые имеют совпадения в обеих таблицах по указанному условию.
+ Как работает: Возвращает строки, где значение в колонке одной таблицы совпадает со значением в колонке другой таблицы. Если совпадений нет, строка не включается в результат.
```java
SELECT employees.name, departments.department_name
FROM employees
INNER JOIN departments ON employees.department_id = departments.id;

возвращаются только те сотрудники (employees), которые имеют 
совпадение в таблице отделов (departments) по department_id.
```
2. LEFT JOIN (или LEFT OUTER JOIN) возвращает все строки из левой таблицы и только совпадающие строки из правой таблицы. Если совпадения нет, то поля правой таблицы будут заполнены NULL.
+ Как работает: Возвращает все строки из левой таблицы, даже если нет совпадения в правой таблице. Строки, которые не имеют соответствий, будут иметь NULL значения в полях правой таблицы.
```java
SELECT employees.name, departments.department_name
FROM employees
LEFT JOIN departments ON employees.department_id = departments.id;

будут возвращены все сотрудники (employees), даже если 
они не принадлежат ни к одному отделу.
```
3. RIGHT JOIN (или RIGHT OUTER JOIN) работает аналогично LEFT JOIN, но возвращает все строки из правой таблицы и только совпадающие строки из левой таблицы. Если совпадения нет, то поля левой таблицы будут заполнены NULL.
+ Как работает: Возвращает все строки из правой таблицы, даже если нет совпадения в левой таблице. Строки, которые не имеют соответствий, будут иметь NULL значения в полях левой таблицы.
```java
SELECT employees.name, departments.department_name
FROM employees
RIGHT JOIN departments ON employees.department_id = departments.id;

будут возвращены все отделы (departments), даже если в них нет сотрудников.
```
4. FULL JOIN (или FULL OUTER JOIN) возвращает все строки, если есть совпадение в одной из таблиц. Если совпадения нет, строки из одной таблицы будут заполнены NULL.
+ Как работает: Возвращает все строки из обеих таблиц. Если есть совпадение, данные объединяются. Если совпадений нет, значения из одной из таблиц будут NULL.
```java
SELECT employees.name, departments.department_name
FROM employees
FULL JOIN departments ON employees.department_id = departments.id;

будут возвращены все сотрудники и все отделы, даже если они не связаны друг с другом.
```
5. CROSS JOIN возвращает декартово произведение двух таблиц. Это значит, что каждая строка из первой таблицы будет сочетаться с каждой строкой из второй таблицы.
+ Как работает: Объединяет все строки из первой таблицы со всеми строками из второй таблицы. Результатом является множество комбинаций.
```java
SELECT employees.name, departments.department_name
FROM employees
CROSS JOIN departments;

будут созданы все возможные комбинации сотрудников и отделов
```
6. SELF JOIN — это случай, когда таблица соединяется сама с собой. Это делается, чтобы сравнить строки одной и той же таблицы.
+ Как работает: Применяется тогда, когда нужно сопоставить строки одной таблицы с другими строками из той же таблицы. Обычно используется псевдонимы таблиц (переименованные экземпляры таблицы).
```java
SELECT e1.name AS employee_name, e2.name AS manager_name
FROM employees e1
INNER JOIN employees e2 ON e1.manager_id = e2.id;

таблица employees соединяется сама с собой для отображения сотрудника и его менеджера
```
| Тип JOIN     | Описание                                                                          | Пример применения                                      |
|--------------|-----------------------------------------------------------------------------------|--------------------------------------------------------|
| INNER JOIN   | Возвращает только строки, имеющие совпадения в обеих таблицах                     | Получение только соответствующих данных                |
| LEFT JOIN    | Возвращает все строки из левой таблицы и соответствующие из правой, если они есть | Все данные с одной стороны и соот ветствующие с другой |
| RIGHT JOIN   | Возвращает все строки из правой таблицы и соответствующие из левой, если они есть | Все данные с другой стороны и соответствующие с первой |
| FULL JOIN    | Возвращает все строки, если есть совпадения в одной из таблиц                     | Получение всех данных из обеих таблиц                  |
| CROSS JOIN   | Возвращает декартово произведение двух таблиц                                     | Создание всех комбинаций данных                        |
| SELF JOIN    | Соединяет таблицу саму с собой                                                    | Сравнение строк в одной таблице                        |

![img](https://github.com/itlazykin/answers_to_exam_questions/blob/main/main/resources/joins.png)

[К оглавлению](#SQL)

# 11. Что такое SQL курсор?
SQL курсор — это объект базы данных, который позволяет поэтапно (по строкам) обрабатывать результаты запроса. Курсоры необходимы, когда необходимо выполнить сложные операции с результатами выборки данных, такие как построчная обработка, изменения данных в нескольких строках или выполнение дополнительных вычислений на основе этих данных.
Курсор позволяет "перемещаться" по результатам запроса, читать и изменять строки данных одну за другой, что особенно полезно в тех случаях, когда обычный запрос (например, с использованием SELECT) не подходит, потому что нужно более гибко управлять процессом обработки данных.
#### Типы курсоров
`Имплицитные курсоры (Implicit Cursors)`
+ Эти курсоры автоматически создаются системой при выполнении SQL-запроса, если не используется явное указание курсора. Например, в SQL запросах типа SELECT, INSERT, UPDATE, и DELETE курсор создается автоматически, и работа с ним скрыта от пользователя.
```java
SELECT * FROM employees;
В этом случае создается имплицитный курсор, 
который перебирает строки результата, и система 
управляет этим процессом автоматически.
```
`Явные курсоры (Explicit Cursors)`
+ Явные курсоры создаются и управляются вручную через SQL-запросы.
+ В этом случае программист или пользователь базы данных управляет процессом открытия, извлечения, обновления и закрытия курсора.
+ Это более гибкий способ работы с данными, так как позволяет более точно контролировать процесс обработки строк результата.
```java
Пример создания и использования явного курсора в PL/SQL
DECLARE
    CURSOR emp_cursor IS
        SELECT name, salary FROM employees WHERE department = 'IT';
    emp_record emp_cursor%ROWTYPE;
BEGIN
    OPEN emp_cursor;  -- Открытие курсора
LOOP
        FETCH emp_cursor INTO emp_record;  -- Извлечение данных
        EXIT WHEN emp_cursor%NOTFOUND;  -- Условие завершения
        DBMS_OUTPUT.PUT_LINE(emp_record.name || ': ' || emp_record.salary);  -- Обработка данных
    END LOOP;
    CLOSE emp_cursor;  -- Закрытие курсора
END;

В этом примере курсор emp_cursor выполняет выборку
всех сотрудников из отдела "IT". Курсор открывается, 
извлекаются данные построчно, и потом курсор закрывается.
```
#### Операции с курсором
`OPEN` — открывает курсор, который выполняет запрос к базе данных. Он выполняет SQL-запрос и подготавливает результат для последующего извлечения.
```java
OPEN emp_cursor FOR SELECT name, salary FROM employees WHERE department = 'IT';
```
`FETCH` — извлекает следующую строку данных из курсора. Каждый вызов FETCH возвращает одну строку.
```java
FETCH emp_cursor INTO emp_record;
```
`CLOSE` — закрывает курсор после того, как его работа завершена, освобождая ресурсы, которые были заняты во время его работы.
```java
CLOSE emp_cursor;
```
`%FOUND` и `%NOTFOUND` — специальные атрибуты, которые используются для проверки состояния курсора. %FOUND — возвращает TRUE, если была извлечена строка, и FALSE, если строк не осталось. %NOTFOUND — возвращает противоположное значение к %FOUND.
```java
IF emp_cursor%NOTFOUND THEN
  DBMS_OUTPUT.PUT_LINE('No more records to fetch.');
END IF;
```
#### Преимущества использования курсоров
+ Построчная обработка: Когда нужно обработать данные построчно, например, выполнять вычисления или изменять данные на основе сложной логики, курсоры позволяют сделать это в цикле.
+ Гибкость: Курсоры дают больше контроля над обработкой данных, что полезно в ситуациях, когда результат запроса нужно обрабатывать сложным образом.
+ Управление памятью: Явные курсоры позволяют управлять временем жизни и ресурсами, связанными с выполнением запросов.
#### Недостатки использования курсоров
+ Производительность: Курсоры могут быть менее эффективными по сравнению с обычными SQL-запросами, так как они требуют построчной обработки, а не параллельной работы с набором данных.
+ Ресурсы: Использование курсоров требует выделения дополнительных системных ресурсов, например, памяти, для хранения состояния курсора и результатов запроса.
+ Сложность: Код с использованием курсоров может быть сложнее для понимания и отладки, чем простые SQL-запросы.
#### Когда стоит использовать курсоры?
+ Если необходимо выполнить построчную обработку данных с возможностью выполнения сложных операций с каждой строкой.
+ Когда нужно работать с большим количеством данных, и можно обрабатывать их по частям, а не загружать все в память.
+ Когда важно иметь контроль над открытием и закрытием ресурсов, связанных с запросами.

[К оглавлению](#SQL)

# 12. Опишите шаги по созданию и использованию курсора.
+ Определение курсора — создание курсора с SQL-запросом.
+ Открытие курсора (OPEN) — выполнение запроса и подготовка данных.
+ Извлечение данных (FETCH) — поочередное извлечение строк данных.
+ Проверка состояния (например, с помощью %NOTFOUND) — для определения, нужно ли продолжать извлечение данных.
+ Закрытие курсора (CLOSE) — освобождение ресурсов после завершения работы с курсором.
```java
пример создания, использования и закрытия курсора:

DECLARE
    CURSOR emp_cursor IS
        SELECT employee_id, first_name, last_name FROM employees WHERE department_id = 10;
    v_employee emp_cursor%ROWTYPE;
BEGIN
    OPEN emp_cursor;  -- Открытие курсора
    LOOP
      FETCH emp_cursor INTO v_employee;  -- Извлечение данных
      EXIT WHEN emp_cursor%NOTFOUND;  -- Выход, если данных больше нет
      DBMS_OUTPUT.PUT_LINE('ID: ' || v_employee.employee_id || ', Name: ' || v_employee.first_name || ' ' || v_employee.last_name);
  END LOOP;
  CLOSE emp_cursor;  -- Закрытие курсора
END;

```
[К оглавлению](#SQL)

# 13. Что такое транзакция?
Транзакция — это последовательность операций, выполняемых как единое целое, которая должна либо полностью завершиться (с подтверждением всех изменений), либо не состояться вообще. Основная цель транзакций в базе данных — обеспечить целостность данных и избежать их повреждения или частичного обновления.
#### Основные свойства транзакции — ACID
+ Atomicity (Атомарность): Транзакция должна быть атомарной, то есть она либо полностью выполняется, либо не выполняется вовсе. Если какая-либо операция в транзакции не может быть выполнена, все изменения, сделанные в рамках этой транзакции, отменяются.
+ Consistency (Согласованность): Транзакция должна переводить базу данных из одного согласованного состояния в другое. Это означает, что после выполнения транзакции база данных должна быть в корректном состоянии, удовлетворяя всем её ограничениям (например, внешним ключам, уникальности значений и т.д.).
+ Isolation (Изолированность): Результаты выполнения транзакции должны быть изолированы от других транзакций. Пока одна транзакция не завершена, другие транзакции не должны видеть её промежуточные изменения.
+ Durability (Долговечность): После завершения транзакции все изменения должны быть сохранены в базе данных и пережить сбои в системе, такие как выключение питания или сбой оборудования.
#### Пример транзакции в базе данных
Предположим, что у нас есть банковская система, и нужно перевести деньги с одного счета на другой. Транзакция будет состоять из двух операций:Списать деньги с одного счета. Зачислить деньги на другой счет.
Эти два действия должны быть выполнены как единое целое. Если при выполнении транзакции происходит сбой после того, как деньги были списаны, но не были зачислены на второй счет, то это нарушит целостность данных. Транзакция в этом случае должна быть отменена, и все изменения (списание) должны быть откатаны.
#### Пример транзакции в SQL
В SQL для работы с транзакциями используется набор команд:
+ BEGIN TRANSACTION — начало транзакции.
+ COMMIT — подтверждение транзакции, все изменения сохраняются.
+ ROLLBACK — откат транзакции, если произошла ошибка или необходимо отменить изменения.
```java
BEGIN TRANSACTION;

UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;  -- Списание денег
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;  -- Зачисление денег

-- Если все прошло успешно, подтверждаем транзакцию
COMMIT;

Если в какой-то момент возникнет ошибка 
(например, недостаточно средств на счете), то можно откатить все изменения

ROLLBACK;
```
#### Зачем нужны транзакции?
Транзакции важны для обеспечения целостности и согласованности данных, предотвращения потери данных и конфликтов при одновременном доступе разных пользователей к базе данных. Они позволяют работать с базой данных более безопасно, особенно в многопользовательской среде.
Транзакции являются основой для построения надежных и отказоустойчивых систем, особенно в критических приложениях, таких как банковские системы, системы бронирования, учетные системы и т.д.

[К оглавлению](#SQL)

# 14. Что такое триггер? Какие типы триггеров Вы знаете?
Триггер — это специальная программа или блок кода, который автоматически выполняется (или "срабатывает") в ответ на определённые события, происходящие в базе данных. Эти события могут быть связаны с изменениями данных в таблицах, такими как вставка, обновление или удаление строк. Триггеры часто используются для автоматизации различных задач в базе данных, таких как поддержание целостности данных, журналирование изменений или реализация бизнес-логики.
#### Основные типы триггеров:
`DML триггеры (Data Manipulation Language):` Эти триггеры срабатывают на операции манипуляции данными, такие как INSERT, UPDATE и DELETE.
#### Типы DML триггеров
+ BEFORE триггер: Выполняется до того, как операция вставки, обновления или удаления данных будет фактически выполнена. Это позволяет выполнить проверку данных или их изменение перед тем, как данные попадут в таблицу.
+ AFTER триггер: Выполняется после того, как операция манипуляции с данными была завершена. Это полезно для реализации дополнительной логики после того, как данные были изменены, например, для логирования или синхронизации с другими таблицами.
+ INSTEAD OF триггер: Этот триггер срабатывает вместо операции изменения данных. Он может быть полезен в случае, если нужно заменить стандартное поведение операции на что-то другое. Например, для работы с представлениями (views), когда стандартный запрос не может быть выполнен, и нужно выполнить замену операции на другую логику.
```java
Пример для AFTER INSERT триггера

CREATE TRIGGER trg_after_insert
AFTER INSERT ON employees
FOR EACH ROW
BEGIN
  -- Логика для добавления записи в лог или другой процесс
INSERT INTO audit_log (action, employee_id, timestamp)
VALUES ('INSERT', NEW.employee_id, NOW());
END;

```
`DDL триггеры (Data Definition Language):` Эти триггеры срабатывают на операции, изменяющие структуру базы данных, такие как CREATE, ALTER, DROP и другие DDL-команды. Данные триггеры используются для контроля изменений в схеме базы данных, например, для защиты от несанкционированных изменений.
```java
Пример использования DDL триггера
CREATE TRIGGER prevent_drop
BEFORE DROP ON DATABASE
BEGIN
SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Dropping the database is not allowed';
END;
```
`LOGON/LOGOFF триггеры:`Эти триггеры срабатывают при входе или выходе пользователя из базы данных. Они могут использоваться для аудита, отслеживания активности пользователей или выполнения предварительных настроек, когда пользователь подключается.
```java
CREATE TRIGGER trg_logon
AFTER LOGON ON DATABASE
BEGIN
  -- Логика для регистрации входа пользователя
  INSERT INTO login_audit (username, login_time)
  VALUES (USER, SYSDATE);
END;
```
`Compound триггеры:`Эти триггеры объединяют несколько действий в одном объекте. Они могут использовать как BEFORE, так и AFTER операцию и позволяют сгруппировать несколько триггеров в одном.
#### Преимущества использования триггеров:
+ Автоматизация: Триггеры могут автоматизировать различные процессы, такие как проверка целостности данных, обновление смежных таблиц, ведение журналов и другие операции.
+ Сохранение целостности данных: Триггеры позволяют автоматически выполнять действия, которые обеспечивают целостность базы данных, например, обновление или удаление связанных записей.
+ Безопасность: Триггеры могут быть использованы для защиты базы данных от несанкционированных изменений, проверки данных или мониторинга доступа.
#### Недостатки:
+ Производительность: Триггеры могут существенно замедлить выполнение операций, если они выполняются часто или выполняют сложные вычисления.
+ Сложность отладки: Триггеры могут быть трудны для отладки и тестирования, особенно если они вызывают каскадные эффекты (триггеры, вызывающие другие триггеры).
+ Скрытая логика: Логика, встроенная в триггеры, может быть неочевидной для разработчиков, что делает базу данных трудной для понимания и поддержки.

[К оглавлению](#SQL)

# 15. В чем разница между where и having?
Это оба оператора, которые используются для фильтрации данных в SQL, но они применяются в разных контекстах и имеют разные функции.
#### Основные различия:
`WHERE:`
Применяется до агрегации данных, то есть фильтрует строки до того, как выполняются группировки или агрегатные функции.
Используется для фильтрации индивидуальных строк таблицы на основе их значений.
Не может работать с агрегатными функциями (например, COUNT(), SUM(), AVG()), если только не используется в подзапросах.
```java
SELECT name, age
FROM employees
WHERE age > 30;

фильтруем строки по значению поля age до выполнения любых агрегатных функций.
```
`HAVING:`Применяется после агрегации данных, то есть фильтрует строки после того, как выполнены операции группировки и агрегации.
Используется для фильтрации результатов группировок или агрегатных значений, полученных с помощью команд типа GROUP BY.
Может работать только с агрегатными функциями.
```java
SELECT department, COUNT(*) as employee_count
FROM employees
GROUP BY department
HAVING COUNT(*) > 10;

сначала группируем сотрудников по отделам, 
а затем фильтруем те группы, где количество сотрудников больше 10.
```
#### Когда использовать WHERE и HAVING:
+ Используйте WHERE для фильтрации строк, прежде чем будет применена агрегация.
+ Используйте HAVING для фильтрации групп данных после применения агрегатных функций.

Можно использовать оба оператора в одном запросе, если необходимо сначала отфильтровать строки с помощью WHERE, а затем применить агрегатные функции и фильтровать группы с помощью HAVING.
```java
SELECT department, AVG(salary) as avg_salary
FROM employees
WHERE age > 30
GROUP BY department
HAVING AVG(salary) > 50000;

Сначала мы фильтруем сотрудников старше 30 лет с помощью WHERE.
Затем группируем их по отделам и вычисляем среднюю зарплату.
После этого с помощью HAVING мы фильтруем те группы, 
где средняя зарплата больше 50,000.
```

[К оглавлению](#SQL)

# 16. Что такое подзапрос sub-query?
Подзапрос (sub-query) — это запрос, который выполняется внутри другого SQL-запроса. Подзапрос используется для получения данных, которые затем могут быть использованы в основном запросе. Он может быть частью оператора SELECT, INSERT, UPDATE, DELETE или других SQL-операторов, и может возвращать одно или несколько значений.
#### Основные типы подзапросов:
+ Подзапрос в списке выборки (SELECT): Подзапрос используется внутри основного запроса, чтобы вернуть результат, который может быть использован как один из столбцов.
```java
SELECT name, (SELECT department FROM employees WHERE id = 1) AS department
FROM employees;

В этом примере подзапрос возвращает значение отдела для сотрудника с id = 1, 
и это значение будет использоваться в основном запросе.
```
+ Подзапрос в операторе WHERE: Один из самых популярных случаев использования подзапросов. Подзапрос помогает фильтровать данные в основном запросе, используя результат, который возвращает подзапрос.
```java
SELECT name
FROM employees
WHERE department_id = (SELECT department_id FROM departments WHERE name = 'HR');

подзапрос используется для поиска department_id для отдела с названием 'HR',
и основной запрос выбирает сотрудников, работающих в этом отделе.
```
+ Подзапрос в операторе FROM: Подзапрос может быть использован как временная таблица (или "вьюшка"), из которой затем можно извлекать данные.
```java
SELECT avg_salary
FROM (SELECT salary FROM employees WHERE department_id = 1) AS dept_salaries;

В этом случае подзапрос извлекает зарплаты сотрудников из отдела с department_id = 1, а затем основной запрос вычисляет среднюю зарплату для этого отдела.
```
+ Коррелированный подзапрос: Это подзапрос, который зависит от внешнего запроса и использует значения из основного запроса. Коррелированный подзапрос выполняется для каждой строки внешнего запроса.
````java
SELECT name
FROM employees e
WHERE salary > (SELECT AVG(salary) FROM employees WHERE department_id = e.department_id);

В этом примере подзапрос сравнивает зарплату каждого сотрудника с средней зарплатой в его департаменте. 
Подзапрос зависит от значения e.department_id из внешнего запроса, и выполняется для каждой строки.
````
#### Когда использовать подзапросы:
+ Для сравнения значений с результатами другого запроса.
+ Когда требуется вычислить агрегатные значения (например, среднее, максимальное, минимальное значение) в подзапросе и затем использовать их в основном запросе.
+ Для получения значений из нескольких таблиц, когда необходимо выполнить несколько запросов.
#### Преимущества подзапросов:
+ Позволяют логически разделить запросы на части, что делает их более читаемыми.
+ Использование подзапросов может упростить сложные запросы с несколькими условиями.
#### Недостатки подзапросов:
+ В некоторых случаях производительность может пострадать, особенно если подзапросы выполняются для каждой строки внешнего запроса (в случае с коррелированными подзапросами).
+ В случае сложных запросов, подзапросы могут усложнить отладку и понимание структуры данных.

[К оглавлению](#SQL)

# 17. Что такое union?
UNION — это оператор SQL, который используется для объединения результатов двух или более SELECT-запросов в один набор данных. Все SELECT-запросы, объединяемые с помощью UNION, должны возвращать одинаковое количество столбцов, и типы данных этих столбцов должны быть совместимы.
#### Как работает UNION:
+ Объединяет результаты: Каждый SELECT-запрос возвращает результат, который будет объединен с результатами других запросов.
+ Удаляет дубликаты: По умолчанию UNION удаляет все дубликаты из результирующего набора данных, оставляя только уникальные строки.
+ Нумерация столбцов: Столбцы, которые объединяются, должны быть одинакового типа и должны соответствовать по порядку.
````java
Пример использования UNION:

SELECT name FROM employees WHERE department = 'HR'
UNION
SELECT name FROM employees WHERE department = 'Finance';

Этот запрос объединяет имена сотрудников, работающих в департаментах "HR" и "Finance". 
Результат будет содержать уникальные имена сотрудников из этих двух департаментов.
````
#### Важные моменты:
+ Одинаковое количество столбцов: Каждый запрос, который объединяется с помощью UNION, должен возвращать одинаковое количество столбцов.
+ Совместимость типов данных: Типы данных столбцов, возвращаемых в разных SELECT-запросах, должны быть совместимы.
+ Удаление дубликатов: Если в результирующем наборе есть одинаковые строки, они будут удалены. Для того чтобы оставить все дубликаты, можно использовать оператор UNION ALL.
#### Разница между UNION и UNION ALL:
+ UNION: Убирает дубликаты в результирующем наборе данных.
+ UNION ALL: Не удаляет дубликаты, то есть в результирующем наборе могут быть одинаковые строки.
````java
Пример с UNION ALL:

SELECT name FROM employees WHERE department = 'HR'
UNION ALL
SELECT name FROM employees WHERE department = 'Finance';

будут включены все имена, даже если они повторяются в обоих запросах.
````
#### Преимущества:
+ Позволяет объединить данные из разных источников в один набор.
+ Упрощает запросы, когда нужно извлечь схожую информацию из нескольких таблиц или представлений.
#### Когда использовать UNION:
+ Когда необходимо объединить данные из разных таблиц или запросов и получить уникальные строки.
+ Для работы с несколькими таблицами, которые имеют схожую структуру, но содержат различные данные.

[К оглавлению](#SQL)

# 18. Что такое group by?
GROUP BY — это оператор в SQL, который используется для группировки строк в таблице, основываясь на значениях одного или нескольких столбцов. После группировки, обычно применяются агрегатные функции (например, COUNT(), SUM(), AVG(), MAX(), MIN()), чтобы вычислить статистику для каждой группы.
#### Основные моменты:
+ Группировка данных: GROUP BY позволяет объединять строки с одинаковыми значениями в одном или нескольких столбцах в единую группу.
+ Агрегация: После того как строки сгруппированы, обычно используется агрегатная функция для выполнения вычислений по каждой группе.
+ Использование с агрегатами: Обычно GROUP BY применяется в запросах, где необходимо агрегировать данные, например, подсчитать количество, сумму или среднее значение по группе.
```java
Синтаксис:
SELECT column1, column2, AGGREGATE_FUNCTION(column3)
FROM table_name
GROUP BY column1, column2;
```
```java
Если мы хотим посчитать общую сумму продаж по каждому продукту, мы можем использовать GROUP BY:

SELECT product, SUM(amount) AS total_sales
FROM sales
GROUP BY product;

Мы группируем строки по значению столбца product.
Для каждой группы считаем сумму (SUM(amount)), 
что дает нам общую сумму продаж для каждого продукта.
```
```java
Вы можете группировать данные по нескольким столбцам. 
Например, если бы нам нужно было группировать данные по продуктам и датам:

SELECT product, sale_date, SUM(amount) AS total_sales
FROM sales
GROUP BY product, sale_date;
```
#### Важные моменты
+ Все столбцы в SELECT, которые не являются аргументом агрегатной функции, должны быть указаны в GROUP BY. Это правило гарантирует, что запрос будет корректно работать, потому что SQL должен понимать, как объединять строки в группы.
+ Использование с агрегатными функциями: Без использования агрегатных функций, GROUP BY не имеет смысла, так как оно предназначено для агрегации.
+ Фильтрация после группировки: Чтобы отфильтровать результаты после группировки, можно использовать оператор HAVING. В отличие от WHERE, который фильтрует строки до группировки, HAVING фильтрует группы после применения GROUP BY.
#### Когда использовать GROUP BY:
+ Когда нужно сгруппировать строки с одинаковыми значениями по одному или нескольким столбцам.
+ Для выполнения агрегатных операций (например, подсчета количества, суммы, среднего значения) для каждой группы.
+ Когда необходимо фильтровать данные после агрегации с помощью HAVING.

[К оглавлению](#SQL)

# 19. Что такое хранимые процедуры?
Хранимые процедуры (stored procedures) — это именованные блоки SQL-кода, которые хранятся в базе данных и могут быть выполнены по запросу. Хранимые процедуры позволяют выполнять несколько SQL-запросов и бизнес-логики на сервере базы данных, что помогает улучшить производительность, повторное использование кода и безопасность.
#### Основные особенности хранимых процедур:
+ Инкапсуляция логики: Хранимые процедуры позволяют инкапсулировать сложную логику обработки данных, так что она может быть вызвана как единый блок, а не как несколько отдельных запросов.
+ Повторное использование: Вместо того, чтобы писать один и тот же SQL-запрос несколько раз в разных местах, можно создать хранимую процедуру и вызывать ее везде, где она нужна.
+ Повышение производительности: Хранимые процедуры выполняются на стороне сервера базы данных, что может значительно ускорить выполнение сложных операций, так как они компилируются один раз, а затем повторно используются.
+ Безопасность: Использование хранимых процедур может повысить безопасность, так как они могут быть настроены так, чтобы пользователи не имели прямого доступа к базовым таблицам или данным, а взаимодействовали только с заранее определенным набором процедур.
#### Преимущества хранимых процедур:
+ Повторное использование: Разработчики могут многократно использовать одну и ту же логику без необходимости повторно писать SQL-запросы.
+ Производительность: Хранимые процедуры компилируются и выполняются на сервере базы данных, что часто быстрее, чем выполнение нескольких отдельных запросов.
+ Упрощение взаимодействия с базой данных: В коде приложения может быть вызов одной хранимой процедуры, вместо того чтобы писать множество SQL-запросов.
+ Повышение безопасности: Предоставление пользователям доступа к хранимым процедурам позволяет скрыть детали реализации и защитить прямой доступ к данным.
#### Недостатки:
+ Зависимость от СУБД: Хранимые процедуры написаны для конкретной системы управления базами данных (СУБД), что делает их менее переносимыми между различными СУБД.
+ Усложнение тестирования: Тестирование хранимых процедур может быть сложным, так как их выполнение зависит от контекста базы данных.
+ Риск перегрузки базы данных: Неправильно написанные хранимые процедуры могут перегрузить базу данных или привести к блокировкам.
#### Разновидности хранимых процедур:
`Процедуры с параметрами:`
+ IN — входной параметр.
+ OUT — выходной параметр.
+ INOUT — параметр, который может быть использован для передачи значений в процедуру и возвращения значений из процедуры.

`Функции (Stored Functions):` Это разновидность хранимых процедур, которая возвращает одно значение и может быть использована в SQL-запросах, как обычная функция.
#### Когда использовать хранимые процедуры:
+ Когда необходимо инкапсулировать сложную логику в базе данных.
+ Для повторного использования бизнес-логики.  
+ Для улучшения производительности, особенно при работе с большими объемами данных. 
+ Для повышения безопасности доступа к данным.
```java
пример простой процедуры, которая выполняет следующее:
Добавляет нового сотрудника в таблицу employees.
Если сотрудник с таким именем уже существует, обновляет его зарплату.

CREATE TABLE employees (
        id SERIAL PRIMARY KEY,
        name TEXT NOT NULL UNIQUE,
        salary NUMERIC(10, 2) NOT NULL
);

CREATE OR REPLACE PROCEDURE upsert_employee(emp_name TEXT, emp_salary NUMERIC)
LANGUAGE plpgsql
AS $$
BEGIN
    -- Попробуем обновить существующую запись
UPDATE employees
SET salary = emp_salary
WHERE name = emp_name;

    -- Если ни одна запись не обновлена, вставим новую
IF NOT FOUND THEN
INSERT INTO employees (name, salary)
VALUES (emp_name, emp_salary);
END IF;
END;
$$;

Вызов процедуры:
CALL upsert_employee('Alice', 50000);
CALL upsert_employee('Bob', 60000);
CALL upsert_employee('Alice', 55000); -- Обновит зарплату Alice

Проверка результата:
SELECT * FROM employees;

Хранимая процедура в данном случае выполняет "upsert" — 
обновляет запись, если она существует, или добавляет новую, если нет. 
Это удобный способ минимизировать дублирование кода в приложении.
```

[К оглавлению](#SQL)

# 20. Что такое view представление?
View (представление) в базе данных — это виртуальная таблица, которая представляет собой результат выполнения SQL-запроса. Представления не содержат данных, а лишь отображают данные, полученные из одной или нескольких таблиц с использованием SQL-запроса. Они создаются для упрощения сложных запросов, обеспечения безопасности и улучшения удобства работы с базой данных.
#### Основные характеристики представлений:
+ Виртуальная таблица: Представление — это не физическая таблица, а результат запроса, который выполняется каждый раз при обращении к представлению. Оно не хранит данные, а лишь ссылку на запрос, который будет выполнен.
+ Составляется из других таблиц: Представление обычно строится на основе данных из одной или нескольких таблиц, что позволяет создавать абстракцию, скрывая сложность запросов от конечного пользователя.
+ Упрощение запросов: Использование представлений позволяет упростить сложные SQL-запросы, так как можно создавать представления для часто используемых комбинаций данных, чтобы не повторять один и тот же запрос несколько раз.
+ Защита данных: Представления могут использоваться для ограничения доступа к определенным данным. Например, вы можете создать представление, которое отображает только часть столбцов или строк из основной таблицы, ограничивая доступ к чувствительной информации.
```java
Синтаксис для создания представления:

CREATE VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;

Пример: Предположим, у нас есть таблица employees с данными о сотрудниках. 
Чтобы создать представление, которое показывает только имена 
и зарплаты сотрудников, можем выполнить следующий запрос:

CREATE VIEW employee_salaries AS
SELECT name, salary
FROM employees;

Теперь, вместо того чтобы писать SELECT name, 
salary FROM employees; каждый раз, можно просто выполнить:

SELECT * FROM employee_salaries;
```
#### Преимущества представлений:
+ Упрощение запросов: Представления позволяют скрыть сложные запросы, делая их более понятными и легкими для пользователей.
+ Повторное использование: Представление можно использовать многократно в разных частях приложения, минимизируя необходимость писать один и тот же запрос несколько раз.
+ Изоляция бизнес-логики: Логика для извлечения данных может быть инкапсулирована в представление, что упрощает обслуживание и обновление базы данных.
+ Ограничение доступа: Представления могут использоваться для ограничения доступа к определенным данным, обеспечивая безопасность.
#### Недостатки представлений:
+ Производительность: Поскольку представления не хранят данные, каждый раз при обращении к ним выполняется запрос, что может быть медленнее, чем работа с физическими таблицами.
+ Не всегда обновляемы: Некоторые представления могут быть только для чтения. Если запрос представления слишком сложный (например, включает объединение нескольких таблиц с агрегацией), оно может стать не обновляемым, и нельзя будет вставить или обновить данные через это представление.
#### Обновление данных через представление:
Если представление основано на одной таблице и не включает сложных операций, таких как объединения или агрегатные функции, данные в представлении могут быть обновляемыми. Это означает, что можно вставлять, обновлять или удалять строки через представление, и изменения будут отражены в базовых таблицах. Однако если представление состоит из нескольких таблиц или использует агрегатные функции, то оно становится необновляемым (read-only). В таких случаях необходимо работать с базовыми таблицами напрямую.

```java
Пример обновляемого представления:
Если у нас есть представление, которое отображает сотрудников, 
то можно обновить зарплату через это представление, если оно не содержит сложных операций:

CREATE VIEW employee_salaries AS
SELECT id, name, salary
FROM employees;

Теперь можно выполнить обновление через это представление:

UPDATE employee_salaries
SET salary = 5000
WHERE name = 'John Doe';
```
#### Когда использовать представления:
+ Когда требуется абстрагироваться от сложности запросов, например, для отчетности.
+ Когда нужно скрыть сложные вычисления и предоставить пользователям более простой интерфейс.
+ Для ограничения доступа к данным: например, если нужно показывать только часть столбцов или строк.
+ Для улучшения читаемости кода в больших проектах, где повторяется один и тот же набор запросов.

[К оглавлению](#SQL)

# 21. Что такое JDBC?
JDBC (Java Database Connectivity) — это стандартное API для взаимодействия Java-программ с базами данных. Он позволяет приложениям на языке Java выполнять операции с базами данных, такие как создание, чтение, обновление и удаление данных (операции CRUD), а также выполнение запросов и управление транзакциями. JDBC предоставляет универсальный способ подключения к различным СУБД (системам управления базами данных) через драйвера, обеспечивая таким образом независимость от конкретной СУБД.
#### Основные компоненты JDBC:
+ JDBC API — набор классов и интерфейсов, которые предоставляют абстракцию для работы с базами данных.
+ Драйвера JDBC — это специальные реализации интерфейсов JDBC, которые обеспечивают связь с конкретными СУБД. Существует несколько типов драйверов в зависимости от механизма подключения.
#### Как работает JDBC?
+ Приложение создаёт соединение с базой данных с помощью соответствующего драйвера JDBC.
+ Приложение выполняет SQL-запросы или обновления через объект Statement или PreparedStatement.
+ Приложение получает результаты запросов через объект ResultSet.
+ После выполнения операции соединение с базой данных закрывается.
#### Основные компоненты JDBC:
+ Connection — интерфейс для работы с соединением с базой данных. С помощью этого интерфейса устанавливается соединение, управляются транзакции, и получаются объекты Statement, PreparedStatement, CallableStatement.
```java
Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydatabase", "username", "password");
```
+ Statement — интерфейс, который используется для выполнения SQL-запросов. Statement подходит для выполнения простых запросов, которые не требуют параметризации.
```java
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM employees");
```
+ PreparedStatement — это расширение интерфейса Statement, которое позволяет задавать параметры в SQL-запросах и улучшает производительность за счет предварительной компиляции запроса. Он используется для выполнения параметризованных запросов (например, при вставке данных).
```java
PreparedStatement ps = conn.prepareStatement("SELECT * FROM employees WHERE id = ?");
ps.setInt(1, 101);
ResultSet rs = ps.executeQuery();
```
+ ResultSet — интерфейс для обработки результатов запросов. Он представляет собой таблицу данных, возвращаемую SQL-запросами (например, SELECT).
```java
while (rs.next()) {
System.out.println(rs.getString("name"));
}
```
+ CallableStatement — интерфейс для вызова хранимых процедур и функций в базе данных.
+ SQLException — исключение, которое генерируется в случае ошибок при работе с базой данных.

#### Драйверы JDBC:
+ Тип 1 (JDBC-ODBC Bridge Driver) — использует ODBC (Open Database Connectivity) для подключения к базам данных. Это устаревший тип драйвера.
+ Тип 2 (Native-API Driver) — использует нативный API базы данных для подключения.
+ Тип 3 (Network Protocol Driver) — использует сетевой протокол для взаимодействия с базой данных.
+ Тип 4 (Thin Driver) — полностью реализует протокол JDBC для работы с базой данных без необходимости в дополнительных программных слоях.
#### Основные этапы работы с JDBC:
+ Установка соединения: Для начала работы с базой данных необходимо установить соединение, указав URL базы данных, имя пользователя и пароль.
```java
Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydatabase", "user", "password");
```
+ Создание и выполнение SQL-запросов: После установления соединения создаётся объект Statement или PreparedStatement, с помощью которого выполняются SQL-запросы.
+ Обработка результатов: Когда запрос выполняется, результаты (например, при SELECT) возвращаются в объект ResultSet, который позволяет перебирать строки результата.
+ Закрытие ресурсов: После выполнения всех операций необходимо закрыть соединение и другие ресурсы, такие как Statement и ResultSet, чтобы освободить ресурсы и избежать утечек памяти.
```java
rs.close();
stmt.close();
conn.close();
```
#### Преимущества использования JDBC:
+ Независимость от СУБД: JDBC предоставляет общий интерфейс для работы с различными СУБД, что упрощает переносимость приложений.
+ Гибкость: JDBC позволяет выполнять все типы SQL-запросов, включая SELECT, INSERT, UPDATE, DELETE, а также работу с хранимыми процедурами.
+ Высокая производительность: Использование PreparedStatement помогает ускорить выполнение запросов за счет предварительной компиляции.
+ Широкая поддержка: JDBC поддерживает множество популярных СУБД, таких как MySQL, PostgreSQL, Oracle, Microsoft SQL Server и другие.
#### Недостатки:
+ Низкий уровень абстракции: JDBC предоставляет низкоуровневый интерфейс для работы с базой данных, что требует большого количества кода для выполнения стандартных операций.
+ Трудности с управлением соединениями: Необходимо вручную управлять соединениями с базой данных, что может привести к ошибкам или утечкам памяти.

[К оглавлению](#SQL)

# 22. Что нужно для работы с той или иной БД?
+ Подключить нужный JDBC-драйвер для СУБД. (PostgreSQL JDBC Driver)
+ Указать URL для подключения и данные для аутентификации. 
```java
(String url = "jdbc:postgresql://localhost:5432/mydatabase";)
```
+ Доступ к БД (пользователь и пароль)
```java
String username = "myuser";
String password = "mypassword";
Connection conn = DriverManager.getConnection(url, username, password);
```
+ Уметь работать с SQL-запросами (SELECT, INSERT, UPDATE, DELETE).
```java
String sql = "SELECT * FROM employees WHERE age > ?";
PreparedStatement stmt = conn.prepareStatement(sql);
stmt.setInt(1, 30);  // параметр для запроса
ResultSet rs = stmt.executeQuery();
```
+ Управлять соединениями и ресурсами (закрывать их после работы).
```java
rs.close();
stmt.close();
conn.close();
```
+ Обрабатывать исключения и ошибки, возникающие при взаимодействии с базой данных.
```java
try {
    Connection conn = DriverManager.getConnection(url, username, password);
    // Выполнение операций с БД
} catch (SQLException e) {
    e.printStackTrace();  // Вывод информации об ошибке
}
```

[К оглавлению](#SQL)

# 23. Как зарегистрировать драйвер?
Для того чтобы зарегистрировать драйвер JDBC в Java, в большинстве случаев достаточно подключить сам драйвер, добавляя зависимость в pom 
```java
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <version>42.7.3</version>
</dependency>
```

[К оглавлению](#SQL)

# 24. Как получить Connection?
Для получения Connection (соединения с базой данных) в Java, используем JDBC (Java Database Connectivity).
1. Подключение к базе данных с помощью DriverManager. Для получения соединения с базой данных, нужно использовать метод DriverManager.getConnection(). Этот метод требует указания URL базы данных, имени пользователя и пароля.
```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class JdbcExample {
    public static void main(String[] args) {
        // URL подключения к базе данных
        String url = "jdbc:mysql://localhost:3306/mydatabase";  // для MySQL
        String username = "myuser";  // имя пользователя базы данных
        String password = "mypassword";  // пароль пользователя

        try {
            // Получаем соединение с базой данных
            Connection conn = DriverManager.getConnection(url, username, password);

            // Использование соединения (например, выполнение запросов)
            System.out.println("Соединение успешно установлено!");

            // Не забывайте закрывать соединение после работы с ним
            conn.close();
        } catch (SQLException e) {
            e.printStackTrace();  // Обработка ошибок, если соединение не удалось
        }
    }
}
```
2. Пояснение по параметрам для getConnection()
+ URL подключения: Это строка, указывающая, как подключиться к базе данных. Она состоит из:
- - Протокола JDBC (например, jdbc:mysql:// для MySQL).
- - Хоста базы данных (например, localhost).
- - Порта, на котором работает база данных (например, 3306 для MySQL).
- - Имя базы данных (например, mydatabase).
+ Имя пользователя и пароль: Это учетные данные для аутентификации в базе данных.
3. Подключение с использованием пула соединений. Для улучшения производительности, особенно в многопоточных приложениях, рекомендуется использовать пул соединений. Пул соединений позволяет повторно использовать уже открытые соединения, избегая затрат на создание нового соединения для каждого запроса. Это достигается с помощью различных библиотек и фреймворков, например:
+ HikariCP (быстрый и легковесный пул соединений).
+ Apache Commons DBCP.
+ C3P0.
4. Использование DataSource (альтернатива DriverManager). DataSource — это интерфейс, предоставляющий более высокоуровневый способ работы с соединениями. В отличие от DriverManager, который работает с соединениями напрямую, DataSource может быть использован для управления пулом соединений и упрощения получения соединений.
```java
import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.SQLException;
import org.apache.commons.dbcp2.BasicDataSource;

public class DataSourceExample {
    public static void main(String[] args) {
        // Создание DataSource с использованием DBCP2
        BasicDataSource dataSource = new BasicDataSource();
        dataSource.setUrl("jdbc:mysql://localhost:3306/mydatabase");
        dataSource.setUsername("myuser");
        dataSource.setPassword("mypassword");

        try {
            // Получаем соединение из DataSource
            Connection conn = dataSource.getConnection();
            System.out.println("Соединение успешно установлено!");

            // Закрываем соединение
            conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```
#### Заключение
Для получения Connection в Java вам необходимо:
+ Указать правильный URL подключения.
+ Предоставить учетные данные (пользователь и пароль).
+ Использовать DriverManager.getConnection() для обычного подключения или DataSource для более сложных случаев (например, с использованием пула соединений).

7. [К оглавлению](#SQL)

# 25. Что такое Statement, PreparedStatement? В чем разница между ними?
Java, для работы с базой данных через JDBC, для выполнения SQL-запросов используются объекты Statement и PreparedStatement. Оба класса являются частью API JDBC и используются для выполнения SQL-запросов
1. Statement — это интерфейс, который используется для выполнения простых SQL-запросов без параметров. Обычно его используют для запросов, которые не требуют параметризации, например, для простого SELECT, INSERT, UPDATE и т.д.
```java
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM users");
```
2. PreparedStatement — это расширение интерфейса Statement, которое позволяет заранее компилировать SQL-запросы с использованием параметров. Вместо того, чтобы каждый раз передавать строку запроса (что может быть небезопасно и неэффективно), вы используете плейсхолдеры (?) для параметров, и затем заполняете их значениями перед выполнением запроса. Это улучшает производительность и безопасность (защищает от SQL-инъекций). SQL-инъекция (SQLi) - это уязвимость веб-безопасности, которая позволяет злоумышленнику вмешиваться в запросы, которые приложение делает к своей базе данных. Как правило, это позволяет просматривать данные, которые он обычно не может получить. Это могут быть других пользователей, или любые другие данные, доступ к которым имеет само приложение. Во многих случаях злоумышленник может изменять или удалять эти данные, вызывая постоянные изменения в содержимом или поведении приложения.
```java
String sql = "SELECT * FROM users WHERE id = ?";
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setInt(1, 1); // Устанавливаем значение для параметра
ResultSet rs = pstmt.executeQuery();
```
#### Преимущества PreparedStatement:
+ Безопасность: Защищает от SQL-инъекций, так как параметры передаются отдельно от самого запроса.
+ Производительность: При многократном выполнении одного и того же запроса с разными параметрами, PreparedStatement компилируется только один раз, а затем используется повторно, что ускоряет выполнение.
+ Читаемость кода: Параметризованные запросы могут сделать код более читаемым, так как не нужно вручную строить SQL-строку с параметрами.
#### Заключение:
+ Используйте Statement, если вам нужно выполнить простой запрос без параметров.
+ Используйте PreparedStatement, если вам нужно работать с параметризованными запросами или хотите защититься от SQL-инъекций и улучшить производительность при многократном выполнении одинаковых запросов.

  | Характеристика           | Statement                                                                                         | PreparedStatement                                                                                                                   |
  |--------------------------|---------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------|
  | Производительность       | Менее производительный для повторных запросов, так как каждый запрос нужно компилировать заново.  | Более производительный, так как SQL-запрос компилируется один раз, а затем используется многократно.                                |
  | Безопасность	          | Подвержен SQL-инъекциям, так как значения подставляются непосредственно в строку запроса.         | Защищает от SQL-инъекций, так как параметры передаются через метод setXXX(), а не вставляются в строку                              |
  | Использование параметров | Не поддерживает параметры (все значения в запросе должны быть жестко закодированы).               | Поддерживает параметры, которые задаются через методы типа setInt(), setString(), и т.д.                                            |
  | Использование            | Хорошо подходит для одноразовых или простых запросов.                                             | Подходит для многократного выполнения запросов с изменяющимися параметрами (например, циклическое выполнение с разными значениями). |



[К оглавлению](#SQL)

# 26. Что такое ResultSet?
ResultSet — это интерфейс в Java, который используется для хранения и обработки результатов, полученных в результате выполнения SQL-запроса через JDBC. Когда вы выполняете SQL-запрос с использованием объектов Statement или PreparedStatement, результат этого запроса возвращается в виде объекта ResultSet. Этот объект представляет собой таблицу данных (состоящую из строк и столбцов), которую можно перебрать и обработать.
#### Основные характеристики ResultSet:
+ Табличное представление данных: ResultSet похож на таблицу, где строки соответствуют строкам в базе данных, а столбцы — столбцам. Можно получить данные из каждой строки и каждого столбца.
+ Навигация по данным: ResultSet позволяет перемещаться по строкам данных, извлекать значения из столбцов и получать доступ к результатам запроса.
#### Как получить ResultSet?
Для получения ResultSet выполняется SQL-запрос с помощью Statement или PreparedStatement:
```java
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM users");
```
#### Методы работы с ResultSet:
1. Навигация по строкам:
+ boolean next() — перемещается к следующей строке в результате. Возвращает false, если больше строк нет.
+ boolean previous() — перемещается к предыдущей строке (если ResultSet поддерживает это).
+ boolean first() — перемещается к первой строке. 
+ boolean last() — перемещается к последней строке.  
+ void beforeFirst() — устанавливает курсор перед первой строкой. 
+ void afterLast() — устанавливает курсор после последней строки. 
+ boolean absolute(int row) — перемещается к указанной строке.
2. Извлечение данных из текущей строки:
+ int getInt(int columnIndex) — получить значение столбца в виде int по индексу.  
+ String getString(String columnName) — получить значение столбца в виде строки по имени столбца. 
+ double getDouble(int columnIndex) — получить значение столбца в виде double. 
+ boolean getBoolean(String columnName) — получить булевое значение из указанного столбца.
3. Типы данных и методы извлечения: В ResultSet есть методы для получения данных различных типов:
+ getInt(), getLong(), getFloat(), getDouble()
+ getString()
+ getDate()
+ getTime()
+ getTimestamp()
```java
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT id, name, age FROM users");

while (rs.next()) {
int id = rs.getInt("id");         // Получаем значение столбца "id"
String name = rs.getString("name"); // Получаем значение столбца "name"
int age = rs.getInt("age");         // Получаем значение столбца "age"

    System.out.println("ID: " + id + ", Name: " + name + ", Age: " + age);
}

// Закрываем ResultSet и Statement после использования
rs.close();
stmt.close();
```
#### Типы ResultSet:
1. Типы по возможностям навигации:
+ ResultSet.TYPE_FORWARD_ONLY — позволяет перемещаться только вперед по строкам. 
+ ResultSet.TYPE_SCROLL_INSENSITIVE — позволяет перемещаться вперед и назад. Однако изменения в базе данных после получения результата не будут видны. 
+ ResultSet.TYPE_SCROLL_SENSITIVE — позволяет перемещаться вперед и назад, при этом изменения в базе данных будут видны в ResultSet.
2. Типы по возможностям изменения:
+ ResultSet.CONCUR_READ_ONLY — данные доступны только для чтения. 
+ ResultSet.CONCUR_UPDATABLE — данные можно обновлять.
```java
Пример создания скроллируемого и обновляемого ResultSet:

Statement stmt = conn.createStatement(
ResultSet.TYPE_SCROLL_INSENSITIVE,
ResultSet.CONCUR_UPDATABLE
);
ResultSet rs = stmt.executeQuery("SELECT * FROM users");
```
#### Методы обновления данных:
Если ResultSet имеет тип CONCUR_UPDATABLE, можно изменять данные прямо в результате:
+ updateString(String columnLabel, String value) — обновить значение в текущей строке.
+ updateRow() — применить изменения к текущей строке.
+ deleteRow() — удалить текущую строку.
+ insertRow() — добавить новую строку.

[К оглавлению](#SQL)

# 27. В чем разница между методами execute, executeUpdate, executeQuery?
В JDBC интерфейсе для выполнения SQL-запросов используются три основных метода: execute, executeUpdate, и executeQuery. Эти методы принадлежат интерфейсу Statement (и его расширениям, таким как PreparedStatement), и каждый из них служит для выполнения различных типов SQL-запросов.
1. Метод executeQuery используется исключительно для выполнения SELECT-запросов, то есть запросов, которые возвращают данные из базы данных. Он возвращает объект ResultSet, представляющий результат запроса в виде таблицы данных.
```java
String sql = "SELECT * FROM users WHERE age > 18";
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(sql);

while (rs.next()) {
    System.out.println("User ID: " + rs.getInt("id"));
}
```
#### Особенности:
+ Используется только для запросов на получение данных (SELECT).
+ Возвращает объект ResultSet, содержащий строки результата.
+ Если использовать executeQuery для запросов, которые не возвращают данные (например, INSERT, UPDATE), это вызовет исключение.
2. Метод executeUpdate используется для выполнения DML-запросов (Data Manipulation Language), таких как INSERT, UPDATE, и DELETE, а также DDL-запросов (Data Definition Language), таких как CREATE, ALTER, и DROP. Он возвращает целое число, которое показывает количество строк, затронутых запросом.
```java
String sql = "UPDATE users SET age = age + 1 WHERE id = 10";
Statement stmt = conn.createStatement();
int rowsAffected = stmt.executeUpdate(sql);

System.out.println("Rows affected: " + rowsAffected);
```
#### Особенности:
+ Используется для модификации данных в базе (INSERT, UPDATE, DELETE).
+ Возвращает количество строк, затронутых запросом.
+ Если выполнить UPDATE, который не затронет ни одной строки, метод вернет 0.
3. Метод execute является универсальным методом, который можно использовать для выполнения любого SQL-запроса. Он возвращает значение типа boolean, которое указывает, был ли результатом запроса объект ResultSet (например, при SELECT-запросе).
```java
String sql = "CREATE TABLE new_users (id INT PRIMARY KEY, name VARCHAR(50))";
Statement stmt = conn.createStatement();
boolean hasResultSet = stmt.execute(sql);

if (hasResultSet) {
    ResultSet rs = stmt.getResultSet();
    // Обработка ResultSet
} else {
    int updateCount = stmt.getUpdateCount();
    System.out.println("Update count: " + updateCount);
}
```
#### Особенности:
+ Возвращает true, если запрос вернул объект ResultSet (например, SELECT), и false в противном случае (например, при INSERT, UPDATE, DELETE).
+ Если false, то можно использовать метод getUpdateCount(), чтобы узнать количество затронутых строк.
+ Если true, то можно использовать метод getResultSet() для получения объекта ResultSet.
#### Когда использовать какой метод:
+ executeQuery — когда ожидается результат в виде таблицы (например, при SELECT-запросах).
+ executeUpdate — когда нужно изменить данные (например, вставка, обновление или удаление строк) или изменить структуру таблицы.
+ execute — когда тип запроса заранее не известен или требуется универсальное решение (например, когда SQL-запрос динамически создается).

  | Метод         | Используется для                            | Возвращаемое значение                          | Примеры запросов                        |
  |---------------|---------------------------------------------|------------------------------------------------|-----------------------------------------|
  | executeQuery  | SELECT-запросы                              | ResultSet (результаты выборки)                 | SELECT * FROM users                     |
  | executeUpdate | INSERT, UPDATE, DELETE, CREATE, ALTER, DROP | int (количество затронутых строк)              | INSERT INTO users ..., UPDATE users ... |
  | execute       | Любые SQL-запросы                           | boolean (true для SELECT, false для остальных) | SELECT ..., INSERT ..., CREATE ...      |


[К оглавлению](#SQL)

# 28. Можно ли использовать возвращаемое значение метода execute для проверки, что что-то обновилось?
Да, можно использовать возвращаемое значение метода execute для проверки, что в базе данных что-то обновилось, но это требует немного больше шагов по сравнению с использованием более специфичных методов, таких как executeUpdate
#### Как работает метод execute
Метод execute возвращает значение типа boolean:
+ true, если запрос вернул ResultSet (например, при выполнении SELECT).
+ false, если запрос не вернул ResultSet (например, при выполнении INSERT, UPDATE, или DELETE). Если execute возвращает false, это означает, что запрос был DML-запросом (Data Manipulation Language), и можно использовать метод getUpdateCount(), чтобы проверить количество затронутых строк.

#### Как проверить, что что-то обновилось:
+ Выполнить запрос с помощью метода execute.
+ Проверить значение getUpdateCount() — этот метод вернет количество строк, затронутых последним DML-запросом. Если getUpdateCount() возвращает значение больше нуля, это означает, что изменения были произведены.
Если getUpdateCount() возвращает 0, это означает, что ни одна строка не была затронута.
```java
String sql = "UPDATE users SET age = age + 1 WHERE id = 10";
Statement stmt = conn.createStatement();
boolean hasResultSet = stmt.execute(sql);

if (!hasResultSet) {
    int rowsAffected = stmt.getUpdateCount();
    if (rowsAffected > 0) {
        System.out.println("Rows updated: " + rowsAffected);
    } else {
        System.out.println("No rows were updated.");
    }
} else {
    System.out.println("The query returned a ResultSet.");
}
```
#### Когда использовать:
+ Метод execute полезен, если вы хотите использовать универсальный подход к выполнению запросов и не знаете заранее, какой тип запроса будете выполнять.
+ Однако, если вы точно знаете, что будете выполнять DML-запрос (например, INSERT, UPDATE, DELETE), предпочтительнее использовать executeUpdate, так как он сразу возвращает количество затронутых строк без необходимости дополнительной проверки через getUpdateCount().

[К оглавлению](#SQL)

# 29. Как получить при вставке сгенерированные ключи? Как это сделать на чистом sql?
На чистом SQL для получения сгенерированных ключей можно использовать такие конструкции, как RETURNING, LAST_INSERT_ID(), или OUTPUT в зависимости от СУБД. В JDBC используется флаг RETURN_GENERATED_KEYS и метод getGeneratedKeys(). Этот подход делает работу с автоматическими ключами в Java более удобной и стандартизированной, независимо от используемой базы данных.
1.  На чистом SQL. В SQL есть ключевое слово RETURNING(поля), которое мы можем использовать в запросе. В итоге запрос вставки будет выглядеть так:
```java
INSERT INTO cities(name, population) VALUES ('Ufa', 1000000) RETURNING (id);
```
2. С использованием JDBC. Для того чтобы получить id. Нужно при создании PreparedStatement вторым аргументом передать Statement.RETURN_GENERATED_KEYS. После как обычно выполнить запрос. Наконец, чтобы получить ключ нужно вызвать метод getGeneratedKeys(). 
```java
public City insert(City city) {
    try (PreparedStatement statement =
                 connection.prepareStatement("INSERT INTO cities(name, population) VALUES (?, ?)",
                         Statement.RETURN_GENERATED_KEYS)) {
        statement.setString(1, city.getName());
        statement.setInt(2, city.getPopulation());
        statement.execute();
        try (ResultSet generatedKeys = statement.getGeneratedKeys()) {
            if (generatedKeys.next()) {
                city.setId(generatedKeys.getInt(1));
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return city;
}
```
[К оглавлению](#SQL)

# 30. Для чего используется конструкция try-with-resources?
Конструкция try-with-resources в Java используется для автоматического управления ресурсами, такими как Statement, PreparedStatement, Connection, и другие классы, реализующие интерфейс AutoCloseable. Эта конструкция позволяет автоматически закрывать ресурсы, когда они больше не нужны, даже в случае возникновения исключений, что предотвращает утечки ресурсов и освобождает разработчика от необходимости вручную закрывать ресурсы в блоке finally.
#### Что делает try-with-resources?
Когда вы используете try-with-resources, Java автоматически вызывает метод close() на всех ресурсах, которые были открыты в try-блоке. Это происходит независимо от того, было ли выброшено исключение в блоке try или нет. Это особенно важно для таких ресурсов, как подключения к базе данных и потоки ввода/вывода, которые необходимо закрывать, чтобы избежать утечек памяти или блокировок.
```java
String sql = "SELECT * FROM users";
try (Connection conn = DriverManager.getConnection(url, username, password);
     Statement stmt = conn.createStatement();
     ResultSet rs = stmt.executeQuery(sql)) {
    
    // Работаем с данными результата
    while (rs.next()) {
        System.out.println("User ID: " + rs.getInt("id"));
        System.out.println("User Name: " + rs.getString("name"));
    }
    
} catch (SQLException e) {
    e.printStackTrace();
}

Connection, Statement и ResultSet объявляются в круглых скобках 
после ключевого слова try.
Все три ресурса автоматически закрываются в конце блока try,
даже если возникает исключение.
Нет необходимости вручную писать close() для каждого 
ресурса в блоке finally, что делает код чище и проще.
```
```java
String sql = "INSERT INTO users (name, email) VALUES (?, ?)";
try (Connection conn = DriverManager.getConnection(url, username, password);
     PreparedStatement pstmt = conn.prepareStatement(sql)) {
    
    pstmt.setString(1, "John Doe");
    pstmt.setString(2, "john.doe@example.com");
    pstmt.executeUpdate();
    
} catch (SQLException e) {
    e.printStackTrace();
}
```
#### Почему это важно?
+ Упрощает код: Нет необходимости явно закрывать ресурсы. Это уменьшает количество кода и снижает риск ошибок.
+ Предотвращает утечки ресурсов: Если ресурс не будет закрыт, это может привести к утечке памяти, проблемам с подключением к базе данных и другим неожиданным сбоям.
+ Безопасность при исключениях: Даже если в блоке try произойдет ошибка, ресурсы все равно будут закрыты, так как вызов close() гарантирован в конце блока.
#### Как это работает?
Все ресурсы, используемые в try-with-resources, должны реализовывать интерфейс AutoCloseable, который содержит метод close(). В случае с JDBC, такие классы, как Connection, Statement, PreparedStatement, и ResultSet уже реализуют этот интерфейс, поэтому их можно безопасно использовать в конструкции try-with-resources.

[К оглавлению](#SQL)

