## SQL

[1. Что такое SQL?](#1-Что-такое-SQL)

[2. Что такое DML и DDL?](#2-Что-такое-DML-и-DDL)

[3. Что такое первичный ключ?](#3-Что-такое-первичный-ключ)

[4. Что такое внешний ключ?](#4-Что-такое-внешний-ключ)

[5. Какие виды связей между таблицами существуют и как они организуются?](#5-Какие-виды-связей-между-таблицами-существуют-и-как-они-организуются)

[6. Опишите как вставить, удалить, обновить данные в, из таблицы.](#6-опишите-как-вставить-удалить-обновить-данные-в-из-таблицы)

[7. Что такое нормализация БД?](#7-Что-такое-нормализация-БД)

[8. Что такое денормализация БД? Для чего она нужна?](#8-Что-такое-денормализация-БД-Для-чего-она-нужна)

[9. Что такое кластерный и некластерный индексы?](#9-Что-такое-кластерный-и-некластерный-индексы)

[10. Какие типы соединений join таблиц существуют? В чем их разница?](#10-Какие-типы-соединений-join-таблиц-существуют-В-чем-их-разница)

[11. Что такое SQL курсор?](#11-Что-такое-SQL-курсор)

[12. Опишите шаги по созданию и использованию курсора.](#12-Опишите-шаги-по-созданию-и-использованию-курсора)

[13. Что такое транзакция?](#13-Что-такое-транзакция)

[14. Что такое триггер? Какие типы триггеров Вы знаете?](#14-Что-такое-триггер-Какие-типы-триггеров-Вы-знаете)

[15. В чем разница между where и having?](#15-В-чем-разница-между-where-и-having)

[16. Что такое подзапрос sub-query?](#16-Что-такое-подзапрос-sub-query)

[17. Что такое union?](#17-Что-такое-union)

[18. Что такое group by?](#18-Что-такое-group-by)

[19. Что такое хранимые процедуры?](#19-Что-такое-хранимые-процедуры)

[20. Что такое view представление?](#20-Что-такое-view-представление)

[21. Что такое JDBC?](#21-Что-такое-JDBC)

[22. Что нужно для работы с той или иной БД?](#22-Что-нужно-для-работы-с-той-или-иной-БД)

[23. Как зарегистрировать драйвер?](#23-Как-зарегистрировать-драйвер)

[24. Как получить Connection?](#24-Как-получить-Connection)

[25. Что такое Statement, PreparedStatement? В чем разница между ними?](#25-Что-такое-Statement-PreparedStatement-В-чем-разница-между-ними)

[26. Что такое ResultSet?](#26-Что-такое-ResultSet)

[27. В чем разница между методами execute, executeUpdate, executeQuery?](#27-В-чем-разница-между-методами-execute-executeUpdate-executeQuery)

[28. Можно ли использовать возвращаемое значение метода execute для проверки, что что-то обновилось?](#28-Можно-ли-использовать-возвращаемое-значение-метода-execute-для-проверки-что-что-то-обновилось)

[29. Как получить при вставке сгенерированные ключи? Как это сделать на чистом sql?](#29-Как-получить-при-вставке-сгенерированные-ключи-Как-это-сделать-на-чистом-sql)

[30. Для чего используется конструкция try-with-resources?](#30-Для-чего-используется-конструкция-try-with-resources)

# 1. Что такое SQL?

SQL (Structured Query Language) — это язык структурированных запросов, используемый для работы с базами данных. Он предназначен для управления и манипулирования данными в реляционных базах данных (RDBMS), таких как MySQL, PostgreSQL, Oracle, SQL Server и другие.
#### Основные задачи SQL
+ Запрос данных — получение информации из базы данных с помощью SELECT.
+  Вставка данных — добавление новых записей в таблицы базы данных с помощью INSERT.
+  Обновление данных — изменение существующих данных в таблицах с помощью UPDATE.
+  Удаление данных — удаление записей из таблиц с помощью DELETE.
+  Создание структур — создание новых таблиц, баз данных, индексов и других объектов с помощью CREATE.
+  Изменение структур — модификация существующих объектов базы данных с помощью ALTER.
+ Удаление структур — удаление объектов базы данных с помощью DROP.
+  Управление доступом — предоставление или ограничение доступа к базе данных с помощью GRANT и REVOKE.

[К оглавлению](#SQL)

# 2. Что такое DML и DDL?

`DML (Data Manipulation Language)` — запросы для изменения данных:
+ INSERT — добавляет данные в таблицу.
+ UPDATE — обновляет данные.
+ DELETE — удаляет данные.

`DDL (Data Definition Language)` — команды для работы со структурой базы данных:
+ CREATE — создает новые объекты, такие как таблицы или базы данных.
+ ALTER — изменяет структуру существующих объектов.
+ DROP — удаляет объекты, такие как таблицы или базы данных.
+ TRUNCATE — удаляет все записи из таблицы, но сохраняет структуру.

`DCL (Data Control Language)` — управление доступом к данным:
+ GRANT — предоставляет права пользователю или роли.
+ REVOKE — отзывает права у пользователя или роли.

`TCL (Transaction Control Language`) — команды для управления транзакциями:
+ COMMIT — фиксирует изменения в базе данных.
+ ROLLBACK — отменяет изменения, если что-то пошло не так.
+ SAVEPOINT устанавливает точку сохранения внутри транзакции для возможного отката.

[К оглавлению](#SQL)

# 3. Что такое первичный ключ?
Первичный ключ (Primary Key) — это специальное ограничение в реляционных базах данных, которое обозначает уникальный идентификатор каждой записи (строки) в таблице. Первичный ключ гарантирует, что значения в этом столбце (или наборе столбцов) будут уникальными и не будут пустыми (NULL).
#### Зачем нужен первичный ключ?
+ Уникальность: Первичный ключ обеспечивает уникальность каждой записи в таблице, что позволяет легко отличать одну запись от другой.
+ Целостность данных: Значения первичного ключа не могут быть NULL. Это гарантирует, что каждая запись будет иметь уникальный идентификатор.
+ Производительность: Первичный ключ часто используется базой данных для оптимизации поиска данных. Он обычно связан с индексом, что ускоряет операции чтения.
+ Связи между таблицами: Первичный ключ используется для создания связей между таблицами через внешний ключ (Foreign Key), что позволяет строить реляционные структуры и обеспечивать целостность данных.
#### Правила и ограничения первичного ключа
+ Значение должно быть уникальным в пределах таблицы.
+ Значение не может быть NULL.
+ В таблице может быть только один первичный ключ, но он может состоять из нескольких столбцов (так называемый составной первичный ключ).
```java
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,  -- user_id является первичным ключом
    name VARCHAR(100),
    email VARCHAR(100) UNIQUE,
    registration_date DATE
);

В этом примере user_id — это первичный ключ. Он уникален для каждой строки, 
и каждая запись будет иметь свое уникальное значение в этом столбце.
```
#### Составной первичный ключ
В некоторых случаях требуется использовать несколько столбцов для уникальной идентификации строки. В таких ситуациях создают составной первичный ключ:
```java
CREATE TABLE orders (
    order_id INT,
    product_id INT,
    order_date DATE,
    PRIMARY KEY (order_id, product_id)  -- Составной первичный ключ
);
Здесь уникальной записью будет комбинация значений order_id и product_id. Это означает, 
что в одной и той же таблице могут быть несколько записей с одинаковым order_id, 
но они должны отличаться по product_id.
```
#### Преимущества использования первичного ключа
+ Упрощение поиска: Благодаря индексации, поиск по первичному ключу выполняется очень быстро.
+  Защита данных: Первичный ключ предотвращает дублирование данных.
 + Связи между таблицами: Позволяет создавать реляционные связи между таблицами через внешний ключ.

[К оглавлению](#SQL)

# 4. Что такое внешний ключ?
Внешний ключ (Foreign Key) —  это механизм, который помогает поддерживать структурные связи между таблицами в реляционных базах данных и гарантировать целостность данных. Он связывает данные между таблицами, предоставляя надежный способ управления связями и предотвращая ошибки, связанные с некорректными ссылками.
#### Зачем нужен внешний ключ?
+ Обеспечение целостности данных: Внешний ключ гарантирует, что значение в одной таблице (таблице-потомке) должно соответствовать существующему значению в другой таблице (таблице-родителе).
+ Связи между таблицами: Внешние ключи позволяют установить связи между таблицами, что помогает строить сложные реляционные структуры.
+ Поддержка ссылочной целостности: Внешний ключ обеспечивает автоматическую проверку данных, предотвращая удаление или изменение записей в родительской таблице, если они используются в таблице-потомке.
```java
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);

CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    order_date DATE NOT NULL,
    customer_id INT,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);

customer_id в таблице customers — это первичный ключ.
customer_id в таблице orders — это внешний ключ, 
который ссылается на customer_id в таблице customers.
```
#### Правила и ограничения внешнего ключа
+ Ссылочная целостность: Значение внешнего ключа в таблице-потомке должно соответствовать существующему значению первичного ключа в таблице-родителе, или быть NULL.
+ Удаление и обновление: При удалении или обновлении строки в таблице-родителе можно использовать каскадные операции, чтобы изменения автоматически отражались в таблице-потомке.

#### Каскадные операции
При использовании внешних ключей можно настроить каскадные операции для управления связанными данными:
+ ON DELETE CASCADE: Если запись в родительской таблице удаляется, все связанные записи в таблице-потомке также будут удалены.
```java
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    order_date DATE NOT NULL,
    customer_id INT,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id) ON DELETE CASCADE
);
```
ON UPDATE CASCADE: Если значение первичного ключа в родительской таблице обновляется, связанные значения во внешнем ключе также обновляются.
```java
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    order_date DATE NOT NULL,
    customer_id INT,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id) ON UPDATE CASCADE
);
```
```java
Пример использования внешнего ключа с каскадными операциями

CREATE TABLE departments (
        department_id SERIAL PRIMARY KEY,
        name VARCHAR(100)
);

CREATE TABLE employees (
        employee_id SERIAL PRIMARY KEY,
        name VARCHAR(100),
department_id INT,
FOREIGN KEY (department_id) REFERENCES departments(department_id) ON DELETE SET NULL
);

Если удалить запись из таблицы departments, то в таблице employees поле department_id 
для связанных сотрудников будет установлено в NULL, благодаря ON DELETE SET NULL.
```
#### Преимущества использования внешнего ключа
+ Поддержка целостности данных: Внешний ключ предотвращает несогласованные изменения данных, такие как удаление записи, на которую есть ссылки.
+ Упрощение связей между таблицами: Использование внешних ключей позволяет строить сложные реляционные связи между таблицами.
+ Автоматизация действий: Каскадные операции позволяют автоматизировать удаление или обновление данных, связанные с родительскими записями.

[К оглавлению](#SQL)

# 5. Какие виды связей между таблицами существуют и как они организуются?
Связи между таблицами в реляционных базах данных позволяют организовать структуру данных и поддерживать целостность. Основные виды связей включают один к одному, один ко многим, многие ко многим, и каждая из них имеет свои особенности и способы организации.
1. Один к одному (One-to-One) Это связь, при которой одной записи в одной таблице соответствует ровно одна запись в другой таблице.
+ Чаще всего связь "один к одному" реализуется с помощью внешнего ключа в одной из таблиц, который также является первичным ключом.
+ Можно использовать одну таблицу для хранения данных, но иногда данные разделяют для лучшей организации или безопасности.
```java
Представим, что есть таблица users (пользователи) и таблица user_profiles 
(профили пользователей),где каждому пользователю соответствует один профиль

CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(100) NOT NULL
);

CREATE TABLE user_profiles (
    profile_id SERIAL PRIMARY KEY,
    user_id INT UNIQUE,
    bio TEXT,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

Здесь user_id в таблице user_profiles — это внешний ключ, к
оторый также уникален, чтобы связь была "один к одному".
```
2. Один ко многим (One-to-Many) Это наиболее распространённая связь, при которой одной записи в одной таблице соответствует несколько записей в другой таблице.
+ Реализуется с помощью внешнего ключа в дочерней таблице (таблица, содержащая много записей).
+ Обычный пример — связь между таблицей категорий и таблицей товаров, где каждой категории соответствует несколько товаров.
```java
CREATE TABLE categories (
    category_id SERIAL PRIMARY KEY,
    category_name VARCHAR(100) NOT NULL
);

CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL,
    category_id INT,
    FOREIGN KEY (category_id) REFERENCES categories(category_id)
);

Здесь category_id в таблице products — внешний ключ, 
который связывает продукты с категориями.
```
3. Многие ко многим (Many-to-Many) Это связь, при которой нескольким записям в одной таблице соответствуют несколько записей в другой таблице.
+ Реализуется через связующую таблицу (или промежуточную таблицу), которая содержит внешние ключи на обе связанные таблицы.
+ В связующей таблице каждая комбинация внешних ключей описывает связь между двумя записями.
```java
Представим, что у нас есть таблицы students (студенты) и courses (курсы), 
и каждый студент может посещать несколько курсов, 
а каждый курс может иметь несколько студентов

CREATE TABLE students (
    student_id SERIAL PRIMARY KEY,
    student_name VARCHAR(100) NOT NULL
);

CREATE TABLE courses (
    course_id SERIAL PRIMARY KEY,
    course_name VARCHAR(100) NOT NULL
);

CREATE TABLE student_courses (
    student_id INT,
    course_id INT,
    PRIMARY KEY (student_id, course_id),
    FOREIGN KEY (student_id) REFERENCES students(student_id),
    FOREIGN KEY (course_id) REFERENCES courses(course_id)
);

Здесь student_courses — это связующая таблица, которая устанавливает 
связь "многие ко многим" между студентами и курсами.
```
4. Самосвязанная (Self-Referencing) связь. Иногда требуется установить связь внутри одной таблицы, например, для построения иерархий.
+ Используется внешний ключ, который ссылается на первичный ключ в той же таблице.
```java
Предположим, что у нас есть таблица employees (сотрудники), 
где каждый сотрудник может иметь начальника

CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    employee_name VARCHAR(100),
    manager_id INT,
    FOREIGN KEY (manager_id) REFERENCES employees(employee_id)
);

Здесь manager_id — это внешний ключ, который ссылается на employee_id 
в той же таблице, создавая связь между сотрудником и его начальником.
```
#### Сводная таблица: Типы связей и их особенности

| Тип связи              | Пример                    | Организация                                                                  | Характеристики                                                                                                                                                                   |
|------------------------|---------------------------|------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Один к одному          | Пользователь и профиль    | Внешний ключ в одной таблице, уникальный для каждой записи                   | Каждой записи в одной таблице соответствует ровно одна запись в другой. Используется для данных, которые можно разделить на отдельные категории.                                 |
| Один ко многим         | Категория и товары        | Внешний ключ в дочерней таблице                                              | Каждой записи в родительской таблице соответствует несколько записей в дочерней. Самая распространённая связь для организации связанных данных.                                  |
| Многие ко многим       | Студенты и курсы          | Промежуточная таблица с внешними ключами на обе связанные таблицы            | Несколько записей в одной таблице могут быть связаны с несколькими записями в другой. Используется для сложных связей, таких как объединение студентов и курсов, книг и авторов. |
| Самосвязанная          | Сотрудники и начальники   | Внешний ключ в таблице, который ссылается на первичный ключ в той же таблице | Используется для построения иерархических структур, таких как дерево категорий, сотрудники и начальники. Позволяет хранить иерархические отношения внутри одной таблицы.         |


[К оглавлению](#SQL)

# 6. Опишите как вставить, удалить, обновить данные в, из таблицы.
1. Вставка данных в таблицу (INSERT INTO)
```java
INSERT INTO table_name (column1, column2, column3)
VALUES (value1, value2, value3);


Вставка нескольких записей:

INSERT INTO table_name (column1, column2, column3)
VALUES
(value1_1, value1_2, value1_3),
(value2_1, value2_2, value2_3),
(value3_1, value3_2, value3_3);

```
2. Удаление данных из таблицы (DELETE FROM)
```java
Удаление с условием:

DELETE FROM table_name
WHERE condition;

Удаление всех записей:

DELETE FROM table_name;

Удалим всех сотрудников из департамента HR:

DELETE FROM employees
WHERE department = 'HR';
```
3. Обновление данных в таблице (UPDATE)
```java
Обновление с условием:

UPDATE table_name
SET column1 = value1, column2 = value2
WHERE condition;


Обновление всех записей:

UPDATE table_name
SET column1 = value1, column2 = value2;

Обновим департамент всех сотрудников с фамилией 'Doe' на IT:

UPDATE employees
SET department = 'IT'
WHERE last_name = 'Doe';
```
| Операция                | SQL-команда     | Примерный синтаксис                                                |
|-------------------------|-----------------|--------------------------------------------------------------------|
| Вставка                 | INSERT INTO     | INSERT INTO table_name (column1, column2) VALUES (value1, value2); |
| Удаление                | DELETE FROM     | DELETE FROM table_name WHERE condition;                            |
| Обновление              | UPDATE          | UPDATE table_name SET column1 = value1 WHERE condition;            |
#### Нюансы.
+ Если у таблицы есть поле, которое автоматически увеличивается (например, SERIAL в PostgreSQL или AUTO_INCREMENT в MySQL), то его можно пропустить при вставке
```java
INSERT INTO employees (first_name, last_name, department)
VALUES ('Jane', 'Smith', 'Finance');

employee_id будет автоматически присвоено
```
+ Если требуется удалить все записи из таблицы, лучше использовать команду TRUNCATE, так как она более эффективна и быстрее освобождает ресурсы
```java
TRUNCATE TABLE table_name;
```
+ Чтобы избежать случайных изменений всех записей в таблице, рекомендуется всегда использовать условия (WHERE) при операциях DELETE и UPDATE.
```java
DELETE FROM employees WHERE employee_id = 10;
UPDATE employees SET department = 'Sales' WHERE department = 'Marketing';
```
+ Для критически важных операций, таких как массовые обновления или удаления, лучше использовать транзакции
```java
BEGIN;

-- Операции вставки, удаления или обновления
UPDATE employees SET department = 'Support' WHERE department = 'Customer Service';

COMMIT;

Если что идет не так - отменям транзакцию:

ROLLBACK;

Транзакции помогают обеспечить целостность данных, особенно в случаях, 
когда операции включают несколько связанных изменений.
```

[К оглавлению](#SQL)

# 7. Что такое нормализация БД?
Нормализация базы данных — это процесс организации данных в таблицах базы данных с целью минимизации избыточности данных и улучшения их целостности. Она включает в себя разделение данных на отдельные связанные таблицы и определение правильных связей между ними. Основная цель нормализации — устранить аномалии вставки, обновления и удаления данных.

#### Зачем нужна нормализация?
+ Избегание дублирования данных — уменьшение избыточности помогает уменьшить количество ошибок и объем хранимых данных.
+ Повышение целостности данных — снижение риска несоответствий в данных и улучшение качества информации.
+ Упрощение поддержки и изменения данных — проще обновлять и расширять структуру данных.
+ Оптимизация использования памяти — экономия ресурсов за счет хранения данных в более компактной форме.
#### Формы нормализации.
+ Первая нормальная форма (1NF)
Каждое поле должно содержать только одно значение, а таблица не должна иметь повторяющихся групп.

Требования: Каждая ячейка таблицы содержит только одно значение.
Все строки таблицы должны быть уникальными.
+ Вторая нормальная форма (2NF) Таблица должна быть в 1NF, и все неключевые поля должны зависеть от первичного ключа целиком.

Требования: Устранить частичные зависимости (когда часть составного ключа определяет атрибут).
Если есть составной ключ, неключевые атрибуты должны зависеть от всех частей ключа. 

Пример: Если у нас есть таблица orders, в которой составной первичный ключ состоит из order_id и product_id, но поле product_name зависит только от product_id, нужно вынести информацию о продуктах в отдельную таблицу.
+ Третья нормальная форма (3NF) Таблица должна быть в 2NF, и все неключевые поля должны зависеть только от первичного ключа и не иметь транзитивных зависимостей.

Требования: Устранить транзитивные зависимости (когда одно поле зависит от другого неключевого поля, которое, в свою очередь, зависит от первичного ключа).

Пример: Если в таблице employees есть поле department_location, и оно зависит от department, а не от employee_id, то данные о департаментах лучше вынести в отдельную таблицу.

[К оглавлению](#SQL)

# 8. Что такое денормализация БД? Для чего она нужна?
Денормализация базы данных — это процесс обратный нормализации, который предполагает намеренное добавление избыточности данных для улучшения производительности чтения. Денормализация используется, чтобы уменьшить количество сложных операций JOIN и ускорить выполнение запросов, особенно когда приоритетом является скорость чтения, а не экономия места.
#### Зачем нужна денормализация?
+ Ускорение чтения данных — уменьшение количества JOIN операций между таблицами, которые могут быть медленными на больших объемах данных.
+ Упрощение запросов — денормализованные данные позволяют составлять более простые и быстрые запросы.
+ Оптимизация для аналитики — в аналитических и отчетных системах важнее быстрее извлекать данные, чем экономить место.
#### Преимущества денормализации
+ Ускорение выборки — уменьшение количества операций JOIN делает запросы быстрее, особенно если данные часто читаются.
+ Упрощение аналитических запросов — доступ к нужным данным напрямую упрощает создание отчетов.
+ Снижение нагрузки на базу — меньшее количество сложных запросов уменьшает нагрузку на сервер базы данных.
#### Недостатки денормализации
+ Избыточность данных — при денормализации те же данные могут храниться в нескольких местах, что увеличивает объем базы данных.
+ Риск несогласованности данных — изменение данных в одном месте требует их обновления во всех местах, что увеличивает риск ошибок.
+ Усложнение операций записи — при изменении данных нужно обновлять несколько таблиц, что может замедлить вставку и обновление.
#### Когда стоит использовать денормализацию?
+ Большие объемы данных — когда база данных содержит миллионы записей, JOIN операции могут замедлить выполнение запросов.
+ Чтение важнее записи — если система ориентирована на чтение данных (например, отчетные и аналитические системы), денормализация может помочь.
+ Отсутствие сложных транзакций — если база данных редко изменяется и не требует частых обновлений, денормализация оправдана.
+ Необходимость в real-time отчетах — в системах, где важно быстро получать аналитические данные, денормализация может упростить жизнь.
#### Баланс между нормализацией и денормализацией
+ Нормализация: хороша для сохранения целостности данных, устранения избыточности и экономии памяти.
+ Денормализация: подходит для случаев, когда требуется высокая скорость чтения, особенно при работе с большими объемами данных.
#### Примеры денормализации в реальной жизни
+ Аналитические базы данных — данные часто денормализуются для отчетов и аналитики, чтобы быстро создавать сводки и отчеты.
+ Кэширование данных — если данные редко меняются, их можно сохранить в денормализованной форме в кэше для ускорения доступа.
+ Системы рекомендаций — в системах, где требуется быстрое агрегирование информации, данные могут быть денормализованы для упрощения получения рекомендаций.

[К оглавлению](#SQL)

# 9. Что такое кластерный и некластерный индексы?
Кластерный и некластерный индексы — это два типа индексов, используемых в базах данных для ускорения операций поиска и повышения производительности запросов. Они оба влияют на способ хранения и доступа к данным, но различаются по структуре и применению.

1. Кластерный индекс (Clustered Index) определяет физический порядок строк в таблице на диске. Он действует как основная организация данных, поэтому таблица может иметь только один кластерный индекс.
+ Как работает: В таблице с кластерным индексом строки физически хранятся на диске в порядке, соответствующем значениям, по которым создан индекс. Это значит, что строки в таблице отсортированы по ключу кластерного индекса.
 
Пример: Если таблица содержит столбец id, который является кластерным индексом, то данные будут физически отсортированы на диске по значениям этого столбца.
+ Преимущества: Ускоряет доступ к данным при поиске по полю кластерного индекса.
Быстрый доступ к диапазонам данных, так как строки отсортированы.
+ Недостатки: Вставка новых данных может быть медленной, так как они должны вставляться в определенное место, чтобы поддерживать порядок.
Изменение значения кластерного ключа может привести к перемещению данных на диске.
+ Применение: Обычно используется для столбцов, которые часто используются для фильтрации или сортировки данных, например, первичный ключ (PRIMARY KEY), идентификаторы и даты.

2. Некластерный индекс (Non-Clustered Index) создается отдельно от основного порядка хранения данных. Он содержит указатели на физическое расположение строк в таблице. Таблица может иметь несколько некластерных индексов.
+ Как работает: Некластерный индекс создаёт отдельную структуру, которая хранит значения индекса и ссылки на физическое расположение соответствующих строк в таблице. Данные в таблице не сортируются физически по этому индексу.

Пример: Если в таблице есть некластерный индекс по столбцу name, то создается структура, которая содержит все значения name в отсортированном виде с указателями на строки, где эти значения находятся.
+ Преимущества: Ускоряет поиск по полям, которые не являются частью кластерного индекса.
Можно иметь несколько некластерных индексов, что позволяет оптимизировать запросы под разные условия.
+ Недостатки: Некластерный индекс занимает дополнительное пространство на диске, так как хранит ссылки на данные.
Поиск по некластерному индексу может быть медленнее, чем по кластерному, так как требуется дополнительное обращение к таблице для получения данных.
+ Применение: Используется для столбцов, которые часто используются в WHERE, ORDER BY, GROUP BY запросах, но не для сортировки всей таблицы.
#### Когда использовать кластерный и некластерный индексы?
+ Кластерный индекс подходит, если нужно часто фильтровать или сортировать данные по ключу. Например, по дате или идентификатору.
+ Некластерный индекс полезен для оптимизации поиска по столбцам, которые не связаны с сортировкой всей таблицы.
#### Основные отличия:
| Критерий                  | Кластерный индекс                                | Некластерный индекс                           |
|---------------------------|--------------------------------------------------|-----------------------------------------------|
| Порядок хранения данных   | Определяет физический порядок строк              | Не влияет на физический порядок данных        |
| Количество индексов       | Один на таблицу                                  | Несколько на таблицу                          |
| Использование места       | Не требует дополнительного места                 | Требует дополнительного места для указателей  |
| Скорость вставки/удаления | Может быть медленнее (из-за поддержания порядка) | Быстрее, так как не меняет физический порядок |
| Поиск диапазонов          | Эффективен, так как данные отсортированы         | Менее эффективен при поиске диапазонов        |
| Примеры использования     | Первичный ключ, уникальные идентификаторы        | Поиск по столбцам в WHERE и ORDER BY          |

[К оглавлению](#SQL)

# 10. Какие типы соединений join таблиц существуют? В чем их разница?
1.  INNER JOIN возвращает только те строки, которые имеют совпадения в обеих таблицах по указанному условию.
+ Как работает: Возвращает строки, где значение в колонке одной таблицы совпадает со значением в колонке другой таблицы. Если совпадений нет, строка не включается в результат.
```java
SELECT employees.name, departments.department_name
FROM employees
INNER JOIN departments ON employees.department_id = departments.id;

возвращаются только те сотрудники (employees), которые имеют 
совпадение в таблице отделов (departments) по department_id.
```
2. LEFT JOIN (или LEFT OUTER JOIN) возвращает все строки из левой таблицы и только совпадающие строки из правой таблицы. Если совпадения нет, то поля правой таблицы будут заполнены NULL.
+ Как работает: Возвращает все строки из левой таблицы, даже если нет совпадения в правой таблице. Строки, которые не имеют соответствий, будут иметь NULL значения в полях правой таблицы.
```java
SELECT employees.name, departments.department_name
FROM employees
LEFT JOIN departments ON employees.department_id = departments.id;

будут возвращены все сотрудники (employees), даже если 
они не принадлежат ни к одному отделу.
```
3. RIGHT JOIN (или RIGHT OUTER JOIN) работает аналогично LEFT JOIN, но возвращает все строки из правой таблицы и только совпадающие строки из левой таблицы. Если совпадения нет, то поля левой таблицы будут заполнены NULL.
+ Как работает: Возвращает все строки из правой таблицы, даже если нет совпадения в левой таблице. Строки, которые не имеют соответствий, будут иметь NULL значения в полях левой таблицы.
```java
SELECT employees.name, departments.department_name
FROM employees
RIGHT JOIN departments ON employees.department_id = departments.id;

будут возвращены все отделы (departments), даже если в них нет сотрудников.
```
4. FULL JOIN (или FULL OUTER JOIN) возвращает все строки, если есть совпадение в одной из таблиц. Если совпадения нет, строки из одной таблицы будут заполнены NULL.
+ Как работает: Возвращает все строки из обеих таблиц. Если есть совпадение, данные объединяются. Если совпадений нет, значения из одной из таблиц будут NULL.
```java
SELECT employees.name, departments.department_name
FROM employees
FULL JOIN departments ON employees.department_id = departments.id;

будут возвращены все сотрудники и все отделы, даже если они не связаны друг с другом.
```
5. CROSS JOIN возвращает декартово произведение двух таблиц. Это значит, что каждая строка из первой таблицы будет сочетаться с каждой строкой из второй таблицы.
+ Как работает: Объединяет все строки из первой таблицы со всеми строками из второй таблицы. Результатом является множество комбинаций.
```java
SELECT employees.name, departments.department_name
FROM employees
CROSS JOIN departments;

будут созданы все возможные комбинации сотрудников и отделов
```
6. SELF JOIN — это случай, когда таблица соединяется сама с собой. Это делается, чтобы сравнить строки одной и той же таблицы.
+ Как работает: Применяется тогда, когда нужно сопоставить строки одной таблицы с другими строками из той же таблицы. Обычно используется псевдонимы таблиц (переименованные экземпляры таблицы).
```java
SELECT e1.name AS employee_name, e2.name AS manager_name
FROM employees e1
INNER JOIN employees e2 ON e1.manager_id = e2.id;

таблица employees соединяется сама с собой для отображения сотрудника и его менеджера
```
| Тип JOIN     | Описание                                                                          | Пример применения                                      |
|--------------|-----------------------------------------------------------------------------------|--------------------------------------------------------|
| INNER JOIN   | Возвращает только строки, имеющие совпадения в обеих таблицах                     | Получение только соответствующих данных                |
| LEFT JOIN    | Возвращает все строки из левой таблицы и соответствующие из правой, если они есть | Все данные с одной стороны и соот ветствующие с другой |
| RIGHT JOIN   | Возвращает все строки из правой таблицы и соответствующие из левой, если они есть | Все данные с другой стороны и соответствующие с первой |
| FULL JOIN    | Возвращает все строки, если есть совпадения в одной из таблиц                     | Получение всех данных из обеих таблиц                  |
| CROSS JOIN   | Возвращает декартово произведение двух таблиц                                     | Создание всех комбинаций данных                        |
| SELF JOIN    | Соединяет таблицу саму с собой                                                    | Сравнение строк в одной таблице                        |

[К оглавлению](#SQL)

# 11. Что такое SQL курсор?

[К оглавлению](#SQL)

# 12. Опишите шаги по созданию и использованию курсора.

[К оглавлению](#SQL)

# 13. Что такое транзакция?

[К оглавлению](#SQL)

# 14. Что такое триггер? Какие типы триггеров Вы знаете?

[К оглавлению](#SQL)

# 15. В чем разница между where и having?

[К оглавлению](#SQL)

# 16. Что такое подзапрос sub-query?

[К оглавлению](#SQL)

# 17. Что такое union?

[К оглавлению](#SQL)

# 18. Что такое group by?

[К оглавлению](#SQL)

# 19. Что такое хранимые процедуры?

[К оглавлению](#SQL)

# 20. Что такое view представление?

[К оглавлению](#SQL)

# 21. Что такое JDBC?

[К оглавлению](#SQL)

# 22. Что нужно для работы с той или иной БД?

[К оглавлению](#SQL)

# 23. Как зарегистрировать драйвер?

[К оглавлению](#SQL)

# 24. Как получить Connection?

[К оглавлению](#SQL)

# 25. Что такое Statement, PreparedStatement? В чем разница между ними?

[К оглавлению](#SQL)

# 26. Что такое ResultSet?

[К оглавлению](#SQL)

# 27. В чем разница между методами execute, executeUpdate, executeQuery?

[К оглавлению](#SQL)

# 28. Можно ли использовать возвращаемое значение метода execute для проверки, что что-то обновилось?

[К оглавлению](#SQL)

# 29. Как получить при вставке сгенерированные ключи? Как это сделать на чистом sql?

[К оглавлению](#SQL)

# 30. Для чего используется конструкция try-with-resources?

[К оглавлению](#SQL)

