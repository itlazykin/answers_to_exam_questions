## SQL

[1. Что такое SQL?](#1-Что-такое-SQL)

[2. Что такое DML и DDL?](#2-Что-такое-DML-и-DDL)

[3. Что такое первичный ключ?](#3-Что-такое-первичный-ключ)

[4. Что такое внешний ключ?](#4-Что-такое-внешний-ключ)

[5. Какие виды связей между таблицами существуют и как они организуются?](#5-Какие-виды-связей-между-таблицами-существуют-и-как-они-организуются)

[6. Опишите как вставить, удалить, обновить данные в, из таблицы.](#6-опишите-как-вставить-удалить-обновить-данные-в-из-таблицы)

[7. Что такое нормализация БД?](#7-Что-такое-нормализация-БД)

[8. Что такое денормализация БД? Для чего она нужна?](#8-Что-такое-денормализация-БД-Для-чего-она-нужна)

[9. Что такое кластерный и некластерный индексы?](#9-Что-такое-кластерный-и-некластерный-индексы)

[10. Какие типы соединений join таблиц существуют? В чем их разница?](#10-Какие-типы-соединений-join-таблиц-существуют-В-чем-их-разница)

[11. Что такое SQL курсор?](#11-Что-такое-SQL-курсор)

[12. Опишите шаги по созданию и использованию курсора.](#12-Опишите-шаги-по-созданию-и-использованию-курсора)

[13. Что такое транзакция?](#13-Что-такое-транзакция)

[14. Что такое триггер? Какие типы триггеров Вы знаете?](#14-Что-такое-триггер-Какие-типы-триггеров-Вы-знаете)

[15. В чем разница между where и having?](#15-В-чем-разница-между-where-и-having)

[16. Что такое подзапрос sub-query?](#16-Что-такое-подзапрос-sub-query)

[17. Что такое union?](#17-Что-такое-union)

[18. Что такое group by?](#18-Что-такое-group-by)

[19. Что такое хранимые процедуры?](#19-Что-такое-хранимые-процедуры)

[20. Что такое view представление?](#20-Что-такое-view-представление)

[21. Что такое JDBC?](#21-Что-такое-JDBC)

[22. Что нужно для работы с той или иной БД?](#22-Что-нужно-для-работы-с-той-или-иной-БД)

[23. Как зарегистрировать драйвер?](#23-Как-зарегистрировать-драйвер)

[24. Как получить Connection?](#24-Как-получить-Connection)

[25. Что такое Statement, PreparedStatement? В чем разница между ними?](#25-Что-такое-Statement-PreparedStatement-В-чем-разница-между-ними)

[26. Что такое ResultSet?](#26-Что-такое-ResultSet)

[27. В чем разница между методами execute, executeUpdate, executeQuery?](#27-В-чем-разница-между-методами-execute-executeUpdate-executeQuery)

[28. Можно ли использовать возвращаемое значение метода execute для проверки, что что-то обновилось?](#28-Можно-ли-использовать-возвращаемое-значение-метода-execute-для-проверки-что-что-то-обновилось)

[29. Как получить при вставке сгенерированные ключи? Как это сделать на чистом sql?](#29-Как-получить-при-вставке-сгенерированные-ключи-Как-это-сделать-на-чистом-sql)

[30. Для чего используется конструкция try-with-resources?](#30-для-чего-используется-конструкция-try-with-resources)

[31. Что такое Liquibase и для чего он используется?](#31-что-такое-liquibase-и-для-чего-он-используется)

[32. Какую проблему решает Liquibase в проекте?](#32-какую-проблему-решает-liquibase-в-проекте)

[33. Какие форматы файлов changelog поддерживает Liquibase?](#33-какие-форматы-файлов-changelog-поддерживает-liquibase)

[34. Что такое changelog и changeset? В чем их разница?](#34-что-такое-changelog-и-changeset-в-чем-их-разница)

[35. Какими способами можно интегрировать Liquibase в Java-приложение?](#35-какими-способами-можно-интегрировать-liquibase-в-java-приложение)


# 1. Что такое SQL?

SQL - это декларативный язык программирования, который используется для создания, модификации и управления данными в
реляционной БД, управляемой системой управления базами данных (СУБД). С помощью SQL-запросов можно добавлять, изменять,
получать или удалять данные из БД.

[К оглавлению](#SQL)

# 2. Что такое DML и DDL?

DDL – Data Definition Language, характеризует операции над структурой данных.
создании, удалении, изменении и т.д. таблиц и баз данных.

DML – Data Manipulation Language, представляет операции над самими данными.
создание, удаление, получение, обновление самих данных.

[К оглавлению](#SQL)

# 3. Что такое первичный ключ?
`Первичный ключ` (primary key) - это поле в таблице, однозначно идентифицирующее каждую строку (запись) в таблице БД.
Первичный ключ должен содержать уникальные значения. Также не может содержать null. В таблице может быть только один
первичный ключ. Ключ может состоять из одного и более полей.

Так как в реляционных БД все таблицы почти всегда связаны друг с другом, первичные ключи используются для однозначной
организации этой связи.
```java
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,  -- user_id является первичным ключом
    name VARCHAR(100),
    email VARCHAR(100) UNIQUE,
    registration_date DATE
);

В этом примере user_id — это первичный ключ. Он уникален для каждой строки, 
и каждая запись будет иметь свое уникальное значение в этом столбце.
```
```java
CREATE TABLE orders (
    order_id INT,
    product_id INT,
    order_date DATE,
    PRIMARY KEY (order_id, product_id)  -- Составной первичный ключ
);
Здесь уникальной записью будет комбинация значений order_id и product_id. Это означает, 
что в одной и той же таблице могут быть несколько записей с одинаковым order_id, 
но они должны отличаться по product_id.
```

[К оглавлению](#SQL)

# 4. Что такое внешний ключ?
Внешний ключ — это атрибут или набор атрибутов, которые ссылаются на primary key или unique другой таблицы. Другими
словами, это что-то вроде указателя на строку другой таблицы.

```java
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);

CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    order_date DATE NOT NULL,
    customer_id INT,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);

customer_id в таблице customers — это первичный ключ.
customer_id в таблице orders — это внешний ключ, 
который ссылается на customer_id в таблице customers.
```

[К оглавлению](#SQL)

# 5. Какие виды связей между таблицами существуют и как они организуются?
Связи между таблицами в реляционных базах данных позволяют организовать структуру данных и поддерживать целостность. Основные виды связей включают один к одному, один ко многим, многие ко многим, и каждая из них имеет свои особенности и способы организации.
1. Один к одному (One-to-One) Это связь, при которой одной записи в одной таблице соответствует ровно одна запись в другой таблице.
+ Чаще всего связь "один к одному" реализуется с помощью внешнего ключа в одной из таблиц, который также является первичным ключом.
+ Можно использовать одну таблицу для хранения данных, но иногда данные разделяют для лучшей организации или безопасности.
```java
Представим, что есть таблица users (пользователи) и таблица user_profiles 
(профили пользователей),где каждому пользователю соответствует один профиль

CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(100) NOT NULL
);

CREATE TABLE user_profiles (
    profile_id SERIAL PRIMARY KEY,
    user_id INT UNIQUE,
    bio TEXT,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

Здесь user_id в таблице user_profiles — это внешний ключ, к
оторый также уникален, чтобы связь была "один к одному".
```
2. Один ко многим (One-to-Many) Это наиболее распространённая связь, при которой одной записи в одной таблице соответствует несколько записей в другой таблице.
+ Реализуется с помощью внешнего ключа в дочерней таблице (таблица, содержащая много записей).
+ Обычный пример — связь между таблицей категорий и таблицей товаров, где каждой категории соответствует несколько товаров.
```java
CREATE TABLE categories (
    category_id SERIAL PRIMARY KEY,
    category_name VARCHAR(100) NOT NULL
);

CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL,
    category_id INT,
    FOREIGN KEY (category_id) REFERENCES categories(category_id)
);

Здесь category_id в таблице products — внешний ключ, 
который связывает продукты с категориями.
```
3. Многие ко многим (Many-to-Many) Это связь, при которой нескольким записям в одной таблице соответствуют несколько записей в другой таблице.
+ Реализуется через связующую таблицу (или промежуточную таблицу), которая содержит внешние ключи на обе связанные таблицы.
+ В связующей таблице каждая комбинация внешних ключей описывает связь между двумя записями.
```java
Представим, что у нас есть таблицы students (студенты) и courses (курсы), 
и каждый студент может посещать несколько курсов, 
а каждый курс может иметь несколько студентов

CREATE TABLE students (
    student_id SERIAL PRIMARY KEY,
    student_name VARCHAR(100) NOT NULL
);

CREATE TABLE courses (
    course_id SERIAL PRIMARY KEY,
    course_name VARCHAR(100) NOT NULL
);

CREATE TABLE student_courses (
    student_id INT,
    course_id INT,
    PRIMARY KEY (student_id, course_id),
    FOREIGN KEY (student_id) REFERENCES students(student_id),
    FOREIGN KEY (course_id) REFERENCES courses(course_id)
);

Здесь student_courses — это связующая таблица, которая устанавливает 
связь "многие ко многим" между студентами и курсами.
```
4. Самосвязанная (Self-Referencing) связь. Иногда требуется установить связь внутри одной таблицы, например, для построения иерархий.
+ Используется внешний ключ, который ссылается на первичный ключ в той же таблице.
```java
Предположим, что у нас есть таблица employees (сотрудники), 
где каждый сотрудник может иметь начальника

CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    employee_name VARCHAR(100),
    manager_id INT,
    FOREIGN KEY (manager_id) REFERENCES employees(employee_id)
);

Здесь manager_id — это внешний ключ, который ссылается на employee_id 
в той же таблице, создавая связь между сотрудником и его начальником.
```
#### Сводная таблица: Типы связей и их особенности

| Тип связи              | Пример                    | Организация                                                                  | Характеристики                                                                                                                                                                   |
|------------------------|---------------------------|------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Один к одному          | Пользователь и профиль    | Внешний ключ в одной таблице, уникальный для каждой записи                   | Каждой записи в одной таблице соответствует ровно одна запись в другой. Используется для данных, которые можно разделить на отдельные категории.                                 |
| Один ко многим         | Категория и товары        | Внешний ключ в дочерней таблице                                              | Каждой записи в родительской таблице соответствует несколько записей в дочерней. Самая распространённая связь для организации связанных данных.                                  |
| Многие ко многим       | Студенты и курсы          | Промежуточная таблица с внешними ключами на обе связанные таблицы            | Несколько записей в одной таблице могут быть связаны с несколькими записями в другой. Используется для сложных связей, таких как объединение студентов и курсов, книг и авторов. |
| Самосвязанная          | Сотрудники и начальники   | Внешний ключ в таблице, который ссылается на первичный ключ в той же таблице | Используется для построения иерархических структур, таких как дерево категорий, сотрудники и начальники. Позволяет хранить иерархические отношения внутри одной таблицы.         |

[К оглавлению](#SQL)

# 6. Опишите как вставить, удалить, обновить данные в, из таблицы.
1. Вставка данных в таблицу (INSERT INTO)
```java
INSERT INTO table_name (column1, column2, column3)
VALUES (value1, value2, value3);


Вставка нескольких записей:

INSERT INTO table_name (column1, column2, column3)
VALUES
(value1_1, value1_2, value1_3),
(value2_1, value2_2, value2_3),
(value3_1, value3_2, value3_3);

```
2. Удаление данных из таблицы (DELETE FROM)
```java
Удаление с условием:

DELETE FROM table_name
WHERE condition;

Удаление всех записей:

DELETE FROM table_name;

Удалим всех сотрудников из департамента HR:

DELETE FROM employees
WHERE department = 'HR';
```
3. Обновление данных в таблице (UPDATE)
```java
Обновление с условием:

UPDATE table_name
SET column1 = value1, column2 = value2
WHERE condition;


Обновление всех записей:

UPDATE table_name
SET column1 = value1, column2 = value2;

Обновим департамент всех сотрудников с фамилией 'Doe' на IT:

UPDATE employees
SET department = 'IT'
WHERE last_name = 'Doe';
```
| Операция                | SQL-команда     | Примерный синтаксис                                                |
|-------------------------|-----------------|--------------------------------------------------------------------|
| Вставка                 | INSERT INTO     | INSERT INTO table_name (column1, column2) VALUES (value1, value2); |
| Удаление                | DELETE FROM     | DELETE FROM table_name WHERE condition;                            |
| Обновление              | UPDATE          | UPDATE table_name SET column1 = value1 WHERE condition;            |

[К оглавлению](#SQL)

# 7. Что такое нормализация БД?
Нормализация базы данных — это процесс организации данных в таблицах базы данных с целью минимизации избыточности данных и улучшения их целостности. Она включает в себя разделение данных на отдельные связанные таблицы и определение правильных связей между ними. Основная цель нормализации — устранить аномалии вставки, обновления и удаления данных.

+ Первая нормальная форма

Отношение находится в 1НФ, если все его атрибуты являются простыми, все используемые домены должны содержать только скалярные значения. Не должно быть повторений строк в таблице

+ Вторая нормальная форма

2NF помогает улучшить организацию данных в базе данных, делая их более компактными, устраняя избыточность и снижая вероятность ошибок при обновлении.

+ Третья нормальная форма

Ярким признаком нарушения 3НФ является бессмысленное дублирование одних и тех же данных в множестве строк таблицы (тогда атрибуты, значения которых бессмысленно дублируются, являются первыми кандидатами на перемещение в новое отдельное отношение).

+ Нормальная форма Бойса-Кодда]]

BCNF (Нормальная форма Бойса-Кодда) требует, чтобы в базе данных не было зависимостей между атрибутами, если они не зависят от ключа целиком. Ключевое условие BCNF: если есть функциональная зависимость X -> Y, то X должен быть ключом (первичным ключом).


[К оглавлению](#SQL)

# 8. Что такое денормализация БД? Для чего она нужна?
Денормализация базы данных (DB denormalization) - это процесс, в котором структура базы данных изменяется с целью увеличения производительности или упрощения работы с данными. Она противоположна нормализации, которая направлена на уменьшение избыточности данных и обеспечение целостности данных.

Денормализация может быть полезной в следующих случаях:

1. **Увеличение производительности**: Нормализация может привести к созданию множества связей между таблицами, что может
   замедлить выполнение запросов. Денормализация позволяет объединить данные в одной таблице, ускоряя доступ к ним.

2. **Уменьшение сложности запросов**: Нормализованные базы данных могут потребовать более сложных и долгих запросов для
   получения нужной информации. Денормализация может упростить запросы.

3. **Улучшение читаемости кода**: В некоторых случаях, особенно в приложениях, где скорость работы с данными критически
   важна, денормализированная структура базы данных может улучшить читаемость и производительность кода.

Однако следует быть осторожным с денормализацией, так как она может привести к избыточной информации, ухудшению
целостности данных и усложнению обслуживания базы данных. Денормализация обычно применяется в тех случаях, когда
производительность стоит выше приоритетом, и когда её выигрыши перевешивают её недостатки.

```java
Клиенты:
CREATE TABLE customers (
customer_id SERIAL PRIMARY KEY,
customer_name TEXT,
customer_phone TEXT
);

Продукты:
CREATE TABLE products (
product_id SERIAL PRIMARY KEY,
product_name TEXT,
product_price NUMERIC
);

Заказы:
CREATE TABLE orders (
order_id SERIAL PRIMARY KEY,
customer_id INT REFERENCES customers(customer_id),
product_id INT REFERENCES products(product_id),
quantity INT,
order_date DATE
);

Денормализированная база:
CREATE TABLE denormalized_orders (
        order_id SERIAL PRIMARY KEY,
        customer_name TEXT,
        customer_phone TEXT,
        product_name TEXT,
        product_price NUMERIC,
        quantity INT,
        total_price NUMERIC,
        order_date DATE
);

Пимер запроса:

С денормализованной таблицей:
SELECT customer_name, customer_phone, product_name, total_price, order_date
FROM denormalized_orders
WHERE order_date = '2024-11-27';

нормализованных таблиц:
SELECT c.customer_name, c.customer_phone, p.product_name, (p.product_price * o.quantity) AS total_price, o.order_date
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
JOIN products p ON o.product_id = p.product_id
WHERE o.order_date = '2024-11-27';
```
[К оглавлению](#SQL)

# 9. Что такое кластерный и некластерный индексы?
1. **Кластерный индекс (Clustered Index)**:

    - Кластерный индекс определяет физический порядок данных в таблице. Таблица может иметь только один кластерный
      индекс, так как данные в таблице фактически упорядочиваются по ключевым значениям этого индекса.
    - Кластерный индекс обычно используется для колонки или набора колонок, которые являются первичным ключом таблицы.
      Он оптимизирует операции выборки данных по значению первичного ключа, так как данные фактически хранятся в том же
      порядке, что и ключи.
    - Так как таблица может иметь только один кластерный индекс, выбор правильной колонки для него - важное решение в
      проектировании базы данных.
2. **Некластерный индекс (Non-clustered Index)**:

    - Некластерный индекс не определяет физический порядок данных в таблице. Вместо этого он создает отдельную структуру
      данных, которая содержит ссылки на строки таблицы и значения ключевых столбцов.
    - Таблица может иметь несколько некластерных индексов, и они могут использоваться для оптимизации разных типов
      запросов. Например, индекс можно создать для ускорения выборки данных по определенному столбцу или для оптимизации
      соединений между таблицами.
    - Некластерные индексы обычно занимают больше места, чем кластерные индексы, так как они хранят как значения ключей,
      так и ссылки на строки.
```java
CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    employee_name TEXT,
    department_id INT
);
INSERT INTO employees (employee_name, department_id)
VALUES
        ('Иван Иванов', 2),
        ('Мария Смирнова', 1),
        ('Петр Петров', 3),
        ('Анна Васильева', 2),
        ('Сергей Козлов', 1);
Создаем индекс:
CREATE INDEX idx_department_id ON employees(department_id);
Делаем таблицу кластерной:
CLUSTER employees USING idx_department_id;
```

```java
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_name TEXT,
    product_price NUMERIC
);
INSERT INTO products (product_name, product_price)
VALUES
        ('Хлеб', 50.00),
        ('Молоко', 70.00),
        ('Сыр', 250.00),
        ('Масло', 120.00),
        ('Яйца', 85.00);
Создаем некластерный индекс:
CREATE INDEX idx_product_price ON products(product_price);

Этот индекс ускоряет поиск по цене (product_price). 
Однако физический порядок строк в таблице не меняется.

        SELECT product_name, product_price
        FROM products
        WHERE product_price < 100;
PostgreSQL будет использовать idx_product_price для быстрого поиска строк с ценой ниже 100.
```
#### Основные отличия:
| Критерий                  | Кластерный индекс                                | Некластерный индекс                           |
|---------------------------|--------------------------------------------------|-----------------------------------------------|
| Порядок хранения данных   | Определяет физический порядок строк              | Не влияет на физический порядок данных        |
| Количество индексов       | Один на таблицу                                  | Несколько на таблицу                          |
| Использование места       | Не требует дополнительного места                 | Требует дополнительного места для указателей  |
| Скорость вставки/удаления | Может быть медленнее (из-за поддержания порядка) | Быстрее, так как не меняет физический порядок |
| Поиск диапазонов          | Эффективен, так как данные отсортированы         | Менее эффективен при поиске диапазонов        |
| Примеры использования     | Первичный ключ, уникальные идентификаторы        | Поиск по столбцам в WHERE и ORDER BY          |

[К оглавлению](#SQL)

# 10. Какие типы соединений join таблиц существуют? В чем их разница?
1. **INNER JOIN**: Возвращает только те строки, где есть совпадения в обеих таблицах. Если запись в одной из таблиц не имеет соответствия в другой, она исключается из результата.

2. **LEFT JOIN (или LEFT OUTER JOIN)**: Возвращает все строки из левой (первой) таблицы и соответствующие строки из правой (второй) таблицы. Если запись в левой таблице не имеет соответствия в правой, то для этой записи в результате будет NULL.

3. **RIGHT JOIN (или RIGHT OUTER JOIN)**: Аналогично LEFT JOIN, но возвращает все строки из правой (второй) таблицы и соответствующие строки из левой (первой) таблицы. Если запись в правой таблице не имеет соответствия в левой, то для этой записи в результате будет NULL.

4. **FULL JOIN (или FULL OUTER JOIN)**: Возвращает все строки из обеих таблиц. Если запись в одной из таблиц не имеет соответствия в другой, то для этой записи в результате будут установлены NULL-значения.

5. **CROSS JOIN**: Возвращает декартово произведение двух таблиц, то есть каждая строка из первой таблицы объединяется со всеми строками из второй таблицы. Этот тип JOIN может привести к большому количеству результатов, и его следует использовать осторожно.

6. **SELF JOIN (самообъединение)**: Это JOIN, который используется для объединения таблицы с самой собой. Это полезно, когда в таблице есть связи между разными записями в ней.

7. **NON-EQUI JOIN (неравенство JOIN)**: Этот тип JOIN используется для объединения таблиц по условию, которое не является равенством (=), например, операторы сравнения (<, >, <=, >=).

| Тип JOIN     | Описание                                                                          | Пример применения                                      |
|--------------|-----------------------------------------------------------------------------------|--------------------------------------------------------|
| INNER JOIN   | Возвращает только строки, имеющие совпадения в обеих таблицах                     | Получение только соответствующих данных                |
| LEFT JOIN    | Возвращает все строки из левой таблицы и соответствующие из правой, если они есть | Все данные с одной стороны и соот ветствующие с другой |
| RIGHT JOIN   | Возвращает все строки из правой таблицы и соответствующие из левой, если они есть | Все данные с другой стороны и соответствующие с первой |
| FULL JOIN    | Возвращает все строки, если есть совпадения в одной из таблиц                     | Получение всех данных из обеих таблиц                  |
| CROSS JOIN   | Возвращает декартово произведение двух таблиц                                     | Создание всех комбинаций данных                        |
| SELF JOIN    | Соединяет таблицу саму с собой                                                    | Сравнение строк в одной таблице                        |

![img](https://github.com/itlazykin/answers_to_exam_questions/blob/main/main/resources/joins.png)

[К оглавлению](#SQL)

# 11. Что такое SQL курсор?
2 определения:

1. **Курсор** – это объект, который позволяет отдельно обрабатывать строки из результирующего набора данных, который
   возвращается оператором SELECT. Строки при этом можно перебирать последовательно, с первой до последней.

2. **Курсор** – это область в памяти БД, которая предназначена для хранения последнего оператора SQL. Если текущий
   оператор – запрос к БД, то в памяти хранится и строка данных запроса. Она называется текущим значением или же –
   текущей строкой курсора. Данная область в памяти поименована и доступна нам для вызова.

[К оглавлению](#SQL)

# 12. Опишите шаги по созданию и использованию курсора.
Курсор можно объявить только внутри транзакции.

1. **Объявление курсора**: Сначала вы объявляете курсор с помощью оператора `DECLARE CURSOR`. В этом операторе вы
   определяете имя курсора и SQL-запрос, который будет использоваться для выборки данных. Например:

 ```sql
 DECLARE my_cursor CURSOR FOR
 SELECT column1, column2
 FROM my_table
 WHERE condition;
 ```

2. **Открытие курсора**: После объявления курсора вы открываете его с помощью оператора `OPEN`. Это позволяет выполнить
   запрос и начать выборку данных.

 ```sql
 OPEN my_cursor;
 ```

3. **Чтение данных**: Вы можете читать данные из курсора с помощью оператора `FETCH`. Этот оператор перемещает указатель
   на следующую строку результата запроса и возвращает данные этой строки. Выполняйте FETCH в цикле, чтобы читать все
   строки.

 ```sql
 FETCH NEXT FROM my_cursor INTO @variable1, @variable2;
 ```

Здесь `@variable1` и `@variable2` - это переменные, в которые будут записаны данные из курсора.

4. **Обработка данных**: После чтения данных вы можете обрабатывать их, выполнять вычисления или сохранять в другие
   таблицы по вашей потребности.

5. **Закрытие курсора**: После того как вы закончили работу с курсором, закройте его с помощью оператора `CLOSE`.

 ```sql
 CLOSE my_cursor;
 ```

6. **Освобождение ресурсов**: Хорошей практикой является также освобождение ресурсов, связанных с курсором, с помощью
   оператора `DEALLOCATE`.

 ```sql
 DEALLOCATE my_cursor;
 ```
[К оглавлению](#SQL)

# 13. Что такое транзакция?

Это совокупность операций с БД, которые представляют собой логически неделимую единицу. При этом операции могут быть
выполнены или целиком и успешно (должны быть соблюдены все правила консистентности БД и не зависит от параллельных
транзакций), или же не выполнены вообще (при этом ни одна из операций, которые входят в совокупность, не должна внести
изменения в БД).

- транзакция всегда или выполняется, или не выполняется целиком. Если возникают проблемы в транзакции клиента 1, то
  происходит отмена всех его изменений. При этом работа клиента 2 завершилась успешно и все изменения вступили в силу;

- транзакция может быть использована при восстановлении после сбоев и отказов. Если при работе клиента 1 возникли
  проблемы, то все изменения были отменены. При этом данные были приведены в состояние, в котором были до начала
  операций клиента 1;

- транзакция обеспечивает механизм конкурентного доступа к данным, так как СУБД запретила двум клиентам одновременно
  изменять один и тот же счет.

Типы изоляции:

1. **READ UNCOMMITTED (Чтение неподтвержденных данных)**:

- Транзакции могут видеть изменения, внесенные другими транзакциями, даже если они еще не были подтверждены (COMMIT).
- Этот уровень изоляции обеспечивает самую низкую степень изоляции и может приводить к чтению "грязных данных" (
  неподтвержденных изменений).

2. **READ COMMITTED (Чтение подтвержденных данных)**:

- Транзакции видят только изменения, которые были подтверждены (COMMIT) другими транзакциями.
- Этот уровень изоляции решает проблему "грязных данных", но может вызвать проблему чтения "неповторяющихся данных" (
  non-repeatable reads).

3. **REPEATABLE READ (Повторяемое чтение)**:

- Транзакции видят только данные, считанные в начале транзакции, и эти данные остаются постоянными в течение всей
  транзакции.
- Этот уровень изоляции решает проблему чтения "неповторяющихся данных", но может вызвать проблему чтения "фантомных
  данных" (phantom reads).

4. **SERIALIZABLE (Сериализуемая)**:

- Этот уровень изоляции предоставляет самую высокую степень изоляции.
- Транзакции видят только данные, которые были подтверждены другими транзакциями, и предотвращают как чтение "грязных
  данных", так и чтение "неповторяющихся данных" и "фантомных данных".
- Однако он может привести к блокировкам и ухудшению производительности.

```java
BEGIN TRANSACTION;

UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;  -- Списание денег
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;  -- Зачисление денег

-- Если все прошло успешно, подтверждаем транзакцию
COMMIT;

Если в какой-то момент возникнет ошибка 
(например, недостаточно средств на счете), то можно откатить все изменения

ROLLBACK;
```

[К оглавлению](#SQL)

# 14. Что такое триггер? Какие типы триггеров Вы знаете?

Триггер – специальный объект БД, описывающий перечень действий, которые необходимо автоматически выполнить при
наступлении указанного события.

Триггеры можно поделить на три группы с точки зрения события:

1. BEFORE (до выполнения операции);

2. INSTEAD OF (вместо выполнения операции);

3. AFTER (после выполнения операции).
```java
Пример для AFTER INSERT триггера

CREATE TRIGGER trg_after_insert
AFTER INSERT ON employees
FOR EACH ROW
BEGIN
  -- Логика для добавления записи в лог или другой процесс
INSERT INTO audit_log (action, employee_id, timestamp)
VALUES ('INSERT', NEW.employee_id, NOW());
END;

```

[К оглавлению](#SQL)

# 15. В чем разница между where и having?

WHERE — элемент запроса, который используется, когда нужно отфильтровать данные по нужному условию.

```sql
select * from Customers WHERE City = 'London'
```

HAVING - элемент запроса, gрименяется он аналогично where, только в нем обязательно должна быть агрегатная функция.

```sql
SELECT department, AVG(salary) as avg_salary
FROM employees
GROUP BY department
HAVING AVG(salary) > 60000;
```

[К оглавлению](#SQL)

# 16. Что такое подзапрос sub-query?
Подзапрос (sub-query) — это запрос, который выполняется внутри другого SQL-запроса. 
```java
SELECT name, (SELECT department FROM employees WHERE id = 1) AS department
FROM employees;

В этом примере подзапрос возвращает значение отдела для сотрудника с id = 1, 
и это значение будет использоваться в основном запросе.
```

[К оглавлению](#SQL)

# 17. Что такое union?
`UNION` - это оператор в SQL, который используется для объединения результатов двух или более запросов в один результирующий набор данных. Оператор `UNION` позволяет объединить строки из разных таблиц или результатов запросов таким образом, что дубликаты удаляются, и только уникальные строки включаются в итоговый результат.

Основные характеристики оператора `UNION`:

1. **Объединение по столбцам**: Результаты запросов, объединяемых с помощью `UNION`, должны иметь одинаковое количество столбцов и соответствующие столбцы должны иметь совместимые типы данных.

2. **Удаление дубликатов**: По умолчанию оператор `UNION` удаляет дубликаты строк из итогового результата. Если вы хотите включить дубликаты, вы можете использовать оператор `UNION ALL`.

```sql
-- Получение списка работников
SELECT employee_id, first_name, last_name
FROM employees
WHERE department = 'HR'

UNION

-- Получение списка подрядчиков
SELECT contractor_id, first_name, last_name
FROM contractors
WHERE project = 'Marketing';
```

[К оглавлению](#SQL)

# 18. Что такое group by?
Оператор `GROUP BY` используется в SQL для группировки строк в результирующем наборе данных на основе значений одного
или нескольких столбцов. Это позволяет выполнять агрегатные функции (например, суммирование, подсчет, нахождение
среднего значения) над данными в каждой группе.

```sql
SELECT column1, column2, aggregate_function(column3)
FROM table_name
GROUP BY column1, column2;
```

[К оглавлению](#SQL)

# 19. Что такое хранимые процедуры?
Это подпрограмма (она может принимать параметры), которая предназначена выполнять ряд операций с данными и структурами
БД. Хранится на стороне БД и доступна как для вызова из других процедур и триггеров, а также может исполняться
самостоятельно.

```sql
CREATE PROCEDURE insert_data(a integer, b integer)
LANGUAGE SQL
AS $$
INSERT INTO tbl VALUES (a);
INSERT INTO tbl VALUES (b);
$$;
```

[К оглавлению](#SQL)

# 20. Что такое view представление?

Представления (views) - это SQL-запрос, который можно выполнять, обращаясь к нему по заранее указанному имени.

Материализованное представление - это SQL-запрос, который можно выполнять, обращаясь к нему по заранее указанному имени,
и результат выполнения этого запроса сохраняется для дальнейшего использования.

Основой для построения представления может быть только SELECT-запрос

**Преимущества:**

1. Упрощение выполнения запросов. Как мы уже обсудили, представление может быть построено на SQL-запросе любой
   сложности. Поэтому при использовании представлений нам уже не придется переписывать запрос, который может состоять
   даже из 100 строк. Нам будет достаточно вызвать представление **SELECT * FROM представление** и в итоге получить тот
   же результат;

2. Возможность построения простого и надежного API. На стадии проектирования БД мы можем предусмотреть набор удобных
   представлений, т.е. мы можем заранее скрыть от разработчика сложные запросы, что, в свою очередь, упростит разработку
   приложения и к тому же снизит количество ошибок при разработке.

3. Упрощение бизнес-логики. В принципе, это следует из предыдущего пункта. Однако даже если мы не строим полноценный
   API, мы все равно можем заранее сформировать набор для наиболее сложных и часто встречаемых запросов.

4. Минимум накладных расходов. Представление (это касается простых представлений) практически не занимает места в БД,
   потому даже создание сотен и тысяч представлений не приводит к ощутимому увеличению размера БД.

5. Безопасность. Представления являются объектами БД, потому к ним применимы все механизмы СУБД по контролю прав
   доступа.

**Недостатки:**

1. Избыточность. Иногда представления просто не нужны. Например, БД небольшая, бизнес-логика простая, модель
   безопасности тривиальная. В таком случае представления чаще всего будут лишними.

2. Дополнительный код. Представления, как и все остальное, необходимо создавать, что ведет за собой остальные операции –
   тестирование, корректировка при изменении БД или бизнес-логики. Соответственно, растут трудозатраты и повышается
   вероятность появления ошибок.

3. Ограниченность возможностей. Мы уже говорили, что представления можно использовать для модификации данных. Однако это
   имеет много ограничений, поэтому можно утверждать, что не любую операцию с БД можно выполнить с помощью
   представлений.

```java
Синтаксис для создания представления:

CREATE VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;

Пример: Предположим, у нас есть таблица employees с данными о сотрудниках. 
Чтобы создать представление, которое показывает только имена 
и зарплаты сотрудников, можем выполнить следующий запрос:

CREATE VIEW employee_salaries AS
SELECT name, salary
FROM employees;

Теперь, вместо того чтобы писать SELECT name, 
salary FROM employees; каждый раз, можно просто выполнить:

SELECT * FROM employee_salaries;
```

[К оглавлению](#SQL)

# 21. Что такое JDBC?

JDBC. _JDBC_ – это API, те набор вспомогательных классов, которое позволяет работать с базами данных. Причем JDBC
предоставляет единый интерфейс для работы с ними, ведь бывают различные базы данных.

[К оглавлению](#SQL)

# 22. Что нужно для работы с той или иной БД?

Нужен драйвер, а так же:

1) добавить необходимый драйвер в pom.xml в `dependency`
2) подключиться к БД

[К оглавлению](#SQL)

# 23. Как зарегистрировать драйвер?

```java
Class.forName(cfg.getProperty("jdbc.driver"));
```

[К оглавлению](#SQL)

# 24. Как получить Connection?

```java
Connection cnn = DriverManager.getConnection(
    cfg.getProperty("url"),
    cfg.getProperty("username"),
    cfg.getProperty("password")
);
```
[К оглавлению](#SQL)

# 25. Что такое Statement, PreparedStatement? В чем разница между ними?

1. `Statement` — это интерфейс, который используется для выполнения простых SQL-запросов без параметров. Обычно его
   используют для запросов, которые не требуют параметризации, например, для простого SELECT, INSERT, UPDATE и т.д.

```java
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM users");
```

2. `PreparedStatement` - это интерфейс в Java, предоставляющий способ выполнять предварительно скомпилированные
   SQL-запросы с параметрами. Он представляет собой механизм, который помогает защитить ваш код от SQL-инъекций и может
   улучшить производительность, так как база данных может повторно использовать предварительно скомпилированный запрос.

PreparedStatement поддерживает параметризированные запросы, позволяет избежать SQL-инъекций SQL-инъекция (SQLi) - это
уязвимость веб-безопасности, озволяющая злоумышленнику вмешиваться в запросы, которые приложение делает к своей
базе данных. Как правило, это позволяет просматривать данные, которые он обычно не может получить. Это могут быть других
пользователей, или любые другие данные, доступ к которым имеет само приложение. Во многих случаях злоумышленник может
изменять или удалять эти данные, вызывая постоянные изменения в содержимом или поведении приложения.

```java
String sql = "SELECT * FROM users WHERE id = ?";
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setInt(1, 1); // Устанавливаем значение для параметра
ResultSet rs = pstmt.executeQuery();
```

  | Характеристика           | Statement                                                                                         | PreparedStatement                                                                                                                   |
  |--------------------------|---------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------|
  | Производительность       | Менее производительный для повторных запросов, так как каждый запрос нужно компилировать заново.  | Более производительный, так как SQL-запрос компилируется один раз, а затем используется многократно.                                |
  | Безопасность	          | Подвержен SQL-инъекциям, так как значения подставляются непосредственно в строку запроса.         | Защищает от SQL-инъекций, так как параметры передаются через метод setXXX(), а не вставляются в строку                              |
  | Использование параметров | Не поддерживает параметры (все значения в запросе должны быть жестко закодированы).               | Поддерживает параметры, которые задаются через методы типа setInt(), setString(), и т.д.                                            |
  | Использование            | Хорошо подходит для одноразовых или простых запросов.                                             | Подходит для многократного выполнения запросов с изменяющимися параметрами (например, циклическое выполнение с разными значениями). |



[К оглавлению](#SQL)

# 26. Что такое ResultSet?
`ResultSet` - это интерфейс в Java, который представляет собой результат выполнения SQL-запроса к базе данных. Он
используется для хранения и обработки набора результатов, полученных из базы данных после выполнения SQL-запроса SELECT.
`ResultSet` представляет собой таблицу данных с результатами запроса, и он позволяет вам извлекать, перебирать и
манипулировать данными, полученными из базы данных.

```java
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM users");
```
#### Методы работы с ResultSet:
1. Навигация по строкам:
+ boolean next() — перемещается к следующей строке в результате. Возвращает false, если больше строк нет.
+ boolean previous() — перемещается к предыдущей строке (если ResultSet поддерживает это).
+ boolean first() — перемещается к первой строке. 
+ boolean last() — перемещается к последней строке.  
+ void beforeFirst() — устанавливает курсор перед первой строкой. 
+ void afterLast() — устанавливает курсор после последней строки. 
+ boolean absolute(int row) — перемещается к указанной строке.
2. Извлечение данных из текущей строки:
+ int getInt(int columnIndex) — получить значение столбца в виде int по индексу.  
+ String getString(String columnName) — получить значение столбца в виде строки по имени столбца. 
+ double getDouble(int columnIndex) — получить значение столбца в виде double. 
+ boolean getBoolean(String columnName) — получить булевое значение из указанного столбца.
3. Типы данных и методы извлечения: В ResultSet есть методы для получения данных различных типов:
+ getInt(), getLong(), getFloat(), getDouble()
+ getString()
+ getDate()
+ getTime()
+ getTimestamp()
```java
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT id, name, age FROM users");

while (rs.next()) {
int id = rs.getInt("id");         // Получаем значение столбца "id"
String name = rs.getString("name"); // Получаем значение столбца "name"
int age = rs.getInt("age");         // Получаем значение столбца "age"

    System.out.println("ID: " + id + ", Name: " + name + ", Age: " + age);
}

// Закрываем ResultSet и Statement после использования
rs.close();
stmt.close();
```

[К оглавлению](#SQL)

# 27. В чем разница между методами execute, executeUpdate, executeQuery?

1. **execute()**:
    - Этот метод может использоваться для выполнения любого SQL-запроса, включая SELECT, INSERT, UPDATE, DELETE и
      другие.
    - Возвращает `true`, если был получен результат, который представляет собой `ResultSet`, и `false`, если результатом
      является обновление (как INSERT, UPDATE, DELETE) или нет результата вовсе.
    - Позволяет выполнять любые типы SQL-запросов, но требует более сложного кода для обработки результата.

2. **executeUpdate()**:
    - Этот метод предназначен для выполнения SQL-команд, которые изменяют данные в базе данных, такие как INSERT, UPDATE
      и DELETE.
    - Возвращает количество строк, затронутых выполненной командой. Если команда не изменяет данные (например, SELECT),
      метод возвращает 0.
    - Чаще всего используется при выполнении SQL-команд для вставки, обновления и удаления данных.

3. **executeQuery()**:
    - Этот метод используется исключительно для выполнения SQL-запросов SELECT, которые возвращают набор результатов (
      ResultSet).
    - Возвращает `ResultSet`, представляет собой результаты запроса, и который можно использовать для извлечения
      данных из базы данных.

Разница между этими методами заключается в типах выполняемых операций и типах возвращаемых результатов. `execute()`
может использоваться для всех видов операций, `executeUpdate()` для изменения данных, а `executeQuery()` исключительно
для выполнения SELECT-запросов.

```java
String sql = "SELECT * FROM users WHERE age > 18";
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(sql);

while (rs.next()) {
    System.out.println("User ID: " + rs.getInt("id"));
}
```

```java
String sql = "UPDATE users SET age = age + 1 WHERE id = 10";
Statement stmt = conn.createStatement();
int rowsAffected = stmt.executeUpdate(sql);

System.out.println("Rows affected: " + rowsAffected);
```

```java
String sql = "CREATE TABLE new_users (id INT PRIMARY KEY, name VARCHAR(50))";
Statement stmt = conn.createStatement();
boolean hasResultSet = stmt.execute(sql);

if (hasResultSet) {
    ResultSet rs = stmt.getResultSet();
    // Обработка ResultSet
} else {
    int updateCount = stmt.getUpdateCount();
    System.out.println("Update count: " + updateCount);
}
```

  | Метод         | Используется для                            | Возвращаемое значение                          | Примеры запросов                        |
  |---------------|---------------------------------------------|------------------------------------------------|-----------------------------------------|
  | executeQuery  | SELECT-запросы                              | ResultSet (результаты выборки)                 | SELECT * FROM users                     |
  | executeUpdate | INSERT, UPDATE, DELETE, CREATE, ALTER, DROP | int (количество затронутых строк)              | INSERT INTO users ..., UPDATE users ... |
  | execute       | Любые SQL-запросы                           | boolean (true для SELECT, false для остальных) | SELECT ..., INSERT ..., CREATE ...      |


[К оглавлению](#SQL)

# 28. Можно ли использовать возвращаемое значение метода execute для проверки, что что-то обновилось?

1) использовать напрямую нельзя, тк при обновлении возвращяет `false` и всё.
2) не напрямую - можно, тк можно вызвать `st.getUpdateCount()`

```java
st.execute(sql);

int count = st.getUpdateCount();
```
[К оглавлению](#SQL)

# 29. Как получить при вставке сгенерированные ключи? Как это сделать на чистом sql?

```java
try (PreparedStatement ps =
        con.prepareStatement("INSERT ...", Statement.RETURN_GENERATED_KEYS)) {
        try (ResultSet generatedKeys = ps.getGeneratedKeys()) {}
        }
```

[К оглавлению](#SQL)

# 30. Для чего используется конструкция try-with-resources?

Конструкция try-with-resources в Java используется для автоматического управления ресурсами, такими как Statement,
PreparedStatement, Connection, и другие классы, реализующие интерфейс AutoCloseable. Эта конструкция позволяет
автоматически закрывать ресурсы, когда они больше не нужны, даже в случае возникновения исключений, что предотвращает
утечки ресурсов и освобождает разработчика от необходимости вручную закрывать ресурсы в блоке finally.

[К оглавлению](#SQL)

# 31. Что такое Liquibase и для чего он используется?

Liquibase — это инструмент для управления схемой базы данных, который позволяет автоматизировать миграции. Он
используется для отслеживания изменений в структуре базы данных, упрощения их применения и отката, а также для
обеспечения синхронизации между различными средами (например, разработка, тестирование, продакшн).

[К оглавлению](#SQL)

# 32. Какую проблему решает Liquibase в проекте?

Liquibase решает проблему управления изменениями базы данных. Без него приходится вручную отслеживать, какие изменения
уже применены, что может привести к ошибкам, особенно в командах с несколькими разработчиками. Liquibase автоматизирует
этот процесс, обеспечивая:

+ Историю изменений.
+ Упрощенное развертывание миграций. 
+ Возможность отката изменений.

[К оглавлению](#SQL)

# 33. Какие форматы файлов changelog поддерживает Liquibase?

+ XML (стандартный формат Liquibase).
+ YAML (удобен для читаемости).
+ JSON (может быть полезен для автоматизированных процессов).
+ SQL (для описания миграций напрямую с использованием SQL-запросов).

[К оглавлению](#SQL)

# 34. Что такое changelog и changeset? В чем их разница?

+ Changelog — это файл, который содержит описание всех изменений базы данных (например, db.changelog.xml).
+ Changeset — это отдельное изменение в базе данных (например, добавление таблицы или столбца).
  Changeset является минимальной атомарной единицей, которая содержит инструкции для применения конкретного изменения.
  Несколько changeset'ов объединяются в один changelog.

```java
<databaseChangeLog>
    <changeSet id="1" author="developer">
        <createTable tableName="users">
            <column name="id" type="int" autoIncrement="true"/>
            <column name="name" type="varchar(100)"/>
        </createTable>
    </changeSet>
</databaseChangeLog>
```

[К оглавлению](#SQL)

# 35. Какими способами можно интегрировать Liquibase в Java-приложение?

Liquibase можно интегрировать несколькими способами:

+ Maven или Gradle — через соответствующие плагины для автоматизации миграций.
+ Spring Boot — с помощью стартер-зависимости liquibase-core. Настройки добавляются в application.properties или application.yml.
+ Liquibase CLI — для выполнения команд вручную через консоль.
+ Прямое использование API — вызов Liquibase из Java-кода, например:
```java
Liquibase liquibase = new Liquibase("path/to/changelog.xml", database);
liquibase.update("");
```


[К оглавлению](#SQL)




