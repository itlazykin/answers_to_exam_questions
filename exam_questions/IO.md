## IO

[1. Что такое поток ввода-вывода?](#1-Что-такое-поток-ввода-вывода)

[2. Что такое Java IO?](#2-Что-такое-Java-IO)

[3. Что такое Java NIO?](#3-Что-такое-Java-NIO)

[4. Что такое NIO 2?](#4-Что-такое-NIO-2)

[5. Что такое Scanner? ](#5-Что-такое-Scanner)

[6. Как работает Scanner внутри?](#6-Как-работает-Scanner-внутри)

[7. Какие базовые методы существуют в Scanner?](#7-Какие-базовые-методы-существуют-в-Scanner)

[8. Что такое байтовый поток? Как он реализован внутри?](#8-Что-такое-байтовый-поток-Как-он-реализован-внутри)

[9. Что такое символьный поток. Как он реализован внутри?](#9-Что-такое-символьный-поток-Как-он-реализован-внутри)

[10. Что такое буферизированный поток? ](#10-Что-такое-буферизированный-поток)

[11. Какие классы-обёртки позволяют ускорить чтение или запись за счет использования буфера?](#11-Какие-классы-обёртки-позволяют-ускорить-чтение-или-запись-за-счет-использования-буфера)

[12. Как осуществляется ввод и вывод из командной строки?](#12-Как-осуществляется-ввод-и-вывод-из-командной-строки)

[13. Что такое класс Console? Расскажите его АПИ.](#13-Что-такое-класс-Console-Расскажите-его-АПИ)

[14. Что такое поток данных? Data stream.](#14-Что-такое-поток-данных-Data-stream)

[15. Что такое поток объектов, Object stream.](#15-Что-такое-поток-объектов-Object-stream)

[16. Что такое Path? Как он реализуется на разных ОС?](#16-Что-такое-Path-Как-он-реализуется-на-разных-ОС)

[17. Как получить список файлов?](#17-Как-получить-список-файлов)

[18. Как проверить что файловая сущность является файлом или папкой?](#18-Как-проверить-что-файловая-сущность-является-файлом-или-папкой)

[19. Как удалить файл?](#19-Как-удалить-файл)

[20. Как переместить файл?](#20-Как-переместить-файл)

[21. Как управлять атрибутами файла?](#21-Как-управлять-атрибутами-файла)

[22. Как создать файл?](#22-Как-создать-файл)

[23. Как создать директорию?](#23-Как-создать-директорию)

[24. Как записать в файл?](#24-Как-записать-в-файл)

[25. Как прочитать данные из файла?](#25-Как-прочитать-данные-из-файла)

[26. Для чего нужны классы PrintStream и PrintWriter? В чем их различие?](#26-Для-чего-нужны-классы-PrintStream-и-PrintWriter-В-чем-их-различие)

[27. Что такое потоки байтовых массивов? Как они устроены?](#27-Что-такое-потоки-байтовых-массивов-Как-они-устроены)

[28. Зачем нужен класс RandomAccessFile?](#28-Зачем-нужен-класс-RandomAccessFile)

[29. Данные в каком виде можно считывать байтовыми и символьными потоками?](#29-Данные-в-каком-виде-можно-считывать-байтовыми-и-символьными-потоками)

[30. Что такое сокет?](#30-Что-такое-сокет)

[31. Какие виды сокетов есть в Java? С каким протоколом они работают?](#31-Какие-виды-сокетов-есть-в-Java-С-каким-протоколом-они-работают)

[32. Как отправить через сокет сообщение?](#32-Как-отправить-через-сокет-сообщение)

[33. Что такое логирование?](#33-Что-такое-логирование)

[34. Какие уровни логирования вы знаете?](#34-Какие-уровни-логирования-вы-знаете)

[35. Какая библиотека для логирования используется в курсе? Как ее настроить?](#35-Какая-библиотека-для-логирования-используется-в-курсе-Как-ее-настроить)

[36. Опишите из каких элементов состоит формат JSON](#36-Опишите-из-каких-элементов-состоит-формат-JSON)

[37. Как преобразовать POJO в или из json?](#37-Как-преобразовать-POJO-в-или-из-json)

[38. Опишите из каких элементов состоит формат XML](#38-Опишите-из-каких-элементов-состоит-формат-XML)

[39. Как преобразовать POJO в или из xml?](#39-Как-преобразовать-POJO-в-или-из-xml)

[40. Что такое сериализация, десериализация?](#40-Что-такое-сериализация-десериализация)

[41. Что такое регулярные выражения? Зачем они нужны?](#41-Что-такое-регулярные-выражения-Зачем-они-нужны)

[42. Как создать регулярное выражение в Java?](#42-Как-создать-регулярное-выражение-в-Java)

[43. Что такое метасимволы? Для чего они применяются в регулярных выражениях?](#43-Что-такое-метасимволы-Для-чего-они-применяются-в-регулярных-выражениях)

# 1. Что такое поток ввода-вывода?

Поток ввода-вывода - это абстракция для потребления или поставки данных. Цель создания InputStream и OutputStream это
абстрактный доступ к вводу и выводу. Источник при этом не важен. Это может быть файл, консоль, веб-страница. Stream -
это бесконечный поток данных, подключенный к источнику данных

[К оглавлению](#IO)

# 2. Что такое Java IO?

Java IO — это API в Java, который предоставляет инструменты и классы для работы с операциями ввода-вывода, такими как
чтение и запись данных в файлы, консоль, сеть и другие источники. Этот пакет, в первую очередь, состоит из классов,
обеспечивающих доступ к данным в виде потока (stream). Java IO — довольно мощный, низкоуровневый API, который требует
тщательного управления ресурсами. В системе ввода-вывода IO API используется потокоориентированный подход. Данный подход
организует чтение из потока или запись в поток последовательно по несколько байт в один момент времени. Принцип работы
как у обычного потока (Stream). Данные просто передаются из одного места в другое без какого-либо кэширования (
кэширование - это временное хранение данных в памяти), то есть данные
читаются/записываются без промежуточного сохранения в какую-либо область памяти. Такой подход имеет недостаток: нет
возможности перемещаться по содержимому потока ни вперед, ни назад. В IO при чтении из потока или записи в поток (методы
read или write) работа программы блокируется, пока не закончится чтение/запись. Данные читаются побайтово или
посимвольно.

![IO hierarchy](https://github.com/itlazykin/answers_to_exam_questions/blob/main/main/resources/java.IO.png)

Для разных типов данных существуют разные реализации классов

| _                | Byte Based                            | _                                   | Character Based                   | _                           |
|------------------|---------------------------------------|-------------------------------------|-----------------------------------|-----------------------------|
| _                | Input                                 | Output                              | Input                             | Output                      |
| Basic            | InputStream                           | OutputStream                        | Reader / InputStreamReader        | Writer / OutputStreamWriter |
| Arrays           | ByteArrayInputStream                  | ByteArrayOutputStream               | CharArrayReader                   | CharArrayWriter             |
| Files            | FileInputStream / RandomAccessFile    | FileOutputStream / RandomAccessFile | FileReader                        | FileWriter                  |
| Pipes            | PipedInputStream                      | PipedOutputStream                   | PipedReader                       | PipedWriter                 |
| Buffering        | BufferedInputStream                   | BufferedOutputStream                | BufferedReader                    | BufferedWriter              |
| Filtering        | FilterInputStream                     | FilterOutputStream                  | FilterReader                      | FilterWriter                |
| Parsing          | PushbackInputStream / StreamTokenizer | _                                   | PushbackReader / LineNumberReader | _                           |
| Strings          | _                                     | _                                   | StringReader                      | StringWriter                |
| Data             | DataInputStream                       | DataOutputStream                    | _                                 | _                           |
| Data - Formatted | _                                     | PrintStream                         | _                                 | PrintWriter                 |
| Objects          | ObjectInputStream                     | ObjectOutputStream                  | _                                 | _                           |

**Классы Java IO API**

**Базовые**

+ `InputStream` /` OutputStream` - абстрактный класс, определяющий потоковый байтовый ввод/вывод
+ `Reader` / `Writer` - Символьные потоки имеют два основных абстрактных класса `Reader` и `Writer`,
  управляющие потоками символов `Unicode`.
+ `InputStreamReader` / `OutputStreamWriter` Входной/выводной поток, транслирующий байты в символы

**Массивы**

+ `ByteArrayInputStream` / `ByteArrayOutputStream` - использует байтовый массив в потоке.
+ `CharArrayReader` / `CharArrayWriter` - читает/пишет из символьного массива.

**Files**

+ `FileInputStream` / `FileOutputStream` - Чтение/Отправка данных в файл на диске. Реализация класса `OutputStream`
+ `RandomAccessFile` / `RandomAccessFile` - Чтение/запись файлов с произвольным доступом. метод `seek()` позволяет
  переместиться к определенной позиции и изменить хранящееся там значение.
  При использовании RandomAccessFile необходимо знать структуру файла. Класс `RandomAccessFile` содержит методы для
  чтения
  и записи примитивов и строк UTF-8.
  `RandomAccessFile` может открываться в режиме чтения ("r") или чтения/записи ("rw"). Также есть режим "rws", когда
  файл
  открывается для операций чтения-записи и каждое изменение данных файла немедленно записывается на физическое
  устройство.
+ `FileReader` / `FileWriter` `FileWriter` записывает данные в файл. При вводе/выводе практически всегда применяется
  буферизация, поэтому используется `BufferedWriter`.                           
  Когда данные входного потока исчерпываются, метод `readLine()` возвращает `null`. Для потока явно вызывается
  метод `close()`;
  если не вызвать его для всех выходных файловых потоков, в буферах могут остаться данные, и файл получится неполным

**Буферизация**

+ `BufferedInputStream` / `BufferedOutputStream` - буферизируемый поток. Буферы вывода нужно для повышения
  производительности
+ `BufferedReader` / `BufferedWriter`

[К оглавлению](#IO)

# 3. Что такое Java NIO?

Java NIO (New Input/Output) — это набор API, добавленных в Java начиная с версии 1.4, для работы с вводом-выводом на
более высоком уровне, чем традиционный Java IO.
Новая система Java NIO API использует буферориентированный подход. Данный подход организует чтение и запись данных с
помощью их загрузки в специальные буферы, внутри которых можно перемещаться по данным вперед и назад, тем самым
обеспечивается гибкость обработки данных. NIO читает данные в буфер. Обработать можно только те данные, которые уже
считались в буфер. При этом блокировка программы не производится. В основе системы ввода-вывода NIO лежат буферы и
каналы. Буфер хранит данные, а канал - это шлюз, который предоставляет соединение с устройством ввода-вывода (Например,
файл). Система работы NIO: получаем буфер для хранения данных, получаем канал для устройства ввода-вывода. По мере
необходимости загружаем данные в буфер и передаем по каналу.

#### Основные компоненты Java NIO:

+ Буферы (Buffers): Буфер — это контейнер для хранения данных. В отличие от обычных потоков, которые просто передают
  данные, буферы дают возможность записывать данные, перемещать их и повторно использовать. Каждый буфер имеет
  ограниченную емкость и позицию, что помогает управлять данными при чтении или записи.
+ Каналы (Channels): Канал — это двунаправленный поток, через который передаются данные между буферами и устройствами
  ввода-вывода, такими как файлы и сетевые сокеты. Каналы поддерживают асинхронную и неблокирующую работу. Примеры
  каналов:
    - FileChannel — для работы с файлами.
    - SocketChannel — для сетевых соединений (TCP).
    - DatagramChannel — для UDP соединений.
+ Selectors (Селекторы): Селекторы позволяют одному потоку управлять множеством каналов, делая возможным эффективную
  работу с сетью. Селектор следит за состоянием каналов и уведомляет, когда они готовы для операций чтения или записи.
  Это
  помогает избежать необходимости создавать поток на каждый канал, что упрощает масштабирование многопоточных серверных
  приложений.
+ Файловая система: Java NIO также расширил возможности работы с файловой системой через java.nio.file, предоставляя
  классы для удобной работы с путями (Path), файловыми атрибутами и операциями над файлами (чтение, запись, создание
  директорий).

#### Преимущества Java NIO:

- Неблокирующий ввод-вывод: В отличие от традиционного Java IO, где потоки блокируются, пока выполняется операция, NIO
  позволяет работать с неблокирующими каналами. Это особенно полезно для создания серверов, которые могут обслуживать
  множество соединений одновременно.
- Управление памятью: С помощью буферов NIO обеспечивает более точный контроль над использованием памяти.
- Асинхронная обработка данных: NIO позволяет асинхронно работать с данными, что улучшает производительность при
  обработке
  больших объемов.

[К оглавлению](#IO)

# 4. Что такое NIO 2?

NIO.2 — это обновление Java NIO, добавленное в Java 7, которое расширило возможности работы с файловой системой и
асинхронным вводом-выводом. Основной целью NIO.2 было упростить и улучшить работу с файлами, атрибутами файлов, а также
добавить полноценную поддержку асинхронных операций, что сделало NIO более удобным и мощным для современных приложений.

#### Основные возможности NIO.2:

+ Работа с файловой системой:

    - Введен новый API для работы с файлами и директориями через классы Path, Files, и FileSystem. Класс Path пришел на
      смену File, предоставляя более современный и гибкий способ представления путей к файлам и директориям.
    - Класс Files предлагает множество удобных методов для распространенных операций с файлами: создание, копирование,
      перемещение, удаление файлов и папок.
    - Поддержка работы с метаданными файлов (например, даты создания, права доступа) с помощью методов из Files.

+ Пути и файловые системы (Path и FileSystem):
    - Класс Path обеспечивает кроссплатформенное представление пути к файлу или директории, заменяя устаревший File.
    - Класс FileSystem предоставляет интерфейс для работы с различными файловыми системами (например, локальная система,
      удаленные файловые системы, ZIP-архивы), что делает доступ к файлам более универсальным.
+ Поиск и обход файловой системы:
    - NIO.2 предоставляет простой способ рекурсивного обхода директорий через DirectoryStream и Files.walkFileTree. С их
      помощью можно легко обрабатывать файлы в директории и выполнять операции, такие как поиск, копирование или
      удаление.

+ Асинхронный ввод-вывод:

- В NIO.2 были добавлены асинхронные каналы (AsynchronousFileChannel и AsynchronousSocketChannel), которые позволяют
  выполнять ввод-вывод без блокировки, освобождая основной поток для других задач.
- Асинхронный ввод-вывод особенно полезен для серверов, которые обслуживают множество соединений, так как он
  позволяет
  запускать операции чтения и записи в фоне и получать уведомления при их завершении.

+ Поддержка атрибутов и прав доступа к файлам:

    - NIO.2 позволяет работать с файловыми атрибутами, включая такие свойства, как размер файла, время последнего
      изменения
      и расширенные атрибуты, например, права доступа и специальные метаданные.
    - Атрибуты можно получить и установить с помощью Files и PosixFilePermissions, что позволяет точно контролировать
      права
      на доступ к файлам.

#### Преимущества NIO.2:

- Упрощенный и удобный интерфейс для работы с файлами и директориями.
- Улучшенная производительность при работе с файловыми операциями, особенно при асинхронном вводе-выводе.
- Универсальные и платформонезависимые способы обращения к файловой системе.
- Больше контроля над файлами благодаря поддержке атрибутов и прав доступа.

[К оглавлению](#IO)

# 5. Что такое Scanner?

Scanner — это класс в Java, который используется для чтения ввода из различных источников, таких как консоль, файлы и
строки. Этот класс является частью пакета java.util и предоставляет удобный способ для парсинга и анализа текста.
Scanner позволяет легко считывать текстовые данные и преобразовывать их в различные примитивные типы (например, int,
double, boolean) или строки. Вот основные источники ввода, которые Scanner может обрабатывать:

+ Консольный ввод (например, с клавиатуры).
+ Файлы.
+ Строки.
+ Потоки данных (например, InputStream).

Класс Scanner делает процесс чтения данных интуитивно понятным и простым. Scanner автоматически разбивает текст на
токены (части текста), основываясь на разделителях (по умолчанию — пробелы).

### Особенности и ограничения Scanner

+ Проблемы с чтением nextLine() после nextInt() или других методов:
  Если использовать метод nextInt(), а затем сразу же вызвать nextLine(), то можно столкнуться с проблемой пропуска
  строки. Это связано с тем, что nextInt() считывает только число, оставляя символ новой строки (\n) в буфере, который
  затем немедленно считывается nextLine().
  Решение: после nextInt() вызвать scanner.nextLine() для очистки буфера.
+ Закрытие Scanner: Важно закрывать Scanner, когда он больше не нужен, особенно если он используется для чтения из
  файла. Это освобождает ресурсы.
+ Потокобезопасность: Scanner не является потокобезопасным, поэтому не следует использовать его в многопоточной среде
  без синхронизации.

[К оглавлению](#IO)

# 6. Как работает Scanner внутри?

Класс Scanner в Java использует механизм чтения данных и их разбиения на токены (части текста), чтобы затем
преобразовывать эти токены в нужные примитивные типы данных (например, int, double, boolean) или строки.

Внутренняя работа Scanner базируется на следующих ключевых аспектах:

+ Источник ввода.
+ Буферизация данных.
+ Парсинг токенов.
+ Разделители (Delimiters).

Scanner поддерживает несколько источников ввода данных:

+ InputStream (например, System.in — стандартный поток ввода с консоли).
+ File (для чтения из файлов).
+ Readable (для чтения из строк или других источников, реализующих интерфейс Readable).
+ String (обработка данных непосредственно из строки).
  Когда вы создаёте объект Scanner, вы передаёте один из этих источников в конструктор, например:

```java
Scanner scanner = new Scanner(System.in); // Консольный ввод
```

Scanner использует внутренний буфер для хранения данных, которые поступают из источника. Это означает, что данные
считываются порциями, чтобы сократить количество обращений к источнику, особенно в случае работы с медленными ресурсами,
такими как файлы.
Буферизация выполняется с использованием низкоуровневого класса BufferedReader (если источник — это InputStream или
Reader), что повышает производительность за счёт группового чтения данных.

Scanner анализирует данные, разбивая их на токены. Токен — это отдельная часть текста, выделенная на основе заданных
разделителей (по умолчанию пробелы и символы новой строки).
Для анализа текста Scanner использует регулярные выражения и внутренние методы для поиска границ токенов. Например:

+ next() — считывает следующий токен (слово).
+ nextInt() — считывает токен и пытается преобразовать его в int.
+ nextLine() — считывает строку до символа новой строки

По умолчанию, Scanner использует пробелы, табуляцию и символы новой строки как разделители для токенов. Однако, вы
можете изменить разделитель с помощью метода useDelimiter(String pattern), передавая в него регулярное выражение.
Когда Scanner находит разделитель, он считает, что текущий токен завершён и переходит к следующему.

### Пошаговый процесс работы Scanner

+ Создание объекта Scanner: Вы передаёте источник (например, InputStream или File) в конструктор.
  Scanner настраивает буфер для хранения данных.
+ Буферизация данных:
  Scanner считывает данные порциями в буфер для оптимизации чтения.
  Если данных недостаточно для выполнения запроса, Scanner запрашивает новую порцию данных из источника.
+ Разделение данных на токены:
  Scanner использует регулярные выражения для поиска разделителей в тексте.
  Токены разбиваются на основе найденных разделителей.
+ Преобразование данных:
  Методы, такие как nextInt(), nextDouble(), nextBoolean(), пытаются преобразовать текущий токен в соответствующий
  примитивный тип.
  Если преобразование невозможно (например, токен содержит нечисловой текст для nextInt()), возникает исключение
  InputMismatchException.
+ Возвращение данных:
  Если парсинг успешен, метод возвращает данные нужного типа.
  Scanner обновляет свой внутренний указатель на текущую позицию в буфере.

[К оглавлению](#IO)

# 7. Какие базовые методы существуют в Scanner?

+ next() — считывает следующий токен (слово).
+ nextLine() — считывает всю строку.
+ nextInt() — считывает целое число.
+ nextDouble() — считывает число с плавающей точкой.
+ nextBoolean() — считывает булево значение (true или false).
+ hasNext() — проверяет, есть ли ещё токены (данные) для чтения.
+ useDelimiter(String pattern) — позволяет задать разделитель, по которому будет происходить разбиение текста на
  токены (по умолчанию — пробелы и переносы строк)

[К оглавлению](#IO)

# 8. Что такое байтовый поток? Как он реализован внутри?

Байтовые потоки в Java — это основной механизм для работы с вводом и выводом на уровне байтов. Они обеспечивают
низкоуровневый доступ к данным и используются для обработки файлов, сетевых потоков и любых других данных,
представленных в виде байтов.
В Java байтовые потоки делятся на два основных семейства:
`InputStream` — это абстрактный класс, который определяет основные методы для чтения данных. Он реализует
функциональность для последовательного чтения байтов из источника.

### Основные методы класса InputStream:

+ int read() — читает один байт данных и возвращает его. Возвращает -1, если достигнут конец потока.
+ int read(byte[] b) — читает данные в массив байтов b и возвращает количество фактически прочитанных байтов.
+ int read(byte[] b, int off, int len) — читает до len байтов и записывает их в массив b, начиная с индекса off.
+ void close() — закрывает поток и освобождает ресурсы.

```java
import java.io.FileInputStream;
import java.io.IOException;

public class InputStreamExample {
    public static void main(String[] args) {
        try (FileInputStream inputStream = new FileInputStream("example.txt")) {
            int byteData;
            while ((byteData = inputStream.read()) != -1) {
                System.out.print((char) byteData); // Преобразование байта в символ
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

`OutputStream` — это абстрактный класс, который определяет методы для записи данных в виде байтов.

### Основные методы класса OutputStream:

+ void write(int b) — записывает один байт данных.
+ void write(byte[] b) — записывает массив байтов b.
+ void write(byte[] b, int off, int len) — записывает len байтов из массива b, начиная с индекса off.
+ void flush() — очищает буфер потока и записывает все накопленные данные.
+ void close() — закрывает поток и освобождает ресурсы.

```java
import java.io.FileOutputStream;
import java.io.IOException;

public class OutputStreamExample {
    public static void main(String[] args) {
        try (FileOutputStream outputStream = new FileOutputStream("output.txt")) {
            String data = "Hello, world!";
            outputStream.write(data.getBytes()); // Запись строки в файл
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### Как байтовый поток работает внутри?

На уровне реализации байтовые потоки работают с низкоуровневыми байтами данных, независимо от их типа.

1. #### Чтение данных (InputStream)

Когда данные читаются через InputStream, происходит следующий процесс:

+ Чтение одного байта: Метод read() читает один байт за раз. Если источник ввода (например, файл) исчерпан, метод
  возвращает -1.
+ Чтение нескольких байтов: Метод read(byte[] buffer) заполняет массив buffer байтами из источника ввода.
+ Если данных меньше, чем размер буфера, возвращается количество фактически прочитанных байтов.
+ Обработка ошибок: В случае ошибок ввода-вывода, таких как потеря подключения к файлу, метод может выбросить
  IOException.

2. #### Запись данных (OutputStream)

При записи данных с помощью OutputStream происходит:

+ Запись одного байта: Метод write(int b) записывает один байт данных.
+ Запись массива байтов: Метод write(byte[] buffer) записывает сразу несколько байтов из массива buffer.
+ Буферизация и flush(): Если используется буферизированный поток, данные сначала накапливаются в буфере, а затем
  записываются в выходной поток при вызове метода flush() или при заполнении буфера.

3. #### Закрытие потоков

После завершения работы с потоком, всегда важно вызвать метод close(), чтобы освободить все ресурсы и закрыть соединение
с источником (например, файл или сеть). Закрытие потока также вызывает метод flush() для записи всех накопленных данных.

#### Примеры реализаций байтовых потоков

`FileInputStream` и `FileOutputStream`
Эти классы являются прямыми реализациями байтовых потоков для работы с файлами. `FileInputStream` позволяет читать
данные из файла в виде байтов, а `FileOutputStream` — записывать данные в файл.

`BufferedInputStream` и `BufferedOutputStream`
Добавляют буферизацию, что делает операции более эффективными за счёт хранения данных в буфере до тех пор, пока он не
заполнится (или пока не будет вызван flush()).

[К оглавлению](#IO)

# 9. Что такое символьный поток. Как он реализован внутри?

Символьный поток в Java — это поток данных, который работает с символами (char). Символьные потоки предназначены для
работы с текстовыми данными, такими как строки и символы, и учитывают кодировку символов, что позволяет корректно
обрабатывать многоязычный текст. Они являются частью пакета java.io и предоставляют более высокий уровень абстракции по
сравнению с байтовыми потоками.

#### Основные классы символьных потоков

`Reader` — это абстрактный класс, который предоставляет базовые методы для чтения символов. Он предназначен для чтения
текстовых данных из различных источников.

#### Основные методы класса Reader:

+ int read() — читает один символ и возвращает его в виде целого числа (код символа). Возвращает -1, если достигнут
  конец потока.
+ int read(char[] cbuf) — читает данные в массив символов cbuf и возвращает количество фактически прочитанных символов.
+ int read(char[] cbuf, int off, int len) — читает до len символов и записывает их в массив cbuf, начиная с индекса off.
+ void close() — закрывает поток и освобождает ресурсы.

```java
import java.io.FileReader;
import java.io.IOException;

public class FileReaderExample {
    public static void main(String[] args) {
        try (FileReader reader = new FileReader("example.txt")) {
            int character;
            while ((character = reader.read()) != -1) {
                System.out.print((char) character);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

`Writer` — это абстрактный класс, который предоставляет базовые методы для записи символов. Он используется для записи
текстовых данных в различные источники.

#### Основные методы класса Writer:

void write(int c) — записывает один символ.
void write(char[] cbuf) — записывает массив символов cbuf.
void write(char[] cbuf, int off, int len) — записывает len символов из массива cbuf, начиная с индекса off.
void write(String str) — записывает строку str.
void flush() — очищает буфер потока и записывает все накопленные данные.
void close() — закрывает поток и освобождает ресурсы.

```java
import java.io.FileWriter;
import java.io.IOException;

public class FileWriterExample {
    public static void main(String[] args) {
        try (FileWriter writer = new FileWriter("output.txt")) {
            writer.write("Hello, world!");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

#### Как символьный поток работает внутри?

Символьные потоки используют буферизированные массивы символов для чтения и записи данных, обеспечивая работу с текстом
в кодировке Unicode.

1. #### Чтение данных (Reader)
   Когда данные читаются через Reader, происходит:

+ Чтение символов: Метод read() считывает один символ за раз и возвращает его код в виде целого числа. Если источник
  пуст, возвращается -1.
  При чтении данных из источника (например, файла) учитывается кодировка символов, чтобы корректно интерпретировать
  байты как символы.
+ Буферизация: Буферизация позволяет считывать данные построчно или по блокам, что ускоряет процесс по сравнению с
  посимвольным чтением.
+ Обработка ошибок: Если произошла ошибка ввода-вывода (например, файл не найден), метод может выбросить IOException.

2. #### Запись данных (Writer)

При записи данных с помощью Writer:

+ Запись символов: Метод write() записывает один символ за раз или массив символов.
  Данные кодируются в нужную кодировку перед записью (например, UTF-8, UTF-16).
+ Буферизация и flush(): Если используется буферизированный поток, данные накапливаются в буфере и записываются в
  выходной поток, когда буфер заполнен или вызван метод flush().
+ Закрытие потока: После завершения работы с потоком необходимо вызвать close(), чтобы освободить ресурсы и закрыть
  соединение с источником. Это также автоматически вызовет flush() для записи всех накопленных данных.

#### Классы символьных потоков в Java

1. `FileReader` и `FileWriter`
   Эти классы являются прямыми реализациями символьных потоков для работы с текстовыми файлами. `FileReader` позволяет
   читать данные в виде символов из файла, а `FileWriter` — записывать текстовые данные в файл.

2. `BufferedReader` и `BufferedWriter`
   Добавляют буферизацию, что делает операции более эффективными за счёт хранения данных в буфере до тех пор, пока он не
   заполнится.

3. `InputStreamReader` и `OutputStreamWriter`
   Эти классы позволяют преобразовать байтовые потоки в символьные. Они используют указанный набор символов для
   декодирования байтов в символы (`InputStreamReader`) или кодирования символов в байты (`OutputStreamWriter`).
   [К оглавлению](#IO)

# 10. Что такое буферизированный поток?

Буферизированный поток — это поток ввода-вывода в Java, который использует внутренний буфер памяти для повышения
производительности при чтении и записи данных. Он работает за счёт временного хранения данных в буфере, что позволяет
сократить количество обращений к источнику данных или целевому устройству (например, файл, сеть) и уменьшить накладные
расходы на операции ввода-вывода.

+ Буфер — это промежуточное хранилище в памяти, в которое данные сначала считываются или записываются, прежде чем они
  попадут в источник данных или выйдут из него.

Чтение: При чтении данных, вместо того чтобы обращаться к источнику (например, к файлу) каждый раз за одним символом или
байтом, данные загружаются большими блоками в буфер. Когда вы запрашиваете данные, они берутся из буфера, пока буфер не
опустеет. Затем буфер снова заполняется из источника.

Запись: При записи данных они сначала накапливаются в буфере. Когда буфер заполняется или вызывается метод flush(), все
данные из буфера записываются в конечное устройство (например, файл или сеть) единым блоком, что снижает количество
операций записи.

#### Основные классы буферизированных потоков в Java

Байтовые буферизированные потоки:

+ `BufferedInputStream` — буферизированный поток для чтения байтов.
+ `BufferedOutputStream` — буферизированный поток для записи байтов.

```java
import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;

public class BufferedInputStreamExample {
    public static void main(String[] args) {
        try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream("example.txt"))) {
            int data;
            while ((data = bis.read()) != -1) {
                System.out.print((char) data);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

```java
import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class BufferedOutputStreamExample {
    public static void main(String[] args) {
        try (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("output.txt"))) {
            String content = "Hello, World!";
            bos.write(content.getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

Символьные буферизированные потоки:

+ `BufferedReader` — буферизированный поток для чтения символов.
+ `BufferedWriter` — буферизированный поток для записи символов.

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class BufferedReaderExample {
    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader("example.txt"))) {
            String line;
            while ((line = br.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

```java
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class BufferedWriterExample {
    public static void main(String[] args) {
        try (BufferedWriter bw = new BufferedWriter(new FileWriter("output.txt"))) {
            bw.write("Hello, Buffered World!");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

#### Как буферизация реализована внутри?

Буферизация работает за счёт использования внутреннего массива байтов или символов в потоке:

1)Внутренний буфер: Поток использует массив (например, byte[] или char[]) в памяти для временного хранения данных.
Размер буфера можно указать при создании буферизированного потока. Если размер не указан, используется размер по
умолчанию.

2)Чтение данных: При чтении данных из источника (например, файла) данные считываются не по одному символу, а большими
блоками, и сохраняются в буфер. Когда данные запрашиваются, они извлекаются из буфера до тех пор, пока буфер не
опустеет. Затем буфер снова заполняется.

3)Запись данных: При записи данные сначала накапливаются в буфере. Когда буфер заполняется, либо когда вызывается метод
flush(), буфер отправляет данные в целевое устройство (например, файл).

#### Методы, связанные с буферизацией

+ flush() — сбрасывает содержимое буфера в целевое устройство. Обычно вызывается в конце работы с потоком или при
  необходимости записать данные немедленно.
+ close() — закрывает поток и освобождает все связанные ресурсы. При закрытии потока автоматически вызывается flush().

[К оглавлению](#IO)

# 11. Какие классы-обёртки позволяют ускорить чтение или запись за счет использования буфера?

`BufferedInputStream` Оборачивает обычный поток ввода, добавляя к нему буфер. Это позволяет считывать данные большими
блоками, а не по одному байту, что увеличивает производительность.

```java
FileInputStream fileInput = new FileInputStream("file.txt");
BufferedInputStream bufferedInput = new BufferedInputStream(fileInput);
```

`BufferedOutputStream` Оборачивает поток вывода, добавляя буфер. Данные накапливаются в буфере и записываются в целевое
устройство одним большим блоком, что уменьшает количество операций записи.

```java
FileOutputStream fileOutput = new FileOutputStream("output.txt");
BufferedOutputStream bufferedOutput = new BufferedOutputStream(fileOutput);
```

`BufferedReader` Оборачивает символьный поток ввода и добавляет буфер для ускорения чтения строк. Также предоставляет
удобный метод readLine(), который позволяет читать файл построчно.

```java
FileReader fileReader = new FileReader("file.txt");
BufferedReader bufferedReader = new BufferedReader(fileReader);
```

`BufferedWriter` Оборачивает символьный поток вывода, добавляя буфер. Данные накапливаются в буфере, прежде чем
записываются в целевое устройство, что увеличивает производительность.

```java
FileWriter fileWriter = new FileWriter("output.txt");
BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);
```

#### Как эти классы ускоряют чтение и запись?

+ Считывание больших блоков данных вместо поэлементного чтения снижает количество обращений к источнику данных.
+ Запись данных одним блоком уменьшает количество операций записи на диск или в сеть.
+ Буферизация позволяет оптимизировать работу с медленными источниками данных, такими как файловая система или сетевые
  соединения.

[К оглавлению](#IO)

# 12. Как осуществляется ввод и вывод из командной строки?

Ввод и вывод из командной строки в Java осуществляется с использованием класса `Scanner` для ввода и класса `System.out`
для вывода.

+ Класс `Scanner` позволяет считывать данные из различных источников, в том числе из командной строки (консоли). Чаще
  всего `Scanner` используется для чтения данных, введённых пользователем с клавиатуры.

```java
import java.util.Scanner;

public class ConsoleInputExample {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);  // Создаём объект Scanner для чтения данных из System.in

        System.out.println("Введите ваше имя: ");
        String name = scanner.nextLine();  // Считываем строку, введённую пользователем

        System.out.println("Введите ваш возраст: ");
        int age = scanner.nextInt();  // Считываем число (целое) от пользователя

        System.out.println("Привет, " + name + "! Тебе " + age + " лет.");

        scanner.close();  // Закрываем Scanner для освобождения ресурсов
    }
}
```

+ Для вывода данных на консоль в Java используется `System.out`, который предоставляет методы для вывода текста.

```java
public class ConsoleOutputExample {
    public static void main(String[] args) {
        System.out.println("Hello, World!");  // Вывод строки с переводом строки в конце
        System.out.print("Введите число: ");  // Вывод строки без перевода строки
        System.out.printf("Число с форматированием: %d%n", 42);  // Форматированный вывод
    }
}
```

+ Хотя `Scanner` является самым удобным способом для чтения данных из командной строки, в некоторых случаях можно
  использовать `System.in` напрямую, особенно если требуется считывать данные в байтовом формате.

```java
import java.io.IOException;

public class SystemInExample {
    public static void main(String[] args) {
        System.out.println("Введите символ: ");
        try {
            int input = System.in.read();  // Чтение байта из входного потока
            System.out.println("Вы ввели: " + (char) input);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

[К оглавлению](#IO)

# 13. Что такое класс Console? Расскажите его АПИ.

Класс `Console` в Java предоставляет удобный способ взаимодействия с консолью (терминалом) для чтения ввода и вывода
данных. Он является частью пакета `java.io` и предоставляет методы для чтения текстового ввода, а также для
форматированного вывода. В отличие от `Scanner` или `System.in`, класс `Console` имеет ряд дополнительных функций, таких
как безопасное считывание паролей без отображения на экране.
`Console` используется, когда программа запускается в реальной консольной среде (например, в командной строке Windows
или терминале Linux/Mac). Однако Console недоступен в некоторых средах, таких как IDE (например, Eclipse или IntelliJ
IDEA), поэтому для корректного использования программа должна быть запущена из настоящей командной строки.
Для работы с `Console` нужно использовать статический метод System.console(), который возвращает экземпляр `Console`,
если он доступен, или null, если консоль недоступна.

```java
Console console = System.console();
if(console ==null){
        System.out.

println("Консоль недоступна.");
    return;
            }

Пример создания
объекта Console
```

#### Основные методы класса `Console`

1. Чтение строк

+ String readLine() — считывает строку, введённую пользователем, до нажатия клавиши Enter.
+ String readLine(String fmt, Object... args) — выводит отформатированную строку перед считыванием ввода и затем
  считывает введённую строку.

```java
Console console = System.console();
String name = console.readLine("Введите ваше имя: ");
System.out.

println("Привет, "+name +"!");
```

2. Чтение пароля

+ char[] readPassword() — считывает пароль, введённый пользователем, без отображения символов на экране.
+ char[] readPassword(String fmt, Object... args) — выводит отформатированную строку перед считыванием пароля и затем
  считывает пароль без отображения символов.

```java
Console console = System.console();
char[] password = console.readPassword("Введите пароль: ");
// Обработка пароля...

Пароль считывается
как массив
char[],
а не

как строка(String),

чтобы минимизировать
риск утечки
данных,поскольку
char[] можно
быстро о
бнулить после
использования .
```

3. Вывод в консоль

+ void format(String fmt, Object... args) — форматированный вывод в консоль, аналогичный System.out.printf().
+ void printf(String fmt, Object... args) — то же самое, что и format(), выполняет форматированный вывод.

```java
console.printf("Привет, %s! Твой возраст: %d%n","Денчик",30);
```

4. Управление вводом и выводом

+ Reader reader() — возвращает объект Reader, связанный с консолью, который можно использовать для более гибкого
  управления вводом.
+ PrintWriter writer() — возвращает объект PrintWriter, связанный с консолью, для более гибкого управления выводом.

```java
Console console = System.console();
Reader reader = console.reader();
// Чтение данных с использованием Reader

Пример использования
Reader
```

```java
Console console = System.console();
PrintWriter writer = console.writer();
writer.

println("Это пример вывода через PrintWriter.");

Пример использования
PrintWriter
```

#### Особенности и ограничения Console:

+ Безопасное чтение паролей: Одной из главных особенностей класса Console является возможность безопасного считывания
  пароля с помощью метода readPassword(). Это позволяет избежать отображения пароля на экране, что делает Console
  предпочтительным выбором при работе с конфиденциальными данными.
+ Доступность: Console не всегда доступен. Если программа запущена в среде, где консоль недоступна (например, внутри
  IDE), метод System.console() вернёт null. Поэтому перед использованием Console необходимо проверять его наличие.
+ Только для консольного ввода и вывода: Класс Console предназначен только для текстового взаимодействия в консольной
  среде. Он не предназначен для работы с графическими интерфейсами или нестандартными источниками ввода/вывода.

```java
Ниже приведён пример программы,которая использует Console
        для ввода данных и безопасного ввода пароля

import java.io.Console;

public class ConsoleExample {
    public static void main(String[] args) {
        Console console = System.console();

        if (console == null) {
            System.out.println("Консоль недоступна.");
            return;
        }

        // Считывание имени
        String username = console.readLine("Введите имя пользователя: ");

        // Считывание пароля
        char[] password = console.readPassword("Введите пароль: ");

        // Вывод отформатированного сообщения
        console.printf("Добро пожаловать, %s!%n", username);

        // Обнуление массива пароля после использования
        java.util.Arrays.fill(password, ' ');
    }
}

```

[К оглавлению](#IO)

# 14. Что такое поток данных? Data stream.

Поток данных (Data Stream) в Java — это концепция, представляющая собой непрерывный поток байтов или символов,
используемый для чтения или записи данных. Потоки данных позволяют Java-программам взаимодействовать с внешними
источниками данных, такими как файлы, сетевые соединения, консольный ввод/вывод и другие устройства.
В Java под термином Data Stream часто подразумевают специализированные классы-обёртки, такие как DataInputStream и
DataOutputStream, которые позволяют считывать и записывать данные примитивных типов (числа, строки и т. д.) в удобном
формате.
Эти классы работают поверх базовых потоков (InputStream и OutputStream) и позволяют работать с примитивами (например,
int, float, boolean) так, будто они являются объектами. Это делает их использование более удобным, чем ручная работа с
байтами.

#### API классов Data Stream

1. `DataOutputStream` Этот класс является обёрткой над байтовым потоком `OutputStream` и предоставляет методы для записи
   примитивных типов данных:

+ writeInt(int v) — записывает целое число.
+ writeDouble(double v) — записывает число с плавающей точкой.
+ writeBoolean(boolean v) — записывает логическое значение.
+ writeUTF(String s) — записывает строку в формате UTF-8.
+ writeLong(long v), writeFloat(float v), и другие методы для записи примитивных типов.

2. `DataInputStream` Этот класс является обёрткой над байтовым потоком `InputStream` и предоставляет методы для чтения
   примитивных типов данных:

+ readInt() — читает целое число.
+ readDouble() — читает число с плавающей точкой.
+ readBoolean() — читает логическое значение.
+ readUTF() — читает строку в формате UTF-8.
+ readLong(), readFloat(), и другие методы для чтения примитивных типов.

Внутри DataInputStream и DataOutputStream работают с байтовым потоком данных, упаковывая и распаковывая данные
примитивных типов в последовательности байтов. Например, при записи целого числа (int) метод writeInt() преобразует
число в 4 байта (поскольку int занимает 4 байта) и записывает эти байты в поток. При чтении числа методом readInt() те
же 4 байта преобразуются обратно в int.

#### Особенности использования Data Stream

1. Фиксированный формат: При записи данных в бинарном формате важно помнить, что порядок и тип записываемых данных
   должен точно соответствовать порядку и типу данных при чтении.
2. Бинарные данные: Data Streams работают с бинарными данными, что позволяет сэкономить место по сравнению с текстовыми
   форматами, но требует соблюдения формата при чтении и записи.
3. Удобство работы с примитивами: DataInputStream и DataOutputStream значительно упрощают операции с примитивными типами
   данных, скрывая детали кодировки и декодировки байтов.

#### Когда использовать Data Streams?

+ Когда вам нужно записывать и считывать примитивные типы данных или строки в бинарном формате.
+ Когда важна эффективность хранения данных, поскольку бинарный формат может занимать меньше места, чем текстовый.
+ Когда вы разрабатываете собственный формат хранения данных, который будет использоваться только вашим приложением.

```java
Пример использования DataInputStream и DataOutputStream

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class DataStreamExample {
    public static void main(String[] args) {
        // Запись данных в файл с использованием DataOutputStream
        try (DataOutputStream dataOut = new DataOutputStream(new FileOutputStream("data.bin"))) {
            dataOut.writeInt(123);         // Записываем целое число
            dataOut.writeDouble(45.67);    // Записываем число с плавающей точкой
            dataOut.writeBoolean(true);    // Записываем логическое значение
            dataOut.writeUTF("Привет!");   // Записываем строку в формате UTF-8
        } catch (IOException e) {
            e.printStackTrace();
        }

        // Чтение данных из файла с использованием DataInputStream
        try (DataInputStream dataIn = new DataInputStream(new FileInputStream("data.bin"))) {
            int number = dataIn.readInt();         // Чтение целого числа
            double decimal = dataIn.readDouble();  // Чтение числа с плавающей точкой
            boolean flag = dataIn.readBoolean();   // Чтение логического значения
            String text = dataIn.readUTF();        // Чтение строки в формате UTF-8

            System.out.println("Целое число: " + number);
            System.out.println("Число с плавающей точкой: " + decimal);
            System.out.println("Логическое значение: " + flag);
            System.out.println("Строка: " + text);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```

[К оглавлению](#IO)

# 15. Что такое поток объектов, Object stream.

Поток объектов (Object Stream) в Java — это механизм для сериализации и десериализации объектов. Он позволяет записывать
объекты в поток данных и считывать их обратно, что даёт возможность сохранять состояние объектов и передавать их,
например, через сеть или записывать в файл.
Object Stream работает на основе механизма сериализации, который позволяет преобразовывать объект в последовательность
байтов, что позволяет его сохранять или передавать. Обратный процесс — десериализация — восстанавливает объект из этой
последовательности байтов.

#### Основные классы Object Stream

1. `ObjectOutputStream` Этот класс используется для сериализации объектов, т.е. записи объекта в поток в виде байтовой
   последовательности.

```java
Конструктор:

ObjectOutputStream(OutputStream out)

        Создаёт ObjectOutputStream, который
записывает данные
в указанный
OutputStream
```

Основные методы:

+ void writeObject(Object obj) — записывает объект в поток. Объект должен быть сериализуемым (имплементировать интерфейс
  Serializable).
+ void flush() — очищает буфер и записывает все данные в целевой поток.

```java
Пример использования ObjectOutputStream

import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.io.IOException;

public class ObjectOutputStreamExample {
    public static void main(String[] args) {
        try (FileOutputStream fileOut = new FileOutputStream("objectData.bin");
             ObjectOutputStream objOut = new ObjectOutputStream(fileOut)) {

            MyClass myObject = new MyClass("Пример объекта", 42);
            objOut.writeObject(myObject); // Сериализация объекта
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```

2. `ObjectInputStream` Этот класс используется для десериализации объектов, т.е. чтения объекта из потока.

```java
Конструктор

ObjectInputStream(InputStream in)

        Создаёт ObjectInputStream, который
считывает данные
из указанного
InputStream .
```

Основные методы:

+ Object readObject() — считывает объект из потока. Метод возвращает Object, поэтому результат часто приводят к нужному
  типу.
+ void close() — закрывает поток и освобождает ресурсы

```java
Пример использования ObjectInputStream

import java.io.FileInputStream;
import java.io.ObjectInputStream;
import java.io.IOException;

public class ObjectInputStreamExample {
    public static void main(String[] args) {
        try (FileInputStream fileIn = new FileInputStream("objectData.bin");
             ObjectInputStream objIn = new ObjectInputStream(fileIn)) {

            MyClass myObject = (MyClass) objIn.readObject(); // Десериализация объекта
            System.out.println(myObject);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

#### Сериализация и интерфейс Serializable

Для того чтобы объект можно было сериализовать с помощью ObjectOutputStream, класс объекта должен реализовать интерфейс
Serializable. Этот интерфейс является маркерным (не содержит методов) и служит сигналом Java-машине, что объекты этого
класса могут быть преобразованы в байтовую последовательность.

#### Особенности и ограничения потоков объектов:

+ Сериализация требует Serializable: Объект, который нужно записать в поток, должен реализовать интерфейс Serializable.
  Если этого не сделать, при попытке сериализации будет выброшено исключение java.io.NotSerializableException.
+ Поле transient: Поля, помеченные ключевым словом transient, не сериализуются. Это полезно для данных, которые не нужно
  сохранять (например, временные данные или данные, которые не должны сохраняться из соображений безопасности).
+ Версии классов: При изменении структуры класса (добавление/удаление полей) возможны проблемы при десериализации старых
  версий. Для этого используется serialVersionUID — специальное поле, которое служит для управления версиями класса.

```java
Пример полного кода с сериализацией и десериализацией

import java.io.*;

public class SerializationExample {
    public static void main(String[] args) {
        // Сериализация объекта
        try (FileOutputStream fileOut = new FileOutputStream("example.bin");
             ObjectOutputStream objOut = new ObjectOutputStream(fileOut)) {

            Person person = new Person("Денчик", 35);
            objOut.writeObject(person); // Сериализация
        } catch (IOException e) {
            e.printStackTrace();
        }

        // Десериализация объекта
        try (FileInputStream fileIn = new FileInputStream("example.bin");
             ObjectInputStream objIn = new ObjectInputStream(fileIn)) {

            Person deserializedPerson = (Person) objIn.readObject(); // Десериализация
            System.out.println("Десериализованный объект: " + deserializedPerson);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}

class Person implements Serializable {
    private static final long serialVersionUID = 1L; // Идентификатор версии класса
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + "}";
    }
}
```

#### Преимущества использования Object Stream

+ Простота работы с объектами: Позволяет напрямую записывать и считывать объекты, не преобразовывая их вручную в байты.
+ Сохранение состояния: Легко сохранять состояние сложных объектов (содержат другие объекты или коллекции), что удобно
  для долговременного хранения или передачи данных.
+ Мощное API: ObjectInputStream и ObjectOutputStream поддерживают большинство стандартных примитивов и объекты
  коллекций, таких как ArrayList.

#### Недостатки использования Object Stream

+ Требование к сериализуемости: Классы должны реализовывать интерфейс Serializable, что иногда может быть сложно для
  сложных структур.
+ Неэффективность при изменении классов: При изменении полей класса могут возникнуть проблемы при десериализации старых
  данных, если не управлять версиями с помощью serialVersionUID.
+ Небезопасность: Сериализация не является безопасной, если данные могут быть перехвачены или модифицированы. Лучше
  избегать её использования для передачи чувствительной информации.
  [К оглавлению](#IO)

# 16. Что такое Path? Как он реализуется на разных ОС?

Path — это интерфейс в Java, представляющий собой путь к файлу или директории в файловой системе. Он является частью
пакета java.nio.file (NIO — New I/O), который был введён в Java 7, чтобы обеспечить более современный и удобный API для
работы с файлами и путями по сравнению с устаревшим java.io.File.
Path можно рассматривать как абстракцию для пути к файлу или директории. В Java Path представлен интерфейсом, который
позволяет работать с файловыми путями, обрабатывать их части (каталоги, имена файлов), нормализовать путь, соединять
пути и выполнять другие операции.

#### Основные классы и интерфейсы, связанные с Path:

+ Path — основной интерфейс, представляющий путь.
+ Paths — класс с утилитарными методами для создания объектов Path.
+ Files — вспомогательный класс для работы с файлами и директориями, используя Path.

```java
Пример создания объекта Path

import java.nio.file.Path;
import java.nio.file.Paths;

public class PathExample {
    public static void main(String[] args) {
        // Создание объекта Path
        Path path = Paths.get("/users/denchik/documents/example.txt");

        // Вывод информации о пути
        System.out.println("Путь: " + path);
        System.out.println("Имя файла: " + path.getFileName());
        System.out.println("Родительская директория: " + path.getParent());
        System.out.println("Количество элементов в пути: " + path.getNameCount());
    }
}
```

#### Реализация Path на разных операционных системах

Path является платформонезависимым интерфейсом. Это означает, что он одинаково работает на различных операционных
системах, абстрагируясь от особенностей каждой платформы. Java использует внутренние реализации Path в зависимости от
операционной системы, чтобы учитывать особенности её файловой системы.

##### Примеры различий между ОС:

+ Windows использует обратные слэши (\) как разделители в пути, а также поддерживает устройство в начале пути (например,
  C:\).
+ UNIX-подобные системы (например, Linux, macOS) используют прямые слэши (/) в качестве разделителей, и у них
  отсутствует концепция устройства.

Java автоматически обрабатывает эти различия. Например, при создании объекта Path, если код выполняется на Windows, пути
автоматически адаптируются к этой ОС.

#### Как Java управляет различиями между ОС:

Java использует специальный класс `FileSystem`, который определяет поведение файловой системы в зависимости от
платформы. Этот класс предоставляет конкретную реализацию Path для каждой системы:

+ На Windows используется WindowsFileSystem, и объект Path создаётся как WindowsPath.
+ На Linux/UNIX используется UnixFileSystem, и объект Path создаётся как UnixPath.

Таким образом, когда вы вызываете Paths.get("путь"), Java создаёт объект Path, подходящий для текущей ОС.

#### Как Java обрабатывает пути на разных ОС?

+ Разделители путей: Java автоматически выбирает правильный разделитель (/ или \) в зависимости от ОС.
+ Корневые элементы: На Windows путь может начинаться с имени устройства (C:\), а на UNIX-подобных ОС путь начинается с
  корня (/). Java корректно интерпретирует такие различия.
+ Форматирование пути: Java нормализует пути, удаляя избыточные элементы, например . (текущая директория) или .. (
  родительская директория).

```java
import java.nio.file.Path;
import java.nio.file.Paths;

public class CrossPlatformPathExample {
    public static void main(String[] args) {
        // Используем Paths.get() для создания платформонезависимого пути
        Path path = Paths.get("folder", "subfolder", "file.txt");

        // Выводим путь в зависимости от ОС
        System.out.println("Путь: " + path);

        // Нормализация пути
        Path normalizedPath = path.normalize();
        System.out.println("Нормализованный путь: " + normalizedPath);
    }
}
```

#### Основные методы интерфейса Path:

+ getFileName() — возвращает имя файла или последнего элемента пути.
+ getParent() — возвращает родительский путь.
+ getRoot() — возвращает корневой элемент пути (например, C:\ на Windows или / на UNIX).
+ resolve(Path other) — добавляет указанный путь к текущему пути.
+ relativize(Path other) — создаёт относительный путь между текущим и указанным путём.
+ normalize() — удаляет избыточные элементы из пути (. и ..).
+ toAbsolutePath() — возвращает абсолютный путь.
+ toUri() — преобразует путь в URI.

#### Работа с классом Files:

`Files` — это утилитарный класс, который работает с `Path` и предоставляет методы для взаимодействия с файловой
системой:

+ Files.exists(Path path) — проверяет существование файла или директории.
+ Files.createFile(Path path) — создаёт новый файл.
+ Files.createDirectory(Path path) — создаёт новую директорию.
+ Files.copy(Path source, Path target) — копирует файл или директорию.
+ Files.move(Path source, Path target) — перемещает или переименовывает файл/директорию.
+ Files.delete(Path path) — удаляет файл или директорию.

```java
Пример работы с классом Files

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.io.IOException;

public class FilesExample {
    public static void main(String[] args) {
        Path path = Paths.get("example.txt");

        try {
            // Создание файла, если его нет
            if (!Files.exists(path)) {
                Files.createFile(path);
                System.out.println("Файл создан: " + path.toAbsolutePath());
            }

            // Запись данных в файл
            Files.write(path, "Привет, Денчик!".getBytes());
            System.out.println("Данные записаны.");

            // Чтение данных из файла
            String content = Files.readString(path);
            System.out.println("Содержимое файла: " + content);

            // Удаление файла
            Files.delete(path);
            System.out.println("Файл удалён.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

[К оглавлению](#IO)

# 17. Как получить список файлов?

+ Для простых задач можно использовать класс File и его метод listFiles().

```java
import java.io.File;

public class ListFilesExample {
    public static void main(String[] args) {
        // Указываем директорию, в которой нужно получить список файлов
        File directory = new File("путь/к/вашей/директории");

        // Получаем массив файлов и поддиректорий
        File[] filesList = directory.listFiles();

        if (filesList != null) {
            for (File file : filesList) {
                // Проверяем, является ли это файлом или директорией
                if (file.isFile()) {
                    System.out.println("Файл: " + file.getName());
                } else if (file.isDirectory()) {
                    System.out.println("Директория: " + file.getName());
                }
            }
        } else {
            System.out.println("Директория не существует или доступ к ней невозможен.");
        }
    }
}
```

+ Для более сложных задач и фильтрации лучше использовать классы Path и Files из пакета java.nio.file.

```java
import java.nio.file.*;
import java.io.IOException;

public class ListFilesWithPathExample {
    public static void main(String[] args) {
        // Указываем путь к директории
        Path directory = Paths.get("путь/к/вашей/директории");

        try (DirectoryStream<Path> stream = Files.newDirectoryStream(directory)) {
            for (Path path : stream) {
                if (Files.isRegularFile(path)) {
                    System.out.println("Файл: " + path.getFileName());
                } else if (Files.isDirectory(path)) {
                    System.out.println("Директория: " + path.getFileName());
                }
            }
        } catch (IOException e) {
            System.out.println("Ошибка при чтении директории: " + e.getMessage());
        }
    }
}
```

+ Files.list() и Stream API позволяют гибко управлять потоками данных и применять фильтры.

```java
import java.nio.file.*;
import java.io.IOException;
import java.util.stream.Stream;

public class ListFilesWithStreamExample {
    public static void main(String[] args) {
        // Указываем путь к директории
        Path directory = Paths.get("путь/к/вашей/директории");

        try (Stream<Path> paths = Files.list(directory)) {
            paths.forEach(path -> {
                if (Files.isRegularFile(path)) {
                    System.out.println("Файл: " + path.getFileName());
                } else if (Files.isDirectory(path)) {
                    System.out.println("Директория: " + path.getFileName());
                }
            });
        } catch (IOException e) {
            System.out.println("Ошибка при чтении директории: " + e.getMessage());
        }
    }
}
```

[К оглавлению](#IO)

# 18. Как проверить что файловая сущность является файлом или папкой?

+ File: Используйте методы isFile() и isDirectory() для простых задач проверки.

```java
import java.io.File;

public class FileCheckExample {
    public static void main(String[] args) {
        // Создание объекта File для проверки
        File file = new File("путь/к/вашему/файлу_или_папке");

        // Проверка, является ли это файлом
        if (file.isFile()) {
            System.out.println("Это файл.");
        } else if (file.isDirectory()) {
            System.out.println("Это директория.");
        } else {
            System.out.println("Это несуществующая файловая сущность.");
        }
    }
}
```

+ Path и Files: Используйте методы Files.isRegularFile() и Files.isDirectory() для более мощного и современного подхода
  к проверке файловых сущностей.

```java
import java.nio.file.*;
import java.io.IOException;

public class PathCheckExample {
    public static void main(String[] args) {
        // Создание объекта Path для проверки
        Path path = Paths.get("путь/к/вашему/файлу_или_папке");

        try {
            // Проверка, является ли это файлом
            if (Files.isRegularFile(path)) {
                System.out.println("Это файл.");
            } else if (Files.isDirectory(path)) {
                System.out.println("Это директория.");
            } else {
                System.out.println("Это несуществующая файловая сущность или специальный файл.");
            }
        } catch (IOException e) {
            System.out.println("Ошибка при проверке пути: " + e.getMessage());
        }
    }
}
```

+ В новых проектах предпочтительно использовать API java.nio.file, так как он предоставляет более продвинутые и удобные
  возможности для работы с файловой системой.

[К оглавлению](#IO)

# 19. Как удалить файл?

Класс File предоставляет метод delete(), который удаляет файл или пустую директорию.

```java
import java.io.File;

public class DeleteFileExample {
    public static void main(String[] args) {
        // Создание объекта File для файла, который нужно удалить
        File file = new File("путь/к/вашему/файлу.txt");

        // Удаление файла
        if (file.delete()) {
            System.out.println("Файл успешно удалён.");
        } else {
            System.out.println("Не удалось удалить файл.");
        }
    }
}
```

Современный подход к удалению файла заключается в использовании Path и метода Files.delete() или Files.deleteIfExists()

```java
Пример с использованием Files.delete()

import java.nio.file.*;
import java.io.IOException;

public class DeleteFileWithPathExample {
    public static void main(String[] args) {
        // Создание объекта Path для файла, который нужно удалить
        Path path = Paths.get("путь/к/вашему/файлу.txt");

        try {
            // Удаление файла
            Files.delete(path);
            System.out.println("Файл успешно удалён.");
        } catch (NoSuchFileException e) {
            System.out.println("Файл не найден.");
        } catch (IOException e) {
            System.out.println("Ошибка при удалении файла: " + e.getMessage());
        }
    }
}

```

```java
Пример с использованием Files.deleteIfExists()

import java.nio.file.*;
import java.io.IOException;

public class DeleteFileIfExistsExample {
    public static void main(String[] args) {
        // Создание объекта Path для файла, который нужно удалить
        Path path = Paths.get("путь/к/вашему/файлу.txt");

        try {
            // Удаление файла, если он существует
            boolean isDeleted = Files.deleteIfExists(path);
            if (isDeleted) {
                System.out.println("Файл успешно удалён.");
            } else {
                System.out.println("Файл не найден.");
            }
        } catch (IOException e) {
            System.out.println("Ошибка при удалении файла: " + e.getMessage());
        }
    }
}
```

+ delete() в File и Files бросает исключение, если файл не найден, поэтому подходит для ситуаций, когда вы точно
  ожидаете, что файл существует.
+ deleteIfExists() полезен, когда файл может не существовать, и вам не нужно бросать исключение в таком случае.

[К оглавлению](#IO)

# 20. Как переместить файл?

Старый способ перемещения файла с использованием класса File — это просто выполнить копирование в новое место и затем
удалить исходный файл. В классе File нет прямого метода для перемещения, поэтому придётся использовать метод renameTo(),
который работает как для переименования, так и для перемещения файла.

```java
Пример с использованием File.renameTo()

import java.io.File;

public class MoveFileExample {
    public static void main(String[] args) {
        // Создание объекта File для файла, который нужно переместить
        File sourceFile = new File("путь/к/вашему/исходному_файлу.txt");
        // Новый путь, куда нужно переместить файл
        File destFile = new File("путь/к/новой/директории/файл.txt");

        // Перемещение файла
        if (sourceFile.renameTo(destFile)) {
            System.out.println("Файл успешно перемещён.");
        } else {
            System.out.println("Не удалось переместить файл.");
        }
    }
}

```

Современный и более надёжный способ — это использование Path и метода Files.move(), который специально предназначен для
перемещения файла.

```java
import java.nio.file.*;
import java.io.IOException;

public class MoveFileWithPathExample {
    public static void main(String[] args) {
        // Создание объекта Path для исходного файла
        Path sourcePath = Paths.get("путь/к/вашему/исходному_файлу.txt");
        // Новый путь, куда нужно переместить файл
        Path targetPath = Paths.get("путь/к/новой/директории/файл.txt");

        try {
            // Перемещение файла
            Files.move(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);
            System.out.println("Файл успешно перемещён.");
        } catch (IOException e) {
            System.out.println("Ошибка при перемещении файла: " + e.getMessage());
        }
    }
}
```

#### Дополнительные параметры перемещения

Метод Files.move() поддерживает использование опций из StandardCopyOption:

+ StandardCopyOption.REPLACE_EXISTING — заменяет файл в целевой директории, если он уже существует.
+ StandardCopyOption.ATOMIC_MOVE — выполняет атомарное перемещение (если поддерживается файловой системой), что
  гарантирует, что файл будет перемещён либо полностью, либо не будет перемещён вовсе.

```java
import java.nio.file.*;
import java.io.IOException;

public class MoveFileWithOptionsExample {
    public static void main(String[] args) {
        // Создание объекта Path для исходного файла
        Path sourcePath = Paths.get("путь/к/вашему/исходному_файлу.txt");
        // Новый путь, куда нужно переместить файл
        Path targetPath = Paths.get("путь/к/новой/директории/файл.txt");

        try {
            // Перемещение файла с заменой и атомарным перемещением
            Files.move(sourcePath, targetPath,
                    StandardCopyOption.REPLACE_EXISTING,
                    StandardCopyOption.ATOMIC_MOVE);
            System.out.println("Файл успешно перемещён с использованием атомарного перемещения.");
        } catch (IOException e) {
            System.out.println("Ошибка при перемещении файла: " + e.getMessage());
        }
    }
}
```

+ renameTo() в File прост в использовании, но не всегда надёжен. Он не предоставляет детальной информации о возможных
  ошибках и может не сработать на некоторых файловых системах.
+ Files.move() в java.nio.file является более гибким и надёжным, поддерживает обработку исключений и дополнительные
  опции.

[К оглавлению](#IO)

# 21. Как управлять атрибутами файла?

В Java управление атрибутами файла (такими как дата создания, права доступа и другие метаданные) осуществляется с
помощью API java.nio.file. В частности, используются классы Files, Path, и различные интерфейсы из пакета
java.nio.file.attribute.

1. Чтение базовых атрибутов файла
   Для чтения базовых атрибутов (дата создания, последняя модификация и т.д.) можно использовать интерфейс
   BasicFileAttributes с помощью метода Files.readAttributes().

```java
import java.nio.file.*;
import java.nio.file.attribute.*;
import java.io.IOException;

public class BasicFileAttributesExample {
    public static void main(String[] args) {
        // Создание объекта Path для файла
        Path path = Paths.get("путь/к/вашему/файлу.txt");

        try {
            // Чтение базовых атрибутов файла
            BasicFileAttributes attributes = Files.readAttributes(path, BasicFileAttributes.class);

            System.out.println("Дата создания: " + attributes.creationTime());
            System.out.println("Последняя модификация: " + attributes.lastModifiedTime());
            System.out.println("Размер файла: " + attributes.size() + " байт");
            System.out.println("Является ли это директорией: " + attributes.isDirectory());
        } catch (IOException e) {
            System.out.println("Ошибка при чтении атрибутов файла: " + e.getMessage());
        }
    }
}
```

2. Изменение базовых атрибутов файла
   Для изменения атрибутов, таких как время последней модификации, используется метод Files.setAttribute().

```java
import java.nio.file.*;
import java.io.IOException;
import java.nio.file.attribute.FileTime;
import java.time.Instant;

public class SetFileAttributeExample {
    public static void main(String[] args) {
        // Создание объекта Path для файла
        Path path = Paths.get("путь/к/вашему/файлу.txt");

        try {
            // Установка времени последней модификации на текущее время
            FileTime newTime = FileTime.from(Instant.now());
            Files.setAttribute(path, "basic:lastModifiedTime", newTime);

            System.out.println("Время последней модификации изменено.");
        } catch (IOException e) {
            System.out.println("Ошибка при изменении атрибутов файла: " + e.getMessage());
        }
    }
}
```

3. Управление правами доступа
   Для управления правами доступа в Java существует интерфейс PosixFileAttributes и класс PosixFilePermissions. Они
   позволяют работать с POSIX-совместимыми правами доступа (только на UNIX-подобных системах).

```java
import java.nio.file.*;
import java.nio.file.attribute.*;
import java.io.IOException;

public class FilePermissionsExample {
    public static void main(String[] args) {
        // Создание объекта Path для файла
        Path path = Paths.get("путь/к/вашему/файлу.txt");

        try {
            // Установка прав доступа (только для UNIX-подобных систем)
            Set<PosixFilePermission> perms = PosixFilePermissions.fromString("rwxr-x---");
            Files.setPosixFilePermissions(path, perms);

            System.out.println("Права доступа изменены.");
        } catch (UnsupportedOperationException e) {
            System.out.println("POSIX права не поддерживаются на данной системе.");
        } catch (IOException e) {
            System.out.println("Ошибка при изменении прав доступа: " + e.getMessage());
        }
    }
}
```

4. Чтение и изменение пользовательских атрибутов (xattr)
   Java позволяет работать с пользовательскими атрибутами, такими как метки или заметки, которые можно добавлять к
   файлам на поддерживаемых файловых системах. Для этого используется метод Files.getAttribute() и Files.setAttribute().

```java
import java.nio.file.*;
import java.io.IOException;

public class UserDefinedFileAttributesExample {
    public static void main(String[] args) {
        // Создание объекта Path для файла
        Path path = Paths.get("путь/к/вашему/файлу.txt");

        try {
            // Установка пользовательского атрибута
            String attributeName = "user.comment";
            String comment = "Это тестовый файл.";
            Files.setAttribute(path, attributeName, comment);

            // Чтение пользовательского атрибута
            String retrievedComment = (String) Files.getAttribute(path, attributeName);
            System.out.println("Пользовательский комментарий: " + retrievedComment);
        } catch (IOException e) {
            System.out.println("Ошибка при работе с пользовательскими атрибутами: " + e.getMessage());
        }
    }
}
```

5. Проверка и удаление атрибутов

+ Для проверки существования атрибута можно использовать метод Files.getAttribute().
+ Для удаления атрибута используется метод Files.setAttribute() с null значением для некоторых типов атрибутов, либо с
  использованием соответствующих методов управления правами.
  ####Рекомендации по использованию:
+ BasicFileAttributes — используйте для чтения базовых атрибутов (создание, модификация и т.д.).
+ PosixFileAttributes — подходит для управления правами на UNIX-подобных системах.
+ Пользовательские атрибуты — используйте для добавления меток или комментариев к файлам, если это поддерживается
  файловой системой.
+ Методы Files.getAttribute() и Files.setAttribute() позволяют управлять атрибутами файлов на более низком уровне и
  поддерживают различные типы атрибутов.

[К оглавлению](#IO)

# 22. Как создать файл?

Создать файл в Java можно несколькими способами с использованием классов File из пакета java.io и Files из пакета
java.nio.file. Каждый из этих методов имеет свои особенности и может быть применён в зависимости от ситуации

1. Использование класса File (пакет java.io)
   Старый, но простой способ создать файл — это использовать класс File. Метод createNewFile() позволяет создать новый
   файл, если его ещё нет в указанной директории.

```java
import java.io.File;
import java.io.IOException;

public class CreateFileExample {
    public static void main(String[] args) {
        // Создание объекта File для нового файла
        File file = new File("путь/к/новому_файлу.txt");

        try {
            // Создание нового файла
            if (file.createNewFile()) {
                System.out.println("Файл успешно создан: " + file.getName());
            } else {
                System.out.println("Файл уже существует.");
            }
        } catch (IOException e) {
            System.out.println("Ошибка при создании файла: " + e.getMessage());
        }
    }
}
```

2. Использование класса Files (пакет java.nio.file)
   Современный и более предпочтительный способ создания файла — это использование класса Files вместе с интерфейсом
   Path. Метод Files.createFile() создаёт файл и выбрасывает исключение, если файл уже существует.

```java
import java.nio.file.*;
import java.io.IOException;

public class CreateFileWithPathExample {
    public static void main(String[] args) {
        // Создание объекта Path для нового файла
        Path path = Paths.get("путь/к/новому_файлу.txt");

        try {
            // Создание нового файла
            Files.createFile(path);
            System.out.println("Файл успешно создан: " + path.getFileName());
        } catch (FileAlreadyExistsException e) {
            System.out.println("Файл уже существует.");
        } catch (IOException e) {
            System.out.println("Ошибка при создании файла: " + e.getMessage());
        }
    }
}
```

3. Создание временного файла Если вам нужно создать временный файл, который не должен сохраняться после завершения
   программы, можно использовать метод Files.createTempFile().

```java
import java.nio.file.*;
import java.io.IOException;

public class CreateTempFileExample {
    public static void main(String[] args) {
        try {
            // Создание временного файла с префиксом "temp" и суффиксом ".txt"
            Path tempFile = Files.createTempFile("temp", ".txt");
            System.out.println("Временный файл создан: " + tempFile.toAbsolutePath());
        } catch (IOException e) {
            System.out.println("Ошибка при создании временного файла: " + e.getMessage());
        }
    }
}
```

4. Создание файла с указанием прав доступа (только для UNIX-систем)
   Если нужно создать файл с определёнными правами доступа, это можно сделать с помощью опций FileAttribute в
   Files.createFile().

```java
import java.nio.file.*;
import java.nio.file.attribute.*;
import java.io.IOException;
import java.util.Set;

public class CreateFileWithPermissionsExample {
    public static void main(String[] args) {
        Path path = Paths.get("путь/к/новому_файлу.txt");

        try {
            // Установка прав доступа
            Set<PosixFilePermission> permissions = PosixFilePermissions.fromString("rw-r-----");
            FileAttribute<Set<PosixFilePermission>> fileAttributes = PosixFilePermissions.asFileAttribute(permissions);

            // Создание файла с заданными правами доступа
            Files.createFile(path, fileAttributes);
            System.out.println("Файл успешно создан с правами доступа: " + permissions);
        } catch (IOException e) {
            System.out.println("Ошибка при создании файла: " + e.getMessage());
        }
    }
}
```

#### Сравнение методов создания файла

+ File.createNewFile(): простой, но не самый надёжный способ. Может не работать на некоторых файловых системах, и
  отсутствует гибкость при установке прав доступа.
+ Files.createFile(): более современный способ с поддержкой обработки исключений и возможностью настройки прав доступа.
+ Files.createTempFile(): создаёт временный файл, который автоматически удаляется после завершения программы.

[К оглавлению](#IO)

# 23. Как создать директорию?

1. Использование класса File (пакет java.io) Старый, но всё ещё используемый способ создания директории — это метод
   mkdir() или mkdirs() класса File.

+ mkdir() — создаёт одну директорию. Вернёт false, если путь к директории не существует.
+ mkdirs() — создаёт всю структуру директорий, если какая-то часть пути отсутствует.

```java
import java.io.File;

public class CreateDirectoryExample {
    public static void main(String[] args) {
        // Создание объекта File для новой директории
        File directory = new File("путь/к/новой/директории");

        // Создание директории
        if (directory.mkdir()) {
            System.out.println("Директория успешно создана: " + directory.getPath());
        } else {
            System.out.println("Не удалось создать директорию.");
        }
    }
}

import java.io.File;

public class CreateDirectoriesExample {
    public static void main(String[] args) {
        // Создание объекта File для нескольких директорий
        File directories = new File("путь/к/нескольким/новым/директориям");

        // Создание всей структуры директорий
        if (directories.mkdirs()) {
            System.out.println("Структура директорий успешно создана: " + directories.getPath());
        } else {
            System.out.println("Не удалось создать структуру директорий.");
        }
    }
}

```

2. Использование класса Files (пакет java.nio.file) Современный и рекомендуемый способ создания директории — это
   использование класса Files вместе с интерфейсом Path.

+ Files.createDirectory(path) создаёт одну директорию и выбрасывает исключение IOException, если путь не существует или
  директория уже есть.
+ Files.createDirectories(path) создаёт всю структуру директорий, если какая-то часть пути отсутствует.

```java
import java.nio.file.*;
import java.io.IOException;

public class CreateDirectoryWithPathExample {
    public static void main(String[] args) {
        // Создание объекта Path для новой директории
        Path path = Paths.get("путь/к/новой/директории");

        try {
            // Создание директории
            Files.createDirectory(path);
            System.out.println("Директория успешно создана: " + path);
        } catch (IOException e) {
            System.out.println("Ошибка при создании директории: " + e.getMessage());
        }
    }
}

import java.nio.file .*;
        import java.io.IOException;

public class CreateDirectoriesWithPathExample {
    public static void main(String[] args) {
        // Создание объекта Path для нескольких директорий
        Path path = Paths.get("путь/к/нескольким/новым/директориям");

        try {
            // Создание всей структуры директорий
            Files.createDirectories(path);
            System.out.println("Структура директорий успешно создана: " + path);
        } catch (IOException e) {
            System.out.println("Ошибка при создании структуры директорий: " + e.getMessage());
        }
    }
}
```

[К оглавлению](#IO)

# 24. Как записать в файл?

1. Использование класса FileWriter для записи текстовых данных в файл.

```java
import java.io.FileWriter;
import java.io.IOException;

public class FileWriterExample {
    public static void main(String[] args) {
        try (FileWriter writer = new FileWriter("example.txt", false)) { // false = перезаписать файл
            writer.write("Привет, мир!"); // Записываем строку в файл
            writer.write(System.lineSeparator()); // Переход на новую строку
            writer.write("Как дела?");
            System.out.println("Запись завершена.");
        } catch (IOException e) {
            System.out.println("Произошла ошибка: " + e.getMessage());
        }
    }
}

Аргумент false указывает,
что файл
будет перезаписан.
Если указать true,
данные будут
добавлены в
конец файла.
В блоке try-with-
resources ресурс
закрывается автоматически.
```

2. Использование класса BufferedWriter, используется для буферизированной записи, что увеличивает производительность при
   записи больших объёмов данных.

```java
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class BufferedWriterExample {
    public static void main(String[] args) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter("example.txt"))) {
            writer.write("Буферизированная запись.");
            writer.newLine(); // Добавляет новую строку
            writer.write("Это быстрее для больших файлов.");
            System.out.println("Запись завершена.");
        } catch (IOException e) {
            System.out.println("Произошла ошибка: " + e.getMessage());
        }
    }
}
```

3. PrintWriter упрощает запись строк, позволяя использовать знакомые методы вроде println().

````java
import java.io.PrintWriter;
import java.io.IOException;

public class PrintWriterExample {
    public static void main(String[] args) {
        try (PrintWriter writer = new PrintWriter("example.txt")) {
            writer.println("Привет, мир!"); // Записываем строку с переходом на новую строку
            writer.println("Запись упрощена.");
            System.out.println("Запись завершена.");
        } catch (IOException e) {
            System.out.println("Произошла ошибка: " + e.getMessage());
        }
    }
}
````

4. Использование класса Files (пакет java.nio.file). Современный способ, который позволяет работать с текстом и
   бинарными файлами.

```java
import java.nio.file.*;
import java.io.IOException;
import java.util.Arrays;

public class FilesWriteExample {
    public static void main(String[] args) {
        Path path = Paths.get("example.txt");

        try {
            Files.write(path, Arrays.asList("Привет, мир!", "Как дела?"), StandardOpenOption.CREATE);
            System.out.println("Запись завершена.");
        } catch (IOException e) {
            System.out.println("Произошла ошибка: " + e.getMessage());
        }
    }
}

Метод Files.

write() принимает коллекцию строк для записи.
Аргумент StandardOpenOption.
        CREATE указывает, что
файл нужно
создать,
если его
нет .
```

5. Использование класса DataOutputStream. Подходит для записи примитивных данных (int, double, char и т.д.) в бинарном
   формате.

```java
import java.io.DataOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class DataOutputStreamExample {
    public static void main(String[] args) {
        try (DataOutputStream dos = new DataOutputStream(new FileOutputStream("example.dat"))) {
            dos.writeInt(123); // Записываем число
            dos.writeDouble(45.67); // Записываем число с плавающей точкой
            dos.writeUTF("Привет!"); // Записываем строку
            System.out.println("Запись завершена.");
        } catch (IOException e) {
            System.out.println("Произошла ошибка: " + e.getMessage());
        }
    }
}
```

6. Использование класса ObjectOutputStream. Используется для записи объектов в файл (сериализация).

```java
import java.io.*;

public class ObjectOutputStreamExample {
    public static void main(String[] args) {
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("example.obj"))) {
            oos.writeObject("Привет, мир!"); // Сериализация строки
            oos.writeObject(123); // Сериализация числа
            System.out.println("Запись завершена.");
        } catch (IOException e) {
            System.out.println("Произошла ошибка: " + e.getMessage());
        }
    }
}

Класс записываемого
объекта должен
реализовать интерфейс
Serializable .
```

[К оглавлению](#IO)

# 25. Как прочитать данные из файла?

1. FileReader используется для чтения текстовых файлов (символьных данных).

```java
import java.io.FileReader;
import java.io.IOException;

public class FileReaderExample {
    public static void main(String[] args) {
        try (FileReader reader = new FileReader("example.txt")) {
            int character;
            while ((character = reader.read()) != -1) { // Читаем символы один за другим
                System.out.print((char) character);
            }
        } catch (IOException e) {
            System.out.println("Ошибка при чтении файла: " + e.getMessage());
        }
    }
}

Метод read() возвращает символ в виде целочисленного значения,

которое нужно
привести к
char.

Закрытие ресурса(FileReader) автоматически происходит в блоке try-with-resources .
```

2. BufferedReader добавляет буферизацию, что делает его быстрее для больших файлов. Этот класс также позволяет читать
   строки целиком.

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class BufferedReaderExample {
    public static void main(String[] args) {
        try (BufferedReader reader = new BufferedReader(new FileReader("example.txt"))) {
            String line;
            while ((line = reader.readLine()) != null) { // Читаем файл строка за строкой
                System.out.println(line);
            }
        } catch (IOException e) {
            System.out.println("Ошибка при чтении файла: " + e.getMessage());
        }
    }
}
```

3. Scanner — это простой и удобный инструмент для чтения данных из файла, строки или потока. Подходит для анализа
   структурированных текстов.

```java
import java.io.File;
import java.io.IOException;
import java.util.Scanner;

public class ScannerExample {
    public static void main(String[] args) {
        try (Scanner scanner = new Scanner(new File("example.txt"))) {
            while (scanner.hasNextLine()) { // Проверяем, есть ли следующая строка
                System.out.println(scanner.nextLine()); // Читаем строку
            }
        } catch (IOException e) {
            System.out.println("Ошибка при чтении файла: " + e.getMessage());
        }
    }
}

hasNextLine() проверяет наличие следующей строки.
Можно также
использовать scanner.

nextInt(), 
scanner.

nextDouble() и другие методы для чтения чисел.
```

4. Использование класса Files (пакет java.nio.file)

```java
import java.nio.file.*;
import java.io.IOException;
import java.util.List;

public class FilesReadExample {
    public static void main(String[] args) {
        try {
            List<String> lines = Files.readAllLines(Paths.get("example.txt"));
            for (String line : lines) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.out.println("Ошибка при чтении файла: " + e.getMessage());
        }
    }
}

Files.

readAllLines() читает весь файл в список строк (List<String>),
что удобно
для небольших
файлов.
        Для больших
файлов можно
использовать потоковый
интерфейс Files.

lines().
```

5. Использование класса DataInputStream. Для чтения примитивных данных (int, double, char и т.д.) в бинарном формате.

```java
import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.IOException;

public class DataInputStreamExample {
    public static void main(String[] args) {
        try (DataInputStream dis = new DataInputStream(new FileInputStream("example.dat"))) {
            int number = dis.readInt(); // Читаем целое число
            double value = dis.readDouble(); // Читаем число с плавающей точкой
            String text = dis.readUTF(); // Читаем строку в формате UTF-8
            System.out.println("Данные: " + number + ", " + value + ", " + text);
        } catch (IOException e) {
            System.out.println("Ошибка при чтении файла: " + e.getMessage());
        }
    }
}
```

6. Использование класса ObjectInputStream. Используется для десериализации объектов.

```java
import java.io.*;

public class ObjectInputStreamExample {
    public static void main(String[] args) {
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("example.obj"))) {
            String text = (String) ois.readObject(); // Читаем строку
            int number = (int) ois.readObject(); // Читаем число
            System.out.println("Данные: " + text + ", " + number);
        } catch (IOException | ClassNotFoundException e) {
            System.out.println("Ошибка при чтении файла: " + e.getMessage());
        }
    }
}

Объекты должны

быть сериализуемыми(implements Serializable).
```

| Метод              | Подходит для                       | Преимущества                     | Недостатки                          |
|--------------------|------------------------------------|----------------------------------|-------------------------------------|
| FileReader         | Текстовые файлы                    | Простота использования           | Менее эффективен для больших файлов |
| BufferedReader     | Большие текстовые файлы            | Высокая производительность       | Требует больше кода                 |
| Scanner            | Структурированные текстовые данные | Простота анализа данных          | Менее производителен                |
| Files.readAllLines | Чтение небольших файлов целиком    | Современный, удобный для списков | Не подходит для больших файлов      |
| DataInputStream    | Бинарные файлы                     | Простота работы с примитивами    | Требует знание формата файла        |
| ObjectInputStream  | Сериализованные объекты            | Простота работы с объектами      | Только для сериализованных данных   |

[К оглавлению](#IO)

# 26. Для чего нужны классы PrintStream и PrintWriter? В чем их различие?

Классы PrintStream и PrintWriter в Java предназначены для упрощения записи текстовых данных в выходной поток. Они
предоставляют удобные методы для форматирования и записи строк, чисел и других типов данных. Однако у них есть важные
различия в реализации и использовании.

1. Что такое PrintStream? Класс PrintStream используется для записи данных в текстовом формате в поток вывода, например,
   в консоль или файл. Он чаще всего применяется для работы с байтовыми потоками, так как наследуется от класса
   OutputStream.

#### Ключевые особенности PrintStream:

+ Позволяет записывать данные (строки, числа, символы) в поток в удобной форме.
+ Не выбрасывает исключения IOException при записи (ошибки игнорируются).
+ Поддерживает метод print() и его перегруженные варианты.
+ По умолчанию используется для системного вывода через System.out.

```java
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.io.IOException;

public class PrintStreamExample {
    public static void main(String[] args) {
        try (PrintStream ps = new PrintStream(new FileOutputStream("example.txt"))) {
            ps.println("Привет, мир!"); // Запись строки с переходом на новую строку
            ps.print(123); // Запись числа без перехода
            ps.printf(" Форматированное число: %.2f", 45.6789); // Форматированный вывод
        } catch (IOException e) {
            System.out.println("Ошибка при записи: " + e.getMessage());
        }
    }
}

println() добавляет символ новой строки после записи.

print() записывает данные без перехода на новую строку.

printf() позволяет форматировать строки с использованием шаблонов.
```

2. Что такое PrintWriter? Класс PrintWriter аналогичен PrintStream, но предназначен для работы с символьными потоками.
   Это делает его более подходящим для работы с текстовыми файлами или потоками, поддерживающими символы (например,
   Writer).

#### Ключевые особенности PrintWriter:

+ Работает с Writer, а не с OutputStream.
+ Поддерживает буферизацию, что делает его эффективнее для записи текста.
+ Исключения IOException также игнорируются, как и у PrintStream.
+ Подходит для записи текстовых данных, особенно при работе с символами Unicode.

```java
import java.io.FileWriter;
import java.io.PrintWriter;
import java.io.IOException;

public class PrintWriterExample {
    public static void main(String[] args) {
        try (PrintWriter pw = new PrintWriter(new FileWriter("example.txt"))) {
            pw.println("Привет, мир!"); // Запись строки с переходом на новую строку
            pw.print(123); // Запись числа без перехода
            pw.printf(" Форматированное число: %.2f", 45.6789); // Форматированный вывод
        } catch (IOException e) {
            System.out.println("Ошибка при записи: " + e.getMessage());
        }
    }
}
```

#### Когда использовать какой класс?

- PrintStream:
  Для системного вывода (например, System.out).
  Для записи данных в байтовые потоки (например, в файл в бинарном формате).
  Когда требуется простой и быстрый способ записи текста в поток вывода.

+ PrintWriter:
  Для работы с текстовыми файлами или потоками символов.
  Когда важна поддержка Unicode.
  Для форматированной записи текста, особенно если данные хранятся в символах (например, JSON или XML).

  | Критерий          | PrintStream                               | PrintWriter                               |
      |-------------------|-------------------------------------------|-------------------------------------------|
  | Работа с потоками | Использует OutputStream (байтовые потоки) | Использует Writer (символьные потоки)     |
  | Тип данных        | Подходит для записи байтов и текста       | Оптимален для текстовых данных            |
  | Поддержка Unicode | Может быть ограничена                     | Полная поддержка Unicode                  |
  | Буферизация       | Не буферизирован                          | Часто буферизирован                       |
  | Поток вывода      | System.out (наследуется)                  | Нужно явно указать поток (например, файл) |
  | Исключения        | Игнорирует IOException                    | Игнорирует IOException                    |

[К оглавлению](#IO)

# 27. Что такое потоки байтовых массивов? Как они устроены?

Потоки байтовых массивов в Java — это потоки ввода/вывода, которые работают с массивами байтов в памяти вместо файлов
или других внешних ресурсов. Они предоставляют удобный способ читать и записывать данные в массивы байтов.

1. ByteArrayInputStream: чтение байтов из массива

#### Как работает?

+ Данные хранятся в массиве байтов, который вы передаете в конструктор.
+ Класс предоставляет методы для последовательного чтения данных из массива.
+ Чтение происходит как будто из файла или другого потока, но источник данных — это массив в памяти.

```java
import java.io.ByteArrayInputStream;
import java.io.IOException;

public class ByteArrayInputStreamExample {
    public static void main(String[] args) {
        byte[] data = {65, 66, 67, 68}; // Байты для символов 'A', 'B', 'C', 'D'

        try (ByteArrayInputStream bais = new ByteArrayInputStream(data)) {
            int byteRead;
            while ((byteRead = bais.read()) != -1) { // Читаем байт за байтом
                System.out.println("Прочитано: " + (char) byteRead);
            }
        } catch (IOException e) {
            System.out.println("Ошибка: " + e.getMessage());
        }
    }
}

Ключевые методы

read() —
считывает следующий
байт,возвращает -1,
если достигнут конец.

reset() —
возвращает указатель
чтения в
начало массива.

available() —
возвращает количество
байтов,
доступных для
чтения .
```

2. ByteArrayOutputStream: запись байтов в массив

#### Как работает?

+ Класс записывает байты в массив, который создается динамически в памяти.
+ Размер массива автоматически увеличивается при записи новых данных.
+ После завершения записи данные можно извлечь в виде массива или строки.

```java
import java.io.ByteArrayOutputStream;
import java.io.IOException;

public class ByteArrayOutputStreamExample {
    public static void main(String[] args) {
        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
            baos.write(65); // Записываем байт (символ 'A')
            baos.write(66); // Записываем байт (символ 'B')
            baos.write(67); // Записываем байт (символ 'C')

            byte[] result = baos.toByteArray(); // Извлекаем записанные байты

            System.out.println("Результат: " + new String(result)); // Преобразуем в строку
        } catch (IOException e) {
            System.out.println("Ошибка: " + e.getMessage());
        }
    }
}

Ключевые методы

write(int b) —
записывает один байт.

write(byte[] b, int off, int len) —
записывает часть массива.

toByteArray() —
возвращает массив
записанных байтов.

reset() —
        очищает буфер, позволяя
начать запись
заново .
```

#### Как устроены внутри?

1. ByteArrayInputStream

+ Хранит массив байтов в приватном поле.
+ Внутренний указатель (pos) отслеживает текущую позицию для чтения.
+ Метод read() возвращает текущий байт и сдвигает указатель вперед.

```java
public class ByteArrayInputStreamExample {
    private byte[] buffer;
    private int pos = 0;

    public ByteArrayInputStreamExample(byte[] buf) {
        this.buffer = buf;
    }

    public int read() {
        if (pos < buffer.length) {
            return buffer[pos++] & 0xFF; // Читаем байт и сдвигаем указатель
        } else {
            return -1; // Конец данных
        }
    }
}
```

2. ByteArrayOutputStream

+ Использует внутренний массив, который увеличивается при необходимости.
+ При достижении предела создается новый массив большего размера, а данные копируются.
+ После завершения записи данные можно извлечь с помощью метода toByteArray().

```java
public class ByteArrayOutputStreamExample {
    private byte[] buffer;
    private int size = 0;

    public ByteArrayOutputStreamExample() {
        this.buffer = new byte[32]; // Начальный размер
    }

    public void write(int b) {
        if (size == buffer.length) {
            expandBuffer();
        }
        buffer[size++] = (byte) b;
    }

    private void expandBuffer() {
        byte[] newBuffer = new byte[buffer.length * 2];
        System.arraycopy(buffer, 0, newBuffer, 0, buffer.length);
        buffer = newBuffer;
    }

    public byte[] toByteArray() {
        return java.util.Arrays.copyOf(buffer, size);
    }
}
```

#### Когда использовать потоки байтовых массивов?

+ Буферизация данных: Когда нужно временно сохранить данные в памяти для последующей обработки.
+ Тестирование: Легко заменить файл или сеть массивом байтов для имитации ввода/вывода.
+ Обработка данных в памяти: Удобно работать с данными, которые не нужно записывать на диск.
+ Сериализация/Десериализация: Часто используется для работы с объектами или данных в бинарном формате.

[К оглавлению](#IO)

# 28. Зачем нужен класс RandomAccessFile?

Класс RandomAccessFile в Java предназначен для работы с файлами, которые нужно читать или записывать в произвольном
порядке, а не последовательно. Это мощный инструмент для работы с файлами, когда требуется прямой доступ к их
содержимому, без необходимости считывать или записывать данные с начала до конца.

#### Основные возможности RandomAccessFile

+ Произвольный доступ к данным: Можно читать или записывать данные в любом месте файла, управляя позицией указателя
  чтения/записи.
  Указатель текущей позиции изменяется методами для перемещения (seek) и чтения/записи.
+ Режимы работы:r: только чтение. rw: чтение и запись.
+ Поддержка различных типов данных: Методы для чтения и записи примитивных типов (например, readInt, writeDouble).
+ Изменение существующего файла: Можно перезаписывать часть данных файла, не затрагивая остальную его часть.

```java
import java.io.RandomAccessFile;
import java.io.IOException;

public class RandomAccessFileExample {
    public static void main(String[] args) {
        try (RandomAccessFile raf = new RandomAccessFile("example.dat", "rw")) {
            raf.writeInt(42);         // Записываем целое число
            raf.writeDouble(3.14159); // Записываем число с плавающей точкой
            raf.writeUTF("Привет!");  // Записываем строку в формате UTF-8
        } catch (IOException e) {
            System.out.println("Ошибка при работе с файлом: " + e.getMessage());
        }
    }
}

Запись данных
в файл
```

```java
import java.io.RandomAccessFile;
import java.io.IOException;

public class RandomAccessFileReadExample {
    public static void main(String[] args) {
        try (RandomAccessFile raf = new RandomAccessFile("example.dat", "r")) {
            int number = raf.readInt();       // Читаем целое число
            double pi = raf.readDouble();     // Читаем число с плавающей точкой
            String message = raf.readUTF();  // Читаем строку в формате UTF-8

            System.out.println("Число: " + number);
            System.out.println("Число Пи: " + pi);
            System.out.println("Сообщение: " + message);
        } catch (IOException e) {
            System.out.println("Ошибка при чтении файла: " + e.getMessage());
        }
    }
}

Чтение данных
из файла
```

#### Произвольное чтение и запись

Перемещение указателя:
Метод seek(long position) перемещает указатель чтения/записи в указанную позицию.
Например, чтобы записать данные в середине файла или переписать их.

```java
import java.io.RandomAccessFile;
import java.io.IOException;

public class RandomAccessFileSeekExample {
    public static void main(String[] args) {
        try (RandomAccessFile raf = new RandomAccessFile("example.dat", "rw")) {
            raf.seek(4); // Перемещаемся на 4-й байт
            raf.writeInt(99); // Перезаписываем данные

            raf.seek(0); // Возвращаемся в начало
            System.out.println("Перезаписанное число: " + raf.readInt());
        } catch (IOException e) {
            System.out.println("Ошибка: " + e.getMessage());
        }
    }
}
```

#### Реализация RandomAccessFile

Основан на низкоуровневых операциях ввода/вывода (через классы FileDescriptor и нативные методы).
Управляет указателем позиции, который отслеживает, откуда будет происходить следующая операция чтения или записи.
Обеспечивает синхронизацию для потокобезопасного доступа.

#### Когда использовать RandomAccessFile?

+ Редактирование больших файлов:Если файл слишком велик, чтобы загружать его в память, но нужно изменить только часть
  данных.
+ Работа с бинарными форматами данных:Например, с файлами баз данных, мультимедийными файлами или сериализованными
  объектами.
+ Чтение файла по частям:Например, для реализации загрузки или обработки больших данных с учетом их структуры.
+ Тестирование и отладка:Легко проверить содержимое файла или записать данные для экспериментов.

#### Ограничения

+ Только файловая работа: Класс не может использоваться с сетевыми потоками или другими источниками.
+ Неудобство при работе с текстовыми файлами: Требуется самостоятельно обрабатывать преобразование строк в байты и
  обратно.
+ Неавтоматическое расширение файлов: Если указатель перемещается за конец файла, то пустое пространство не заполняется
  автоматически.
  [К оглавлению](#IO)

# 29. Данные в каком виде можно считывать байтовыми и символьными потоками?

1. Байтовые потоки (InputStream и OutputStream)

#### Что можно считывать?

Байтовые потоки работают с сырыми байтами (8 бит), поэтому они идеально подходят для работы с любыми бинарными данными,
такими как:

+ Файлы: Изображения, аудио, видео.
  Архивы, исполняемые файлы.
+ Протоколы передачи данных:
  Сетевые данные.
  Последовательные порты.
+ Любые двоичные данные:
  Форматы данных, например PDF, DOCX.
  Объекты в сериализованном виде.

```java
import java.io.FileInputStream;
import java.io.IOException;

public class ByteStreamExample {
    public static void main(String[] args) {
        try (FileInputStream fis = new FileInputStream("binary.dat")) {
            int byteData;
            while ((byteData = fis.read()) != -1) {
                System.out.print(byteData + " "); // Читаем байт за байтом
            }
        } catch (IOException e) {
            System.out.println("Ошибка чтения файла: " + e.getMessage());
        }
    }
}

Пример:
чтение бинарного
файла
```

2. Символьные потоки (Reader и Writer)

#### Что можно считывать?

Символьные потоки работают с текстовыми данными (16 бит), которые представлены в виде символов Unicode. Они используются
для чтения и записи текстовых файлов и строк. Примеры:

+ Текстовые файлы: .txt, .csv, .json, .xml.
+ Текст в кодировках: UTF-8, UTF-16, ASCII, и другие.
+ Лог-файлы, конфигурации.

```java
import java.io.FileReader;
import java.io.IOException;

public class CharStreamExample {
    public static void main(String[] args) {
        try (FileReader reader = new FileReader("text.txt")) {
            int charData;
            while ((charData = reader.read()) != -1) {
                System.out.print((char) charData); // Читаем символ за символом
            }
        } catch (IOException e) {
            System.out.println("Ошибка чтения файла: " + e.getMessage());
        }
    }
}

Пример:
чтение текстового
файла
```

| Характеристика      | Байтовые потоки                              | Символьные потоки                                   |
|---------------------|----------------------------------------------|-----------------------------------------------------|
| Тип данных          | Сырые байты (byte, 8 бит).                   | Символы (char, 16 бит).                             |
| Использование       | Бинарные данные: изображения, видео, архивы. | Текстовые данные: строки, текстовые файлы.          |
| Поддержка кодировок | Кодировка не учитывается                     | Автоматическая поддержка кодировок, например UTF-8. |
| Примеры классов     | FileInputStream, ByteArrayInputStream.       | FileReader, BufferedReader, PrintWriter.            |

#### Особенности выбора подходящего потока

+ Когда использовать байтовые потоки: Если файл содержит не только текст, но и форматированные данные (например, .pdf,
  .jpg, .zip).
  Когда необходимо считывать сырые данные без преобразования.
+ Когда использовать символьные потоки: Если требуется работа с текстовыми файлами.
  Когда нужно обрабатывать строки или символы, особенно с учетом кодировок.
+ Преобразование между потоками: Если данные хранятся в байтовом формате, но нужно их интерпретировать как текст,
  используют классы InputStreamReader или OutputStreamWriter, которые преобразуют байты в символы на основе заданной
  кодировки.

```java
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.io.IOException;

public class StreamConversionExample {
    public static void main(String[] args) {
        try (FileInputStream fis = new FileInputStream("text.txt");
             InputStreamReader isr = new InputStreamReader(fis, "UTF-8");
             BufferedReader reader = new BufferedReader(isr)) {

            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.out.println("Ошибка чтения файла: " + e.getMessage());
        }
    }
}

Пример преобразования
байтового потока
в символьный
```

[К оглавлению](#IO)

# 30. Что такое сокет?

Сокет в Java (и в сетевых технологиях в целом) — это программный интерфейс для обмена данными между двумя узлами (
клиентом и сервером) в сети. Он предоставляет средства для создания и управления подключением по сети, отправки и
получения данных.

#### Основные характеристики сокета

+ Сетевой интерфейс: Используется для обмена данными через TCP или UDP протоколы.
  Поддерживает двустороннюю связь (клиент ↔ сервер).
+ Типы сокетов: TCP-сокеты:
  Основаны на протоколе TCP (Transmission Control Protocol).
  Обеспечивают надежную передачу данных с подтверждением доставки.
  Используют классы Socket и ServerSocket в Java.
+ UDP-сокеты: Основаны на протоколе UDP (User Datagram Protocol).
  Менее надежны, но быстрее, так как не требуют подтверждения.
  Используют класс DatagramSocket в Java.
+ Основные операции:Создание сокета.
  Подключение к удаленному узлу.
  Отправка и получение данных.
  Закрытие подключения.

```java
Пример использования TCP-сокетов

import java.io.*;
import java.net.*;

public class Server {
    public static void main(String[] args) {
        try (ServerSocket serverSocket = new ServerSocket(8080)) {
            System.out.println("Сервер запущен, ожидаем подключения...");

            try (Socket clientSocket = serverSocket.accept(); // Ожидаем клиента
                 BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                 PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {

                System.out.println("Клиент подключился!");

                String message;
                while ((message = in.readLine()) != null) {
                    System.out.println("Сообщение от клиента: " + message);
                    out.println("Сервер получил: " + message);
                }
            }
        } catch (IOException e) {
            System.err.println("Ошибка сервера: " + e.getMessage());
        }
    }
}

Сервер
```

```java
import java.io.*;
import java.net.*;

public class Client {
    public static void main(String[] args) {
        try (Socket socket = new Socket("localhost", 8080);
             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
             BufferedReader consoleInput = new BufferedReader(new InputStreamReader(System.in))) {

            System.out.println("Подключен к серверу!");

            String userInput;
            while ((userInput = consoleInput.readLine()) != null) {
                out.println(userInput); // Отправляем данные на сервер
                System.out.println("Ответ сервера: " + in.readLine());
            }
        } catch (IOException e) {
            System.err.println("Ошибка клиента: " + e.getMessage());
        }
    }
}

Клиент
```

#### Как это работает?

+ Сервер: Создает объект ServerSocket и ожидает подключения.
  Принимает запрос от клиента с помощью метода accept().
  Создает сокет для взаимодействия с конкретным клиентом.
+ Клиент: Создает объект Socket, чтобы подключиться к серверу (указывая IP-адрес и порт).
  Устанавливает соединение с сервером и обменивается данными через потоки.

```java
Пример использования UDP-сокетов

import java.net.*;

public class UDPServer {
    public static void main(String[] args) {
        try (DatagramSocket socket = new DatagramSocket(8080)) {
            byte[] buffer = new byte[1024];
            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);

            System.out.println("UDP-сервер запущен. Ожидаем данных...");

            socket.receive(packet); // Принимаем данные
            String received = new String(packet.getData(), 0, packet.getLength());
            System.out.println("Получено: " + received);
        } catch (Exception e) {
            System.err.println("Ошибка UDP-сервера: " + e.getMessage());
        }
    }
}

Сервер
```

```java
import java.net.*;

public class UDPClient {
    public static void main(String[] args) {
        try (DatagramSocket socket = new DatagramSocket()) {
            String message = "Привет, сервер!";
            byte[] buffer = message.getBytes();
            InetAddress address = InetAddress.getByName("localhost");

            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 8080);
            socket.send(packet); // Отправляем данные
        } catch (Exception e) {
            System.err.println("Ошибка UDP-клиента: " + e.getMessage());
        }
    }
}

Клиент
```

#### Где используются сокеты?

+ Веб-приложения: HTTP, WebSocket-соединения для общения между клиентом и сервером.
+ Мессенджеры: Передача сообщений в реальном времени.
+ Игры: Организация сетевых матчей.
+ Сетевые службы: Сервисы, работающие по TCP/UDP.

[К оглавлению](#IO)

# 31. Какие виды сокетов есть в Java? С каким протоколом они работают?

1. `TCP-сокеты` Работают с протоколом TCP (Transmission Control Protocol). Этот протокол обеспечивает надежное
   соединение и гарантированную доставку данных.

#### Классы для работы с TCP-сокетами:

+ Socket: клиентский сокет. Используется для установления соединения с сервером.
  Поддерживает двустороннюю передачу данных (чтение/запись через потоки).
+ ServerSocket: серверный сокет. Ожидает входящих подключений от клиентов.
  Создает объекты Socket для каждого подключившегося клиента.

#### Особенности TCP-сокетов:

+ Перед началом передачи данных устанавливается соединение между клиентом и сервером.
+ Данные передаются в виде потока байтов.
+ Контролируется порядок доставки данных и целостность информации.
  Пример использования TCP-сокетов:
  (Код клиента и сервера можно найти в предыдущем ответе.)

2. `UDP-сокеты` Работают с протоколом UDP (User Datagram Protocol). Этот протокол является менее надежным, но более
   быстрым, так как не требует установления соединения.

#### Классы для работы с UDP-сокетами:

+ DatagramSocket: Используется для отправки и получения датаграмм (пакетов данных).
  Работает как на стороне клиента, так и на стороне сервера.
+ DatagramPacket: Представляет собой пакет данных, который можно отправить или получить через DatagramSocket.

#### Особенности UDP-сокетов:

+ Нет установления соединения: сообщения отправляются как независимые пакеты.
+ Нет гарантии доставки, порядка или целостности данных.
+ Подходит для приложений, где важна скорость (например, видеостриминг, онлайн-игры).
  Пример использования UDP-сокетов:
  (Код клиента и сервера приведен в предыдущем ответе.)

  | Характеристика     | TCP-сокеты                                  | UDP-сокеты                         |
        |--------------------|---------------------------------------------|------------------------------------|
  | Протокол	          | TCP (надежный, соединение-ориентированный). | UDP (ненадежный, без соединения).  |
  | Гарантия доставки  | Да                                          | Нет                                |
  | Порядок доставки   | Гарантирован                                | Не гарантирован                    |
  | Производительность | Медленнее из-за накладных расходов.         | Быстрее за счет меньшего контроля. |
  | Тип передачи       | Поток данных                                | Отдельные пакеты                   |
  | Применение         | Веб-приложения, файловые трансферы.         | Онлайн-игры, потоковое видео.      |

#### Дополнительные виды сокетов:

+ Многоадресные сокеты (Multicast Sockets): Используются для работы с группами узлов в сети.
  Работают на основе UDP.
  Класс: MulticastSocket.
+ Unix Domain Sockets (доступны через библиотеки): Локальные соединения между процессами на одной машине.
  Не являются частью стандартной Java, но могут быть реализованы через сторонние библиотеки.

[К оглавлению](#IO)

# 32. Как отправить через сокет сообщение?

Чтобы отправить сообщение через сокет, в Java используются входные и выходные потоки (InputStream и OutputStream),
которые ассоциированы с сокетом.

#### Пример передачи сообщения через сокет (TCP)

Клиент отправляет сообщение серверу

+ Клиентская сторона: Подключается к серверу с помощью Socket.
  Получает OutputStream из сокета.
  Использует потоки для записи данных (например, PrintWriter или BufferedWriter).
+ Серверная сторона: Принимает соединение через ServerSocket.
  Получает InputStream из клиентского сокета.
  Читает данные через поток (например, BufferedReader или Scanner).

```java
Код клиента

import java.io.*;
import java.net.*;

public class Client {
    public static void main(String[] args) {
        try (Socket socket = new Socket("localhost", 8080); // Подключение к серверу
             PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) { // Поток для отправки данных

            System.out.println("Клиент подключен к серверу.");
            String message = "Привет, сервер!";
            out.println(message); // Отправляем сообщение
            System.out.println("Сообщение отправлено: " + message);

        } catch (IOException e) {
            System.err.println("Ошибка клиента: " + e.getMessage());
        }
    }
}

Код сервера

import java.io .*;
        import java.net .*;

public class Server {
    public static void main(String[] args) {
        try (ServerSocket serverSocket = new ServerSocket(8080)) {
            System.out.println("Сервер запущен и ожидает подключения...");

            try (Socket clientSocket = serverSocket.accept(); // Принимаем подключение клиента
                 BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()))) { // Поток для чтения данных

                System.out.println("Клиент подключился.");
                String receivedMessage = in.readLine(); // Читаем сообщение
                System.out.println("Сообщение от клиента: " + receivedMessage);
            }

        } catch (IOException e) {
            System.err.println("Ошибка сервера: " + e.getMessage());
        }
    }
}

```

```java
Если клиент
и сервер
должны обмениваться
данными,
оба должны
использовать и

входной(InputStream),и выходной (OutputStream)

потоки.

        Код клиента(двусторонний):

        try(
Socket socket = new Socket("localhost", 8080);
PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))){

        out.

println("Привет, сервер!"); // Отправляем сообщение

String serverResponse = in.readLine(); // Читаем ответ от сервера
    System.out.

println("Ответ от сервера: "+serverResponse);

}catch(
IOException e){
        e.

printStackTrace();
}

Код сервера(двусторонний):

        try(
ServerSocket serverSocket = new ServerSocket(8080)){
        System.out.

println("Сервер запущен...");
    
    try(
Socket clientSocket = serverSocket.accept();
BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)){

String clientMessage = in.readLine(); // Читаем сообщение от клиента
        System.out.

println("Сообщение от клиента: "+clientMessage);
        
        out.

println("Сообщение принято!"); // Отправляем ответ клиенту
    }

            }catch(
IOException e){
        e.

printStackTrace();
}
```

```java
Если вы

используете DatagramSocket(UDP),данные передаются через пакеты.

Код клиента(UDP):

        try(
DatagramSocket socket = new DatagramSocket()){
String message = "Привет, сервер!";
byte[] buffer = message.getBytes();
InetAddress address = InetAddress.getByName("localhost");
DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 8080);

    socket.

send(packet); // Отправляем пакет
    System.out.

println("Пакет отправлен!");
}catch(
IOException e){
        e.

printStackTrace();
}

Код сервера(UDP):

        try(
DatagramSocket socket = new DatagramSocket(8080)){
byte[] buffer = new byte[1024];
DatagramPacket packet = new DatagramPacket(buffer, buffer.length);

    System.out.

println("UDP-сервер запущен...");
    socket.

receive(packet); // Получаем пакет

String received = new String(packet.getData(), 0, packet.getLength());
    System.out.

println("Сообщение: "+received);
}catch(
IOException e){
        e.

printStackTrace();
}


```

[К оглавлению](#IO)

# 33. Что такое логирование?

Логирование — это процесс записи информации о работе программы, который помогает отслеживать её поведение, отлаживать
ошибки и анализировать производительность. Логи (записи) создаются для фиксирования различных событий, состояний, ошибок
или предупреждений в приложении.

#### Зачем нужно логирование?

+ Отладка и диагностика: Помогает разработчикам обнаруживать и исправлять ошибки.
  Удобно для анализа неожиданных ситуаций или багов.
+ Мониторинг: Используется для наблюдения за работой приложения в реальном времени (например, отслеживание активности
  пользователей или загрузки системы).
+ Аудит: Фиксирует действия пользователя и системы для проверки и анализа (например, кто и когда изменил данные).
+ Отчётность и аналитика: Логи могут быть источником данных для отчётов и анализа производительности приложения.

#### Как логирование работает в Java?

1. Стандартное логирование (java.util.logging) Java предоставляет встроенный API для логирования, который поддерживает
   следующие функции:

+ Различные уровни логов.
+ Запись логов в консоль или файл.
+ Настройка через конфигурационные файлы.

```java
import java.util.logging.Logger;
import java.util.logging.Level;

public class LoggingExample {
    private static final Logger logger = Logger.getLogger(LoggingExample.class.getName());

    public static void main(String[] args) {
        logger.info("Приложение запущено");
        logger.warning("Это предупреждение");
        logger.severe("Произошла ошибка");
    }
}
```

2. Популярные сторонние библиотеки

+ SLF4J (Simple Logging Facade for Java): Универсальный интерфейс, поддерживающий различные реализации логеров (Logback,
  Log4j и другие).
+ Log4j (Apache): Высокофункциональная библиотека для логирования.
  Поддерживает гибкую конфигурацию через XML, YAML или properties-файлы.
+ Logback: Современная замена Log4j.
  Высокая производительность, поддержка сложных шаблонов и ротации файлов.

```java
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class Log4jExample {
    private static final Logger logger = LogManager.getLogger(Log4jExample.class);

    public static void main(String[] args) {
        logger.info("Это сообщение уровня INFO");
        logger.error("Это сообщение уровня ERROR");
    }
}

Пример с
использованием Log4j
```

#### Где хранятся логи?

+ Консоль: Для удобства просмотра в процессе работы.
+ Файлы: Для долговременного хранения и анализа.
+ Системы мониторинга: Специальные сервисы, такие как ELK Stack, Splunk или Graylog, для централизованного сбора и
  анализа логов.

#### Рекомендации для логирования

+ Используйте подходящий уровень для каждой записи. Не пишите всё в INFO или ERROR.
+ Не включайте в логи конфиденциальную информацию (пароли, токены и т.д.).
+ Логи должны быть читаемыми и содержательными: включайте метки времени, уровни и контекст.
+ Настройте ротацию файлов логов (чтобы они не занимали много места).
+ Логируйте только то, что действительно нужно, чтобы не нагружать систему.

[К оглавлению](#IO)

# 34. Какие уровни логирования вы знаете?

+ TRACE: Самый детальный уровень.
  Используется для отслеживания потока выполнения программы.
+ DEBUG: Предназначен для отладки.
  Показывает техническую информацию, полезную для разработчиков.
+ INFO: Для информации о нормальном ходе выполнения программы.
  Например, "Сервер запущен на порту 8080".
+ WARN: Предупреждения о возможных проблемах.
  Например, "Низкий уровень памяти".
+ ERROR: Сообщения об ошибках, из-за которых программа может частично перестать работать.
  Например, "Не удалось подключиться к базе данных".
+ FATAL: Критические ошибки, приводящие к остановке приложения.

#### Связь уровней логирования и их использования

+ TRACE и DEBUG: Используются в процессе разработки и отладки. На продакшене обычно отключаются.
+ INFO, WARN, ERROR: Используются для мониторинга приложения в продакшене.
+ FATAL: Редко используется, но помогает фиксировать катастрофические сбои.

[К оглавлению](#IO)

# 35. Какая библиотека для логирования используется в курсе? Как ее настроить?

Log4j - библиотека позволяет осуществить логирование процессов в приложении.

Библиотека slf4j позволяет абстрагироваться от конкретных библиотек. Это позволяет придерживаться единого стиля
логгирования для проектов.

[К оглавлению](#IO)

# 36. Опишите из каких элементов состоит формат JSON

JSON (JavaScript Object Notation) — это легковесный формат обмена данными, который используется для представления
структурированных данных в текстовом виде. Он основан на синтаксисе объектов JavaScript, но является независимым от
языка и используется во многих современных приложениях и сервисах для обмена данными, например, в REST API.

#### Основные элементы формата JSON:

1. Объекты (Objects)
   Объект в JSON заключается в фигурные скобки {}.
   Он состоит из набора пар "ключ: значение".
   Ключ всегда является строкой (строчные символы в кавычках "key"), а значение может быть различного типа (строка,
   число, массив, другой объект и т.д.).
   Каждая пара "ключ: значение" разделяется запятой

```java
{
        "name":"Alice",
        "age":25,
        "city":"New York"
        }
```

2. Массивы (Arrays)
   Массив в JSON заключается в квадратные скобки [].
   Он содержит упорядоченный список значений, которые могут быть любого типа (строки, числа, объекты, массивы и т.д.).
   Элементы массива разделяются запятой

```java
["apple","banana","cherry"]
```

3. Строки (Strings)
   Строки в JSON заключаются в двойные кавычки ".
   Они могут содержать любые символы, включая пробелы, буквы и цифры, а также специальные символы (например, \n для
   новой строки).

```java
"Hello, world!"

```

4. Числа (Numbers)
   Числа в JSON могут быть целыми или с плавающей запятой (десятичными числами).
   Они не заключаются в кавычки.

```java
42
        3.1415
```

5. Булевы значения (Booleans)
   JSON поддерживает два булевых значения: true и false
6. `null`
   В JSON также существует специальное значение null, которое используется для представления отсутствующих или
   неопределённых данных

#### Структура JSON:

+ Объект может содержать другие объекты, массивы или примитивные значения.
+ Массив может содержать объекты, другие массивы, строки, числа и т.д.
+ Примитивы (строки, числа, булевы значения и null) могут быть значениями в объектах и массивах.

```java
{
        "name":"Alice",
        "age":25,
        "isStudent":false,
        "address":{
        "street":"123 Main St",
        "city":"New York",
        "zipCode":"10001"
        },
        "courses":["Math","Science","History"],
        "graduated":null
        }

Пример более
сложной структуры
JSON
"name","age","isStudent","graduated" —
        это ключи, а
их значения —строки,число,
булево значение
и null соответственно .
"address" —
это вложенный
объект с
другими ключами
и значениями.
        "courses" —
это массив
строк .
```

[К оглавлению](#IO)

# 37. Как преобразовать POJO в или из json?

Для преобразования POJO в JSON и наоборот можно использовать Jackson или Gson. Оба варианта широко распространены, и
выбор зависит от требований к производительности и функционалу проекта. Jackson часто используется в крупных и сложных
приложениях, а Gson — в простых и средних по объему проектах.

#### Использование Jackson

Jackson — это мощная библиотека для работы с JSON в Java. Она предоставляет простой способ преобразования объектов в
JSON и обратно.

1. Зависимости для Jackson
   Для использования Jackson в проекте, необходимо добавить зависимость в файл pom.xml (для Maven) или build.gradle (для
   Gradle).
2. Пример POJO-класса

```java
public class Person {
    private String name;
    private int age;

    // Конструкторы, геттеры и сеттеры
    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

3. Преобразование из POJO в JSON (Сериализация)

```java
import com.fasterxml.jackson.databind.ObjectMapper;

public class JacksonExample {
    public static void main(String[] args) {
        try {
            Person person = new Person("Alice", 30);

            // Создание объекта ObjectMapper
            ObjectMapper objectMapper = new ObjectMapper();

            // Преобразование объекта Person в JSON
            String json = objectMapper.writeValueAsString(person);
            System.out.println(json); // Выводит: {"name":"Alice","age":30}
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

4. Преобразование из JSON в POJO (Десериализация)

```java
import com.fasterxml.jackson.databind.ObjectMapper;

public class JacksonExample {
    public static void main(String[] args) {
        try {
            String json = "{\"name\":\"Alice\",\"age\":30}";

            // Создание объекта ObjectMapper
            ObjectMapper objectMapper = new ObjectMapper();

            // Преобразование JSON в объект Person
            Person person = objectMapper.readValue(json, Person.class);
            System.out.println(person.getName()); // Выводит: Alice
            System.out.println(person.getAge());  // Выводит: 30
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

#### Использование Gson

Gson — это библиотека от Google для работы с JSON. Она также позволяет легко преобразовывать объекты в JSON и наоборот.

1. Зависимости для Gson
2.
    2. Пример POJO-класса. Используем тот же класс Person для примера.
3. Преобразование из POJO в JSON (Сериализация)

```java
import com.google.gson.Gson;

public class GsonExample {
    public static void main(String[] args) {
        Person person = new Person("Bob", 25);

        // Создание объекта Gson
        Gson gson = new Gson();

        // Преобразование объекта Person в JSON
        String json = gson.toJson(person);
        System.out.println(json); // Выводит: {"name":"Bob","age":25}
    }
}
```

4. Преобразование из JSON в POJO (Десериализация)

```java
import com.google.gson.Gson;

public class GsonExample {
    public static void main(String[] args) {
        String json = "{\"name\":\"Bob\",\"age\":25}";

        // Создание объекта Gson
        Gson gson = new Gson();

        // Преобразование JSON в объект Person
        Person person = gson.fromJson(json, Person.class);
        System.out.println(person.getName()); // Выводит: Bob
        System.out.println(person.getAge());  // Выводит: 25
    }
}
```

#### Сравнение Jackson и Gson

+ Jackson: Быстрее, чем Gson, особенно при больших объёмах данных.
  Имеет более широкий функционал и гибкость (например, возможность работы с аннотациями и специфическими форматами).
  Поддерживает более сложные структуры (например, дерево JSON и потоковое чтение/запись).
+ Gson: Легковесная и простая в использовании.
  Может быть предпочтительнее для небольших проектов или случаев, когда не требуется высокая производительность.
  Очень хорошо интегрируется с Android-приложениями.

[К оглавлению](#IO)

# 38. Опишите из каких элементов состоит формат XML

XML (eXtensible Markup Language) — это язык разметки, предназначенный для хранения и передачи данных. В отличие от HTML,
XML не имеет фиксированных тегов; это расширяемый формат, что позволяет пользователю создавать собственные теги в
зависимости от потребностей.

#### Элементы формата XML

1. Объявление XML (XML Declaration) Это опциональная строка, которая указывает, что документ является XML, а также может
   содержать информацию о версии XML и кодировке.
   Обычно появляется в первой строке XML-документа.
2. Элементы (Elements) Основная структура XML-документа. Элементы заключены в теги.
   Элемент состоит из открывающего и закрывающего тега.
   Элемент может содержать атрибуты и текстовое содержимое, а также другие вложенные элементы.

```java
<person>
    <name>Alice</name>
    <age>30</age>
</person>

<person> —
открывающий тег.
</person> —
закрывающий тег.
Внутри элемента
<person> находятся другие
элементы — <name>и<age> .
```

3. Атрибуты (Attributes) Элементы могут иметь атрибуты, которые задаются в открывающем теге.
   Атрибуты состоят из имени и значения, разделённых знаком равенства.
   Атрибуты должны быть заключены в кавычки.

```java
<person name="Alice"age="30"/>

name="Alice" —
атрибут name
с значением
Alice.
        age="30" —
атрибут age
с значением 30.
```

4. Текстовое содержимое (Text Content) Элемент может содержать текст, который находится между его открывающим и
   закрывающим тегами.
   Это основной способ хранения данных в XML.

```java
<greeting>Hello,world!</greeting>

Hello,world! —
        текстовое содержимое, находящееся
внутри элемента <greeting>.
```

5. Комментарии (Comments) В XML можно добавлять комментарии, которые не влияют на обработку данных.
   Комментарии заключаются в <!-- и -->.

```java
<!--
Это комментарий -->
<person name="Alice"/>
```

6. Пространства имён (Namespaces) Пространства имён используются для предотвращения конфликтов имен в XML, когда
   используются одинаковые теги, но они могут означать разные вещи.
   Пространства имён задаются с помощью атрибута xmlns

```java
<book xmlns="http://example.com/book">
<title> XML Guide</title>
<author> John Doe</author>
</book>

xmlns="http://example.com/book"указывает,
что все
элементы внутри
<book>
        принадлежат пространству
имён http://example.com/book
```

7. CDData (CData) В XML можно использовать CDData для хранения данных, которые должны быть интерпретированы как текст и
   не обрабатываться как элементы XML.
   CData позволяет включать символы, такие как < и &, без необходимости экранирования.

```java
<description><![CDATA[
Some<text> that
should not
be parsed.]]></description>

Текст Some
<text> that should
not be
parsed.будет восприниматься
как обычный
текст,
а не
как XML-элементы .
```

8. Декларации сущностей (Entity Declarations)
   В XML можно объявлять сущности, которые будут использоваться в документе. Сущности могут быть встроенными (
   предоставляют простые символы, такие как &, <, >) или внешними (ссылаются на внешние файлы).

```java
<!
DOCTYPE greeting[
    <!
ENTITY greetingMessage "Hello, world!">
        ]>
<message>&greetingMessage;</message>

<!
ENTITY greetingMessage "Hello, world!">
объявляет сущность
с именем
greetingMessage .
&greetingMessage; —
это ссылка
на сущность.
```

```java
Пример XML-документа

<? xml version = "1.0"
encoding="UTF-8"?>
<person xmlns="http://example.com/person">
    <name>Alice</name>
    <age>30</age>
    <address>
<street> Main Street 123</street>
<city> New York</city>
    </address>
    <phone type="mobile">123-456-7890</phone>
</person>

<? xml version = "1.0"
encoding="UTF-8"?> —
декларация XML.
<person> —
        основной элемент, содержащий
имя и
возраст.
        Внутри элемента
<person> находятся другие
элементы,
такие как <name>, <age>, <address>, <phone>.
type="mobile" —
атрибут в
элементе<phone>.
        xmlns="http://example.com/person" —
пространство имён
для предотвращения
конфликтов .
```

[К оглавлению](#IO)

# 39. Как преобразовать POJO в или из xml?

Преобразование POJO (Plain Old Java Object) в XML и наоборот — это популярная задача, которая может быть решена с
использованием различных библиотек в Java. Одна из наиболее распространённых и удобных библиотек для работы с XML — это
JAXB (Java Architecture for XML Binding). Она позволяет легко сериализовать (преобразовывать) объекты в XML и
десериализовать (преобразовывать) XML в объекты.

1. Добавление зависимости JAXB. Для использования JAXB в вашем проекте, добавьте зависимость в файл pom.xml (для Maven)
   или build.gradle (для Gradle).
2. Пример POJO-класса

```java
Для начала создадим простой POJO-класс с аннотациями JAXB

import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

@XmlRootElement
public class Person {
    private String name;
    private int age;

    // Конструкторы, геттеры и сеттеры
    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @XmlElement
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @XmlElement
    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

@XmlRootElement указывает,
что класс
может быть
корневым элементом
XML-документа.
@XmlElement указывает,
        что методы, помеченные
        этой аннотацией, будут
сериализованы как
элементы XML.
```

3. Преобразование из POJO в XML (Сериализация)

```java
Чтобы преобразовать объект в XML,используем JAXBContext и Marshaller

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import java.io.StringWriter;

public class JAXBExample {
    public static void main(String[] args) {
        try {
            Person person = new Person("Alice", 30);

            // Создание контекста JAXB для класса Person
            JAXBContext context = JAXBContext.newInstance(Person.class);

            // Создание объекта Marshaller для преобразования в XML
            Marshaller marshaller = context.createMarshaller();

            // Преобразование в строку XML
            StringWriter writer = new StringWriter();
            marshaller.marshal(person, writer);
            String xml = writer.toString();

            // Выводим XML строку
            System.out.println(xml);
        } catch (JAXBException e) {
            e.printStackTrace();
        }
    }
}

Результат

<? xml version = "1.0"
encoding="UTF-8"standalone="yes"?>
<person>
    <name>Alice</name>
    <age>30</age>
</person>

Мы использовали JAXBContext.

newInstance(),чтобы создать контекст для сериализации.

Метод marshal() преобразует объект в XML.
Мы использовали
StringWriter для
записи результата
в строку.
```

4. Преобразование из XML в POJO (Десериализация)

```java
Для преобразования XML обратно в объект POJO используем Unmarshaller

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;
import java.io.StringReader;

public class JAXBExample {
    public static void main(String[] args) {
        try {
            String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>"
                    + "<person>"
                    + "<name>Alice</name>"
                    + "<age>30</age>"
                    + "</person>";

            // Создание контекста JAXB для класса Person
            JAXBContext context = JAXBContext.newInstance(Person.class);

            // Создание объекта Unmarshaller для преобразования XML в объект
            Unmarshaller unmarshaller = context.createUnmarshaller();

            // Преобразование XML в объект Person
            StringReader reader = new StringReader(xml);
            Person person = (Person) unmarshaller.unmarshal(reader);

            // Выводим результат
            System.out.println(person.getName());  // Выводит: Alice
            System.out.println(person.getAge());   // Выводит: 30
        } catch (JAXBException e) {
            e.printStackTrace();
        }
    }
}

Результат

        Alice
30

Мы использовали
Unmarshaller для

десериализации.
        Метод unmarshal() преобразует XML в объект POJO.
```

#### Преобразование с помощью Gson (альтернатива JAXB)

Также можно использовать библиотеку Gson для сериализации и десериализации XML, но для этого нужно дополнительно
настроить преобразование между XML и JSON. Однако JAXB — это более прямолинейный и стандартный способ работы с XML в
Java.

[К оглавлению](#IO)

# 40. Что такое сериализация, десериализация?

Сериализация — это процесс преобразования объекта в поток байтов, который можно передать через сеть, сохранить в файл
или передать между различными приложениями. Основная цель сериализации — сделать объект "плоским", то есть представить
его состояние (поля и их значения) в виде данных, которые можно легко сохранить или передать.

Пример сериализации:

+ Когда вы хотите передать объект через сокет.
+ Когда вам нужно сохранить объект в файл, чтобы потом восстановить его состояние.

```java
Чтобы объект можно было сериализовать,класс должен реализовывать интерфейс Serializable.

import java.io.*;

class Person implements Serializable {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Геттеры и сеттеры
}

public class SerializationExample {
    public static void main(String[] args) {
        try {
            Person person = new Person("Alice", 30);
            // Создание потока для записи в файл
            FileOutputStream fileOut = new FileOutputStream("person.ser");
            ObjectOutputStream out = new ObjectOutputStream(fileOut);

            // Сериализация объекта
            out.writeObject(person);

            // Закрытие потока
            out.close();
            fileOut.close();

            System.out.println("Object has been serialized");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

Метод writeObject() используется для сериализации объекта.
После сериализации
объект сохраняется
в файл
с расширением .
ser или
другом формате
для дальнейшего
использования .
```

Десериализация — это процесс восстановления объекта из его сериализованного состояния. Когда объект сериализуется, он
превращается в поток байтов, и десериализация позволяет восстановить оригинальное состояние объекта, прочитав эти байты.

Пример десериализации:

+ Когда вы получаете данные из базы данных или файла и хотите восстановить объект.
+ Когда нужно передать объект по сети и затем снова использовать его в другой части программы.

```java
import java.io.*;

class Person implements Serializable {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Геттеры и сеттеры
}

public class DeserializationExample {
    public static void main(String[] args) {
        try {
            // Создание потока для чтения из файла
            FileInputStream fileIn = new FileInputStream("person.ser");
            ObjectInputStream in = new ObjectInputStream(fileIn);

            // Десериализация объекта
            Person person = (Person) in.readObject();

            // Закрытие потока
            in.close();
            fileIn.close();

            // Выводим восстановленный объект
            System.out.println("Name: " + person.name);
            System.out.println("Age: " + person.age);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}

Метод readObject() используется для десериализации объекта.
После десериализации
объект восстанавливается
в том
виде,
в каком
он был
до сериализации.
```

#### Зачем это нужно?

+ Персистентность: Сериализация позволяет сохранить состояние объектов в файлах или базах данных и затем восстанавливать
  их, обеспечивая долговечность данных.
+ Передача данных: Сериализация позволяет передавать объекты через сеть (например, между клиентом и сервером),
  обеспечивая обмен данными в нужном формате.
+ Удалённые вызовы: В распределённых системах (например, через RMI в Java) объекты часто сериализуются для передачи по
  сети и их последующей десериализации на другом конце.
+ Кэширование: Сохранение состояния объектов для ускорения работы программы.

#### Примечания:

+ Serializable — интерфейс, который должен реализовать класс, чтобы его объекты могли быть сериализованы.
+ Transient — ключевое слово, которое позволяет исключить поля объекта из процесса сериализации. Если поле помечено как
  transient, оно не будет сериализовано.

[К оглавлению](#IO)

# 41. Что такое регулярные выражения? Зачем они нужны?

Регулярные выражения (regular expressions, или regex) — это мощный инструмент для работы с текстовыми строками. Они
позволяют искать, заменять или проверять строки на соответствие определённому шаблону. Регулярные выражения представляют
собой комбинацию символов и специальных конструкций, которые описывают текстовые шаблоны.

#### Зачем нужны регулярные выражения?

+ Поиск: Регулярные выражения позволяют искать строки, которые соответствуют заданному шаблону. Например, можно искать
  все номера телефонов, адреса электронной почты или другие данные в текстах.
+ Замена: С помощью регулярных выражений можно заменять части строк, которые соответствуют шаблону. Например, заменить
  все вхождения слова "текст" на "статья".
+ Валидация: Регулярные выражения позволяют проверять, соответствует ли строка определённому формату. Например, можно
  проверить, является ли строка валидным номером телефона или адресом электронной почты.
+ Извлечение данных: Регулярные выражения могут использоваться для извлечения части строки, которая соответствует
  шаблону, например, для парсинга текста.

В Java для работы с регулярными выражениями используется класс Pattern и его методы.

```java
Проверка,соответствует ли строка определённому шаблону(например,номеру телефона)

import java.util.regex.*;

public class RegexExample {
    public static void main(String[] args) {
        String phoneNumber = "+1-800-555-1234";

        // Регулярное выражение для поиска номера телефона
        String regex = "^\\+\\d{1,3}-\\d{3}-\\d{3}-\\d{4}$";

        // Создаём шаблон
        Pattern pattern = Pattern.compile(regex);

        // Проверяем, соответствует ли строка шаблону
        Matcher matcher = pattern.matcher(phoneNumber);
        if (matcher.matches()) {
            System.out.println("Номер телефона валиден.");
        } else {
            System.out.println("Номер телефона невалиден.");
        }
    }
}

^
и $ —
это границы

строки(начало и конец).
        \\+ —
экранированный символ "+".
        \\

d {
    1, 3
} —от 1до 3цифр .
\\

d {
    3
}-\\

d {
    3
}-\\

d {
    4
} —
формат номера
телефона с
тире .
```

```java
Замена всех вхождений слова"яблоко"на"груша"

import java.util.regex.*;

public class RegexExample {
    public static void main(String[] args) {
        String text = "Я люблю яблоки. Я купил яблоко вчера.";

        // Регулярное выражение для поиска слова "яблоко"
        String regex = "яблоко";

        // Заменяем все вхождения слова "яблоко" на "груша"
        String replacedText = text.replaceAll(regex, "груша");

        System.out.println(replacedText);  // "Я люблю груши. Я купил грушу вчера."
    }
}
```

```java
Извлечение всех email-адресов из текста

import java.util.regex.*;
import java.util.*;

public class RegexExample {
    public static void main(String[] args) {
        String text = "Пожалуйста, свяжитесь с нами по адресу support@example.com или admin@domain.com.";

        // Регулярное выражение для поиска email-адресов
        String regex = "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}";

        // Создаём шаблон
        Pattern pattern = Pattern.compile(regex);

        // Создаём матчеры для нахождения всех совпадений
        Matcher matcher = pattern.matcher(text);

        // Собираем все найденные email-адреса
        List<String> emails = new ArrayList<>();
        while (matcher.find()) {
            emails.add(matcher.group());
        }

        System.out.println("Найденные email-адреса: " + emails);
    }
}

Результат

Найденные email-адреса:[support@example.com,admin@domain.com]
```

#### Основные символы и конструкции регулярных выражений

+ `^` и `$` — начало и конец строки.
+ `\\d` — любая цифра (эквивалентно [0-9]).
+ `\\w` — любой символ (буква, цифра или подчёркивание).
+ `\\s` — пробельный символ.
+ `{n,m}` — от n до m повторений.
+ `[]` — класс символов (например, [a-z] означает любую строчную букву).
+ `|` — логическое ИЛИ (например, abc|def соответствует "abc" или "def").
+ `()` — группа (используется для объединения символов в подшаблоны или захвата данных).
+ `.` — любой символ (кроме символа новой строки).
+ `*` — 0 или более повторений предыдущего элемента.
+ `+` — 1 или более повторений предыдущего элемента.
+ `?` — 0 или 1 повторение предыдущего элемента.

#### Когда использовать регулярные выражения

Регулярные выражения особенно полезны, когда необходимо:

+ Найти или заменить текст в строках.
+ Проверить формат строки (например, email или телефон).
+ Извлечь части строки (например, парсинг данных).
+ Работать с логами или большими текстами, чтобы найти совпадения.

Однако стоит помнить, что регулярные выражения могут быть сложными для понимания и отладки, поэтому их следует
использовать с осторожностью и там, где они действительно необходимы.

[К оглавлению](#IO)

# 42. Как создать регулярное выражение в Java?

В Java для работы с регулярными выражениями используется класс Pattern из пакета java.util.regex. Регулярные выражения
создаются в виде строковых литералов, а затем компилируются с помощью метода Pattern.compile().

#### Основные шаги для создания регулярного выражения в Java

+ Создание строки с регулярным выражением.
+ Компиляция регулярного выражения в объект Pattern.
+ Использование объекта Matcher для поиска или замены в строках.

```java
Пример создания регулярного выражения в Java

import java.util.regex.*;

public class RegexExample {
    public static void main(String[] args) {
        // Шаблон для поиска email-адресов
        String regex = "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}";

        // Компиляция регулярного выражения в объект Pattern
        Pattern pattern = Pattern.compile(regex);

        // Пример строки для проверки
        String text = "Мой email: example@mail.com, а еще есть test@domain.org.";

        // Создание Matcher для поиска совпадений в строке
        Matcher matcher = pattern.matcher(text);

        // Поиск всех совпадений и вывод
        while (matcher.find()) {
            System.out.println("Найден email: " + matcher.group());
        }
    }
}

Pattern.

compile(regex) —
компилирует строку
с регулярным
выражением в
объект Pattern.
        matcher.

find() —
ищет первое
совпадение в строке.
        matcher.

group() —
возвращает совпавшую
часть строк
```

#### Основные методы класса Pattern

+ compile(String regex) — компилирует строку с регулярным выражением в объект Pattern.
+ compile(String regex, int flags) — компилирует регулярное выражение с флагами (например, игнорирование регистра).
+ matcher(CharSequence input) — создает объект Matcher для заданной строки.

#### Основные методы класса Matcher

+find() — ищет следующее совпадение в строке.

+ matches() — проверяет, соответствует ли вся строка шаблону.
+ group() — возвращает совпавшую часть строки.
+ replaceAll(String replacement) — заменяет все совпадения на строку replacement.

#### Пример использования с флагами

Можно использовать флаги, чтобы изменить поведение регулярного выражения

```java
игнорировать регистр

Pattern pattern = Pattern.compile("abc", Pattern.CASE_INSENSITIVE);

В этом
примере флаг
Pattern.CASE_INSENSITIVE делает
регулярное выражение
нечувствительным к

регистру(будет найдено и"abc", и "ABC").
```

[К оглавлению](#IO)

# 43. Что такое метасимволы? Для чего они применяются в регулярных выражениях

Метасимволы — это специальные символы в регулярных выражениях, которые имеют особое значение и не соответствуют обычным
символам, а выполняют особые функции для построения шаблонов. Они позволяют задать более сложные правила поиска и
манипуляции текстом.

#### Зачем используются метасимволы?

Метасимволы дают возможность:

+ Описывать шаблоны поиска: Они позволяют указать, какие символы могут быть в строках, например, цифры, буквы, пробелы и
  другие.
+ Управлять повторениями: Метасимволы могут использоваться для указания, сколько раз должен повторяться определённый
  элемент шаблона.
+ Группировка символов: Они позволяют группировать части выражений для последующего использования или ссылки на них.
+ Работа с позициями в строках: Метасимволы могут задавать поиск в начале, в конце строки или внутри строки.

#### Основные метасимволы и их применение

+ `^` — Начало строки Используется для указания, что поиск должен начинаться с начала строки.
  Пример: ^abc — соответствует строкам, начинающимся с "abc".
+ `$` — Конец строки Используется для указания, что поиск должен заканчиваться в конце строки.
  Пример: abc$ — соответствует строкам, заканчивающимся на "abc".
+ `.` — Любой символ (кроме новой строки) Представляет собой любой символ, кроме символа новой строки.
  Пример: a.c — соответствует строкам вроде "abc", "axc", но не "ac" (так как между "a" и "c" должен быть хотя бы один
  символ).
+ `[]` — Квадратные скобки (класс символов) Внутри скобок указываются символы, из которых может быть выбран один.
  Пример: [abc] — соответствует любому из символов "a", "b", или "c".
  Пример: [0-9] — соответствует любой цифре от 0 до 9.
+ `|` — ИЛИ (альтернатива) Позволяет указать альтернативы в шаблоне.
  Пример: abc|def — соответствует строкам, содержащим "abc" или "def".
+ `()` — Группировка (подмаски) Группирует части регулярного выражения для последующего использования или для применения
  к ним квантификаторов.
  Пример: (abc)+ — соответствует одному или нескольким вхождениям "abc".
+ `*` — Ноль или более повторений Соответствует нулю или более повторениям предыдущего символа или группы.
  Пример: a*b — соответствует "b", "ab", "aab", "aaab" и так далее.
+ `+` — Один или более повторений Соответствует одному или более повторениям предыдущего символа или группы.
  Пример: a+b — соответствует "ab", "aab", "aaab" и так далее, но не "b".
+ `?` — Ноль или одно повторение Соответствует нулю или одному повторению предыдущего символа или группы.
  Пример: a?b — соответствует "b" или "ab".
+ `{n,m}` — От n до m повторений Указывает на количество повторений, которое должно быть между n и m.
  Пример: a{2,4} — соответствует строкам "aa", "aaa" или "aaaa".
+ `\d` — Цифры Соответствует любой цифре, эквивалентно [0-9].
  Пример: \d+ — соответствует одному или более числовым символам.
+ `\w` — Буквы, цифры или подчеркивания Соответствует любому символу из набора "a-z", "A-Z", "0-9" или "_".
  Пример: \w+ — соответствует последовательности букв, цифр или подчеркиваний.
+ `\s` — Пробельные символы Соответствует любому пробельному символу, включая пробелы, табуляции и символы новой строки.
  Пример: \s+ — соответствует одному или более пробельным символам.
+ `\b` — Граница слова Соответствует границе слова (между буквой и не-буковым символом).
  Пример: \bword\b — соответствует только целому слову "word", а не "sword" или "wordy".
+ `\` — Экранирование Используется для экранирования метасимволов или для обозначения специальных символов.
  Пример: \\ — соответствует символу обратной косой черты.

```java
Использование метасимволов для проверки email-адреса

import java.util.regex.*;

public class RegexExample {
    public static void main(String[] args) {
        String emailRegex = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$";
        String email = "example@mail.com";

        Pattern pattern = Pattern.compile(emailRegex);
        Matcher matcher = pattern.matcher(email);

        if (matcher.matches()) {
            System.out.println("Это валидный email.");
        } else {
            System.out.println("Это невалидный email.");
        }
    }
}

^ —
начало строки.
        [a-zA-Z0-9._%+-]+ —
одна или
        более букв, цифр, точек, подчёркиваний, процентов
и других
символов .
@ —символ "@".
        [a-zA-Z0-9.-]+ —
одна или
        более букв, цифр, точек
или дефисов.
        \\. —

символ точки(необходимо экранировать).
        [a-zA-Z]{2,} —
две или

более букв(для домена верхнего уровня, например, ".com").
$ —
конец строки.
```

[К оглавлению](#IO)