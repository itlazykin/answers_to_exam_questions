# Mnogopotochka

[Чем процесс отличается от потока?](#чем-процесс-отличается-от-потока-)

[Что такое синхронизация? Какие способы синхронизации существуют в Java?](#что-такое-синхронизация-какие-способы-синхронизации-существуют-в-java)

[Проблемы многопоточности](#проблемы-многопоточности)

[Atomic vs Volatile](#atomic-vs-volatile)

[Какими способами можем запустить несколько потоков в Java приложении? Как запустить поток в Java](#какими-способами-можем-запустить-несколько-потоков-в-java-приложении-как-запустить-поток-в-java)

# Чем процесс отличается от потока? 

Процесс - это экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы

Поток - способ выполнения процесса, определяющий последовательность исполнения кода в процессе. Поток всегда создается в контексте какого-либо процесса

[К оглавлению](#Mnogopotochka)

# Что такое синхронизация? Какие способы синхронизации существуют в Java?

Синхронизация - процесс, позволяющий выполнять потоки параллельно. Способы синхронизации в Java:

+ Блок sychronized
```java
public class Counter {

    private int count;

    public synchronized void increment() { //Если много потоков инкрементируют поле у одного объекта
        count++;
    }
```
+ join() Поток вызвавший этот метод будет ждать до тех пор, пока объект, у которого был вызван этот метод - не закончит свое выполнение

```java
public static void main(String[] args) {
        SimpleThread simpleThread = new SimpleThread();
        simpleThread.start();
        try {
            simpleThread.join(); //До тех пор, пока этот поток не завершит свою работу - мы не пойдем дальше
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        System.out.println(Thread.currentThread().getName());
    }
```

Классы из пакета java.util.concurrent - Lock, Semaphore. Концепция данного подхода заключается в использовании атомарных операций и переменных. Semaphore позволяет задать какое кол-во потоков может получить доступ к ресурсу одновременно

[К оглавлению](#Mnogopotochka)

# Проблемы многопоточности

+ Deadlock. Это ситуация, когда два или более потока навсегда блокируются, ожидая ресурсы, которые уже захвачены другими потоками (Thread A ожидает Thread B, а Thread B ожидает Thread A)
+ Livelock. Несколько потоков попадают в зацикленность при попытке получения каких-либо ресурсов. При этом их состояние постоянно изменяется (Два человека постоянно пытаются уступить друг другу дорогу. Каждый раз когда один делает шаг в сторону, другой делает то же самое)
+ Состояние гонки. Это ситуация, при которой результат выполнения программы зависит от порядка выполнения потоков. Возникает, когда несколько потоков одновременно обращаются к разделяемым ресурсам, и результат работы зависит от того, какой поток первым выполнит операции

[К оглавлению](#Mnogopotochka)

# Atomic vs Volatile

### Зачем нужны atomic?

Классы из пакета java.util.concurrent.atomic (например, AtomicInteger, AtomicLong, AtomicReference) обеспечивают безопасные операции над переменными в многопоточной среде без явной синхронизации.

Они полезны для:
+ Операций над примитивами (инкремент, декремент, сравнение и замена) с гарантией атомарности.
+ Оптимизации производительности — вместо блокировок используется низкоуровневая атомарность через аппаратные команды процессора.

### Зачем нужны volatile?

Ключевое слово volatile гарантирует, что изменения переменной одним потоком будут немедленно видны другим потокам. Это предотвращает проблему с кешированием переменных в потоках.

+ Используется для переменных, которые:
  + могут быть изменены несколькими потоками;
  + читаются часто, но синхронизация сложных операций не требуется.

### Ограничения volatile:

Не обеспечивает атомарности операций (например, count++ всё равно небезопасно).
Используется для простых флагов или переменных, где достаточно гарантии чтения/записи.

[К оглавлению](#Mnogopotochka)

# Какими способами можем запустить несколько потоков в Java приложении? Как запустить поток в Java

+ Наследование от класса Thread
  Класс Thread уже реализует интерфейс Runnable. Мы можем наследоваться от него и переопределить метод run().

```java
public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("Thread is running");
    }

    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start(); // Запуск потока
    }
}
```

+ Реализация интерфейса Runnable. Создаётся класс, реализующий интерфейс Runnable. Затем объект этого класса передаётся в конструктор Thread.

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("Runnable is running");
    }

    public static void main(String[] args) {
        Thread thread = new Thread(new MyRunnable());
        thread.start(); // Запуск потока
    }
}
```

+ Использование анонимного класса или лямбда-выражения
```java
public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> System.out.println("Lambda thread is running"));
        thread.start(); // Запуск потока
    }
}
```

+ Использование интерфейса Callable. Callable возвращает результат и может выбрасывать исключения. Для выполнения требуется ExecutorService.

```java
public class CallableExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        Callable<String> task = () -> "Callable result";

        Future<String> future = executor.submit(task);
        System.out.println(future.get()); // Получение результата

        executor.shutdown();
    }
}
```

[К оглавлению](#Mnogopotochka)

# Что за интерфейсы Runnable и Callable? В чем между ними отличия

Runnable — это функциональный интерфейс, который представляет задачу, которая может быть выполнена в отдельном потоке.
Он имеет один метод run(), который не возвращает результат и не может выбрасывать проверяемые исключения.(Логирование, асинхронные операции)

Callable — это также функциональный интерфейс, но он представляет задачу, которая может возвращать результат и выбрасывать проверяемые исключения.
Он имеет один метод call(), который возвращает результат типа V (указанный при создании).(Вычисления, запросы к базе данных)

[К оглавлению](#Mnogopotochka)

