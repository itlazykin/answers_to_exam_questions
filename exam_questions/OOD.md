## OOD

[1. Что такое ООД? Какие задачи выполняет ООД?](#1-что-такое-оод-какие-задачи-выполняет-оод)

[2. Расскажите о принципах KISS, DRY, YAGNI?](#2расскажите-о-принципах-kiss-dry-yagni)

[3. Что такое SOLID?](#3-что-такое-solid)

[4. Для чего используется JavaDoc?](#4-для-чего-используется-javadoc)

[5. Как писать JavaDoc? Опишите основные теги @param, @return, @throws.](#5-как-писать-javadoc-опишите-основные-теги-param-return-throws)

[6. Расскажите про принципы составления Java класса.](#6-расскажите-про-принципы-составления-java-класса)

[7. Что такое SRP?](#7-что-такое-srp)

[8. Расскажите о нарушениях принципа SRP.](#8-расскажите-о-нарушениях-принципа-srp)

[9. Каковы последствия нарушения SRP?](#9-каковы-последствия-нарушения-srp)

[10. Что такое OCP?](#10-что-такое-ocp)

[11. Расскажите о нарушениях принципа OCP.](#11-расскажите-о-нарушениях-принципа-ocp)

[12. Каковы последствия нарушения OCP?](#12-каковы-последствия-нарушения-ocp)

[13. Что такое LSP?](#13-что-такое-lsp)

[14. Расскажите о нарушениях принципа LSP.](#14-расскажите-о-нарушениях-принципа-lsp)

[15. Каковы последствия нарушения LSP?](#15-каковы-последствия-нарушения-lsp)

[16. Что такое ISP?](#16-что-такое-isp)

[17. Расскажите о нарушениях принципа ISP.](#17-расскажите-о-нарушениях-принципа-isp)

[18. Каковы последствия нарушения ISP?](#18-каковы-последствия-нарушения-isp)

[19. Что такое DIP?](#19-что-такое-dip)

[20. Расскажите о нарушениях принципа DIP.](#20-расскажите-о-нарушениях-принципа-dip)

[21. Каковы последствия нарушения DIP?](#21-каковы-последствия-нарушения-dip)

[22. Расскажите, что такое автоматизированное тестирование.](#22-расскажите-что-такое-автоматизированное-тестирование)

[23. Как в Java осуществляется автоматизированное тестирование?](#23-как-в-java-осуществляется-автоматизированное-тестирование)

[24. Что такое JUnit? Как использовать ее для тестирования?](#24-что-такое-junit-как-использовать-ее-для-тестирования)

[25. Что такое функциональное тестирование и чем отличается оно от модульного?](#25-что-такое-функциональное-тестирование-и-чем-отличается-оно-от-модульного)

[26. Расскажите про методологию TDD.](#26-расскажите-про-методологию-tdd)

[27. Расскажите про методологию BDD.](#27-расскажите-про-методологию-bdd)

[28. Что такое тестирование черным, белым, серым ящиком?](#28-что-такое-тестирование-черным-белым-серым-ящиком)

[29. Опишите типы тестов: модульное, интеграционное, функциональное, приемочное?](#29-опишите-типы-тестов-модульное-интеграционное-функциональное-приемочное)

# 1. Что такое ООД? Какие задачи выполняет ООД?

Объектно-ориентированный дизайн (ООД) — это методика проектирования, точка, в которой во время работы над продуктом
сходятся все члены команды: дизайнеры, проектировщики, разработчики, SEO-специалисты и копирайтеры. В этом случае под
дизайном я понимаю не столько внешний вид системы, сколько то, как она работает.
Нарушение принципов ООД приводит к сильной связанности кода, и если понадобится расширять приложение, то при изменении
одной части кода придётся изменять и другие, которые с ней жестко связаны.

#### Задачи ООД:

+ Анализ предметной области:
    + Выявление ключевых сущностей (объектов) и их поведения в реальном мире.
    + Определение их взаимосвязей, например, ассоциаций, агрегации или наследования.
+ Проектирование классов:
    + Разработка классов, их полей (атрибутов) и методов (функциональности).
    + Определение структуры данных, инкапсулированной в объектах.
+ Определение взаимодействий между объектами:
    + Разработка методов связи и передачи данных между объектами.
    + Учет принципов проектирования, таких как низкая связанность и высокая связность.
+ Использование принципов SOLID:
    + Применение принципов для построения гибких, расширяемых и легко сопровождаемых систем.
+ Моделирование иерархий классов:
    + Создание иерархий наследования для повторного использования кода и реализации полиморфизма.
+ Подготовка к реализации кода:
    + Создание UML-диаграмм (классов, последовательностей, компонентов и т.д.) для визуализации системы.
    + Определение интерфейсов и контрактов для взаимодействия компонентов.

[К оглавлению](#OOD)

# 2.Расскажите о принципах KISS, DRY, YAGNI?

Это принципы проектирования приложений.

+ `KISS` - keep it simple and short. Код должен быть простым и коротким.

+ `DRY` - don't repeat yourself. Дословно "не повторяй себя". Противоположность этому принципу - copypaste. То есть,
  старайтесь использовать уже существующие методы, чтобы решить новую задачу. Не копируйте код.

+ `YAGNI` - You aren't gonna need it. Принцип пересекается со втором. Подумайте, стоит ли создавать новый метод. Можно
  ли решить задачу уже существующими методами.

[К оглавлению](#OOD)

# 3. Что такое SOLID?

SOLID — это набор из пяти принципов объектно-ориентированного проектирования, который помогает создавать гибкие,
поддерживаемые и легко расширяемые программы.

#### Пример:

Если вы разрабатываете игру, применяя SOLID, у вас могут быть такие классы, как Character, Enemy, Weapon, которые чётко
разделяют свои роли, расширяемы через наследование или интерфейсы, и связаны через абстракции. Это позволяет легко
добавлять новых врагов, оружие или функции, не переписывая старый код.
SOLID помогает строить код, который проще читать, понимать, расширять и поддерживать.

SRP - делай модули меньше.
OCP - делай модули расширяемыми.
LSP - наследуйся правильно.
ISP - дроби интерфейсы.
DIP - используй интерфейсы.

[К оглавлению](#OOD)

# 4. Для чего используется JavaDoc?

JavaDoc — это инструмент и стандарт документации для программ на языке Java. Он используется для создания удобной и
структурированной документации из комментариев в коде.

#### Основные задачи и преимущества JavaDoc:

+ Создание документации в формате HTML:
    + JavaDoc автоматически генерирует HTML-страницы из комментариев, что удобно для просмотра в браузере.
    + Это стандартный формат, который используют разработчики для изучения API или библиотек.
+ Улучшение читаемости кода:
    + Документирует, что делает класс, метод, конструктор, поле или интерфейс.
    + Помогает другим (и самому разработчику) быстро понять назначение и поведение кода.
+ Облегчение сопровождения и использования кода:
    + Когда библиотеку или API используют другие команды, JavaDoc упрощает понимание того, как ею пользоваться.
    + Предоставляет описание параметров, возвращаемых значений, исключений и особенностей реализации.
+ Автоматизация:
    + Не нужно вручную писать отдельный файл с документацией — достаточно добавлять комментарии в код.
    + Инструмент JavaDoc преобразует эти комментарии в полноценный сайт.

```java
/**
 * Класс представляет собой модель автомобиля.
 * Используется для описания транспортных средств в системе.
 */
public class Car {

    /**
     * Марка автомобиля.
     */
    private String brand;

    /**
     * Конструктор создает новый объект автомобиля.
     *
     * @param brand Марка автомобиля.
     */
    public Car(String brand) {
        this.brand = brand;
    }

    /**
     * Возвращает марку автомобиля.
     *
     * @return Марка автомобиля.
     */
    public String getBrand() {
        return brand;
    }
}
```

#### Основные теги JavaDoc:

+ `@param` — описание параметра метода.
+ `@return` — описание возвращаемого значения метода.
+ `@throws` или `@exception` — описание исключений, которые может выбросить метод.
+ `@see` — ссылка на другие классы, методы или файлы.
+ `@deprecated` — пометка, что элемент устарел и не рекомендуется к использованию.
+ `@since` — указывает, с какой версии появился элемент.
+ `@author` — имя автора класса или метода.
+ `@version` — версия класса.

[К оглавлению](#OOD)

# 5. Как писать JavaDoc? Опишите основные теги @param, @return, @throws.

+ Будьте краткими и точными. Не пишите слишком сложные описания.
+ Используйте понятный язык. Пишите так, чтобы документацию понял другой разработчик.
+ Документируйте всё, что может быть неочевидно. Если метод сложный, поясните, как его правильно использовать.
+ Поддерживайте актуальность документации. Если код изменился, обновите JavaDoc.

[К оглавлению](#OOD)

# 6. Расскажите про принципы составления Java класса.

Принципы составления Java-класса можно разделить на несколько ключевых аспектов, которые способствуют поддерживаемости,
читаемости и расширяемости кода.

1. Соблюдение принципа единственной ответственности (SRP). Каждый класс должен выполнять только одну задачу или
   представлять одну сущность в системе.

+ Это упрощает тестирование и поддержку.
+ Класс становится более предсказуемым и логически завершённым.

2. Инкапсуляция

+ Поля класса должны быть приватными, чтобы защищать данные от некорректного доступа.
+ Для доступа к полям используются геттеры и сеттеры, если это необходимо.

```   java
Пример:

   public class Person {
   private String name;

   public String getName() {
   return name;
   }

   public void setName(String name) {
   this.name = name;
   }
  }
```

3. Минимальная связанность

+ Классы не должны иметь жёстких зависимостей друг от друга.
+ Зависимости должны передаваться через конструктор или интерфейсы.

4. Ясная структура и читаемость

+ Класс начинается с объявления полей, затем идут конструкторы, а потом методы.
+ Придерживайтесь понятного именования классов, методов и переменных.

5. Принцип открытости/закрытости (OCP) Класс должен быть открыт для расширения, но закрыт для модификации.

+ Для добавления новой функциональности лучше использовать наследование или интерфейсы, вместо изменения существующего
  кода.

6. Разделение интерфейсов (ISP)

+ Если класс реализует интерфейс, убедитесь, что он не перегружен избыточными методами.

7. Соответствие принципу DRY

+ Не дублируйте код. Выделяйте повторяющиеся фрагменты в отдельные методы или классы

8. Применение интерфейсов

+ Если класс может иметь несколько реализаций, определите интерфейс и реализуйте его.

```   java
Пример хорошего класса:
   java
   Копировать код
   /**
* Класс описывает модель книги.
  */
  public class Book {
  private final String title;
  private final String author;

  public Book(String title, String author) {
  this.title = title;
  this.author = author;
  }

  public String getTitle() {
  return title;
  }

  public String getAuthor() {
  return author;
  }

  @Override
  public String toString() {
  return "Book{" +
  "title='" + title + '\'' +
  ", author='" + author + '\'' +
  '}';
  }
 }
```

[К оглавлению](#OOD)

# 7. Что такое SRP?

SRP (Single Responsibility Principle) — это принцип единственной ответственности, который является частью
SOLID-принципов. Он гласит, что каждый класс должен иметь только одну причину для изменения, то есть быть ответственным
только за одну задачу или аспект системы.

+ Ключевая идея: Класс должен делать что-то одно и делать это хорошо.
+ Это упрощает поддержку кода, тестирование и повторное использование классов.

[К оглавлению](#OOD)

# 8. Расскажите о нарушениях принципа SRP.

Принцип нарушается, когда класс выполняет несколько независимых задач, из-за чего изменения в одной задаче могут
повлиять на другие.

#### Примеры:

Класс с множеством обязанностей. Класс Report и формирует отчёт, и сохраняет его в базу данных, и отправляет по email.

```java
public class Report {
    public String generateReport() {
        // Генерация отчёта
        return "Отчёт";
    }

    public void saveToDatabase(String report) {
        // Сохранение в базу данных
    }

    public void sendByEmail(String report) {
        // Отправка отчёта по email
    }
}
```

+ Если формат отчёта меняется, нужно менять метод generateReport().
+ Если база данных обновляется, это затронет метод saveToDatabase().
+ Если логика отправки по email изменится, придётся модифицировать метод sendByEmail().

Решение: Разделить класс на три отдельных:

+ ReportGenerator — генерирует отчёт.
+ DatabaseSaver — отвечает за сохранение данных.
+ EmailSender — отправляет email.

Смешивание бизнес-логики и представления
Класс, который и обрабатывает данные, и отвечает за их отображение, нарушает SRP.

```java
public class Product {
    public void calculateDiscount() {
// Бизнес-логика расчёта скидки
    }

    public void renderProductCard() {
        // Код для отображения товара в HTML
    }

}
```

Решение:

+ Выделить бизнес-логику в отдельный класс, например, ProductService.
+ Создать класс, отвечающий за отображение, например, ProductRenderer.

[К оглавлению](#OOD)

# 9. Каковы последствия нарушения SRP?

+ Сложность изменений. Изменения в одной части класса могут повлиять на другие функции, что делает модификации
  рискованными.
+ Сложность тестирования. Тестирование класса с множеством обязанностей затруднено, так как тесты для одной
  функциональности могут ломаться из-за другой.
+ Плохая масштабируемость. Если задачи становятся сложнее, класс разрастается, превращаясь в "божественный объект" (God
  Object).
+ Такой класс сложно использовать в других частях системы, так как он несёт в себе избыточную функциональность.

```java
public class ReportGenerator {
    public String generateReport() {
        return "Отчёт";
    }
}

public class DatabaseSaver {
    public void save(String data) {
        // Сохранение в базу данных
    }
}

public class EmailSender {
    public void send(String data) {
        // Отправка по email
    }
}

// Использование
ReportGenerator generator = new ReportGenerator();
String report = generator.generateReport();

DatabaseSaver saver = new DatabaseSaver();
saver.save(report);

EmailSender sender = new EmailSender();
sender.send(report);

```

[К оглавлению](#OOD)

# 10. Что такое OCP?

OCP (Open/Closed Principle) — это принцип открытости/закрытости из SOLID-принципов. Он гласит, что: Код должен быть
открыт для расширения, но закрыт для модификации.
Это означает, что мы должны иметь возможность добавлять новую функциональность, не изменяя уже существующий код.

Пример:
Представьте себе пульт управления, где для добавления новой кнопки вы просто добавляете новую секцию, а не переделываете
старые кнопки.

Соблюдение принципа OCP позволяет:

+ Снизить вероятность багов.
+ Улучшить читаемость и тестируемость кода.
+ Упростить добавление новых функциональных возможностей.

`Запомните: новый функционал = добавление нового кода, а не изменение существующего.`

[К оглавлению](#OOD)

# 11. Расскажите о нарушениях принципа OCP.

Принцип нарушается, когда для добавления новой функциональности приходится изменять уже существующий код. Это делает
систему хрупкой и увеличивает вероятность ошибок.

Пример нарушения:
Класс, обрабатывающий различные виды уведомлений:

```java
public class NotificationService {
    public void sendNotification(String type, String message) {
        if ("EMAIL".equals(type)) {
            sendEmail(message);
        } else if ("SMS".equals(type)) {
            sendSms(message);
        } else if ("PUSH".equals(type)) {
            sendPush(message);
        }
    }

    private void sendEmail(String message) { /* логика отправки Email */ }

    private void sendSms(String message) { /* логика отправки SMS */ }

    private void sendPush(String message) { /* логика отправки Push */ }
}

```

#### Что здесь не так?

+ Для добавления нового типа уведомлений (например, WhatsApp) нужно изменять метод sendNotification.
+ Любое изменение может сломать существующую логику.

```java
Как исправить? Используйте полиморфизм или паттерн Стратегия,
чтобы избежать изменений существующего кода.

// Шаг 1: Создайте интерфейс
public interface Notification {
    void send(String message);
}

// Шаг 2: Реализуйте его для каждого типа уведомлений
public class EmailNotification implements Notification {
    @Override
    public void send(String message) {
        // Логика отправки Email
    }
}

public class SmsNotification implements Notification {
    @Override
    public void send(String message) {
        // Логика отправки SMS
    }
}

// Шаг 3: Используйте полиморфизм
public class NotificationService {
    private final Notification notification;

    public NotificationService(Notification notification) {
        this.notification = notification;
    }

    public void sendNotification(String message) {
        notification.send(message);
    }
}

// Использование
Notification email = new EmailNotification();
NotificationService service = new NotificationService(email);
service.sendNotification("Привет!");

Теперь, если нужно добавить новый тип уведомлений(например, WhatsApp),
достаточно создать новый класс WhatsAppNotification, не трогая
уже существующий код .
```

[К оглавлению](#OOD)

# 12. Каковы последствия нарушения OCP?

+ Хрупкость системы. Каждое изменение может привести к неожиданным ошибкам в уже работающем функционале.
+ Сложность поддержки. Чем больше вариантов приходится добавлять, тем запутаннее становится код.
+ Нарушение принципа DRY (Don’t Repeat Yourself). Повторяющийся код для обработки каждого нового типа функциональности.
+ Проблемы с масштабированием. Добавление новой логики становится трудоёмким и рискованным.

[К оглавлению](#OOD)

# 13. Что такое LSP?

LSP (Liskov Substitution Principle) — принцип подстановки Барбары Лисков. Он гласит, что: Объекты дочерних классов
должны быть взаимозаменяемыми с объектами родительского класса без нарушения корректности программы.

Проще говоря:
Класс-наследник должен сохранять поведение родительского класса. Использование подкласса вместо базового класса не
должно ломать систему.

#### Чтобы соблюдать LSP:

+ Подкласс должен сохранять контракт родительского класса.
+ Наследование должно использоваться только для объектов, которые полностью соответствуют поведению базового класса.
+ Если наследование нарушает поведение, рассмотрите использование композиции вместо наследования.

[К оглавлению](#OOD)

# 14. Расскажите о нарушениях принципа LSP.

Принцип нарушается, если дочерний класс:

+ Изменяет поведение базового класса так, что ломает его контракт.
+ Добавляет ограничения, которые отсутствуют в родительском классе.
+ Нарушает логическое или ожидаемое поведение.

```java
Представим, что у нас есть класс Bird и его
дочерний класс Penguin:

public class Bird {
    public void fly() {
        System.out.println("Я лечу!");
    }
}

public class Penguin extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("Пингвины не умеют летать");
    }
}

```

#### Что здесь не так?

+ Родительский класс Bird предполагает, что все птицы могут летать.
+ Класс-наследник Penguin ломает это предположение, выбрасывая исключение.

#### Исправление

Следует избегать наследования, если дочерний класс не соответствует поведению родительского. Лучше использовать
композицию или изменить абстракцию.

```java
public abstract class Bird {
    public abstract void move();
}

public class FlyingBird extends Bird {
    @Override
    public void move() {
        System.out.println("Я лечу!");
    }
}

public class Penguin extends Bird {
    @Override
    public void move() {
        System.out.println("Я бегу и плаваю!");
    }
}

Теперь каждый подкласс определяет свое поведение, и
принцип LSP не нарушается.
```

[К оглавлению](#OOD)

# 15. Каковы последствия нарушения LSP?

+ Непредсказуемое поведение. Код, работающий с базовым классом, может неожиданно ломаться при использовании наследников.
+ Сложность тестирования. Если поведение дочернего класса отличается от родительского, нужно писать дополнительные тесты
  для проверки.
+ Сложно масштабировать. Нарушение LSP затрудняет добавление новых классов и поддержку кода.
+ Нарушение полиморфизма. Использование базового класса через интерфейс становится невозможным.

[К оглавлению](#OOD)

# 16. Что такое ISP?

ISP (Interface Segregation Principle) — это принцип разделения интерфейсов из SOLID-принципов. Он гласит: Клиенты не
должны зависеть от интерфейсов, которые они не используют.

Проще говоря:
Интерфейсы должны быть узкоспециализированными. Не нужно заставлять класс реализовывать методы, которые ему не нужны.

#### Чтобы соблюдать ISP:

+ Разделяйте интерфейсы на узкие, логически обособленные.
+ Старайтесь, чтобы каждый интерфейс выполнял одну задачу.
+ Избегайте создания универсальных интерфейсов, пытаясь «учесть всё».

[К оглавлению](#OOD)

# 17. Расскажите о нарушениях принципа ISP.

Принцип нарушается, если интерфейс становится слишком большим и заставляет классы реализовывать методы, которые не имеют
смысла в их контексте.

```java
Пример нарушения:

public interface Animal {
    void eat();

    void fly();

    void swim();
}

Если мы создадим класс Dog, он будет
вынужден реализовать метод fly, который
собакам не нужен .

public class Dog implements Animal {
    @Override
    public void eat() {
        System.out.println("Собака ест");
    }

    @Override
    public void fly() {
        throw new UnsupportedOperationException("Собаки не летают");
    }

    @Override
    public void swim() {
        System.out.println("Собака плавает");
    }
}

```

#### Что здесь не так?

+ Метод fly не имеет смысла для собаки, но его реализация обязательна из-за общего интерфейса.
+ Это создаёт избыточный и непонятный код.

#### Исправление

Разделим интерфейс на несколько узкоспециализированных интерфейсов:

```java
public interface Eatable {
    void eat();
}

public interface Flyable {
    void fly();
}

public interface Swimmable {
    void swim();
}
```

```java
Теперь каждый класс реализует только те
интерфейсы, которые ему подходят:

public class Dog implements Eatable, Swimmable {
    @Override
    public void eat() {
        System.out.println("Собака ест");
    }

    @Override
    public void swim() {
        System.out.println("Собака плавает");
    }
}

public class Bird implements Eatable, Flyable {
    @Override
    public void eat() {
        System.out.println("Птица ест");
    }

    @Override
    public void fly() {
        System.out.println("Птица летает");
    }
}

Интерфейсы используются по назначению, и классы больше
не перегружены ненужными методами.
```

[К оглавлению](#OOD)

# 18. Каковы последствия нарушения ISP?

+ Сложность поддержки кода. Классы становятся громоздкими из-за необходимости реализовать лишние методы.
+ Логика становится запутанной из-за ненужных исключений или заглушек.
+ Трудности с расширением. При добавлении новых методов в большой интерфейс все классы, его реализующие, будут вынуждены
  измениться.
+ Нарушение принципа SRP. Интерфейсы становятся многофункциональными, что противоречит принципу единственной
  ответственности.
+ Такой код сложно читать. Разработчики тратят время на понимание ненужных методов.

[К оглавлению](#OOD)

# 19. Что такое DIP?

DIP (Dependency Inversion Principle) — это принцип инверсии зависимостей из SOLID-принципов. Он гласит: Модули высокого
уровня не должны зависеть от модулей низкого уровня. Оба типа модулей должны зависеть от абстракций.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Проще говоря:
Вместо жёсткой зависимости на конкретные реализации (детали), код должен работать через абстракции (интерфейсы или
абстрактные классы).

#### Чтобы соблюдать DIP:

+ Используйте интерфейсы или абстрактные классы для определения контракта взаимодействия между модулями.
+ Не связывайте модули напрямую — используйте внедрение зависимостей (Dependency Injection).
+ Старайтесь, чтобы модули высокого уровня определяли поведение через абстракции, а детали реализации соответствовали
  этим абстракциям.

[К оглавлению](#OOD)

# 20. Расскажите о нарушениях принципа DIP.

Принцип нарушается, если:

+ Модуль высокого уровня напрямую зависит от деталей реализации модуля низкого уровня.
+ Логика становится жёстко привязанной к конкретным реализациям, что затрудняет её изменение или расширение.

```java
Представьте, что у нас есть приложение для
отправки уведомлений:

public class EmailNotification {
    public void send(String message) {
        System.out.println("Отправлено Email: " + message);
    }
}

public class NotificationService {
    private final EmailNotification emailNotification;

    public NotificationService() {
        this.emailNotification = new EmailNotification();
    }

    public void notify(String message) {
        emailNotification.send(message);
    }
}
```

#### Что здесь не так?

+ NotificationService напрямую зависит от конкретного класса EmailNotification.
+ Если нужно добавить, например, SMS или Push-уведомления, придётся переписать NotificationService.

#### Исправление

```java
Используйте абстракции для инверсии зависимости:

public interface Notification {
    void send(String message);
}

public class EmailNotification implements Notification {
    @Override
    public void send(String message) {
        System.out.println("Отправлено Email: " + message);
    }
}

public class SmsNotification implements Notification {
    @Override
    public void send(String message) {
        System.out.println("Отправлено SMS: " + message);
    }
}

public class NotificationService {
    private final Notification notification;

    public NotificationService(Notification notification) {
        this.notification = notification;
    }

    public void notify(String message) {
        notification.send(message);
    }
}

Теперь, чтобы использовать новый тип уведомлений,
достаточно передать соответствующую реализацию интерфейса:

Notification email = new EmailNotification();
NotificationService service = new NotificationService(email);
service.notify("Привет!");

Notification sms = new SmsNotification();
NotificationService smsService = new NotificationService(sms);
smsService.notify("Привет!");
```

#### Преимущества:

+ Модуль высокого уровня (NotificationService) зависит от абстракции (Notification), а не от деталей.
+ Расширение функциональности (добавление новых уведомлений) больше не требует изменения существующего кода.

[К оглавлению](#OOD)

# 21. Каковы последствия нарушения DIP?

+ Сложно тестировать. Жёсткая зависимость от конкретных классов затрудняет написание тестов.
+ Невозможно подставить "заглушки" (mocks) для модулей низкого уровня.
+ Сложно масштабировать. Изменение или добавление нового функционала требует переписывания кода в модулях высокого
  уровня.
+ Сложно повторно использовать. Модули высокого уровня становятся зависимыми от деталей реализации, что ограничивает их
  повторное использование.
+ Нарушение принципа OCP. Жёсткая связь между модулями делает систему менее гибкой к изменениям.

[К оглавлению](#OOD)

# 22. Расскажите, что такое автоматизированное тестирование.

Автоматизированное тестирование — это процесс проверки программного обеспечения с использованием специальных
инструментов и скриптов вместо ручного выполнения тестов. Цель автоматизации — повысить эффективность и точность
тестирования, сократить время и исключить человеческий фактор в повторяющихся задачах.

#### Преимущества автоматизированного тестирования

+ Скорость. Тесты выполняются быстрее, чем при ручной проверке, особенно если нужно тестировать однотипные сценарии.
+ Повторяемость. Тесты можно запускать многократно без изменений.
+ Точность. Исключаются ошибки, вызванные человеческим фактором.
+ Экономия ресурсов. Уменьшается объём работы тестировщиков при регрессионных тестах.
+ Масштабируемость. Тесты легко адаптировать для новых версий программного обеспечения.

#### Недостатки автоматизированного тестирования

+ Начальные затраты. Требуется время и ресурсы для разработки тестов и настройки инфраструктуры.
+ Поддержка тестов. Автоматизированные тесты нужно обновлять при изменениях в системе.
+ Ограничения. Некоторые виды тестов, например исследовательское тестирование, лучше проводить вручную.

#### Когда использовать автоматизированное тестирование?

+ Регулярные регрессионные проверки.
+ Масштабные проекты с большим объёмом повторяющихся задач.
+ Критически важные системы, где ошибки могут быть недопустимы.
+ API или веб-приложения, где важна скорость отклика и правильность обработки запросов.

[К оглавлению](#OOD)

# 23. Как в Java осуществляется автоматизированное тестирование?

Автоматизированное тестирование в Java осуществляется с помощью тестовых фреймворков и библиотек, которые упрощают
написание, выполнение и проверку тестов. Ниже представлен общий процесс и примеры инструментов, используемых для
автоматизированного тестирования.

#### Процесс автоматизированного тестирования в Java

+ Настройка среды тестирования. Выбор тестового фреймворка (например, JUnit, TestNG). Подключение фреймворка к проекту (
  обычно через Maven или Gradle).
+ Написание тестов. Создаются отдельные классы тестов, где каждая тестовая функция проверяет определённый аспект работы
  программы. Тесты оформляются с помощью аннотаций, таких как @Test в JUnit.
+ Запуск тестов. Тесты запускаются вручную из IDE или автоматически через системы CI/CD (например, Jenkins).
+ Анализ результатов. После выполнения тестов предоставляется отчёт с результатами (успешные и неудачные тесты).
+ Отладка и доработка. Исправление багов, если тесты выявили несоответствия.

#### Инструменты для автоматизированного тестирования

+ JUnit. Основной фреймворк для модульного тестирования в Java. Подходит для написания простых тестов.
+ TestNG. Расширенный фреймворк для тестирования. Позволяет выполнять параллельные тесты, настраивать зависимости между
  тестами.
+ Mockito. Библиотека для создания mock-объектов (заглушек). Используется для тестирования компонентов,
  взаимодействующих с внешними системами (например, базами данных).
+ AssertJ. Библиотека для улучшенной проверки (assertion) результатов. Предоставляет читаемые и удобные API для тестов.
+ Selenium. Используется для автоматизации тестирования веб-интерфейсов.
+ Cucumber. Позволяет писать тесты в формате BDD (Behavior Driven Development).

#### Преимущества автоматизированного тестирования в Java

+ Интеграция с CI/CD. Тесты можно запускать автоматически после каждого изменения в коде.
+ Широкий выбор инструментов. Java обладает богатым набором фреймворков и библиотек для тестирования.
+ Гибкость. Можно тестировать как простую бизнес-логику, так и сложные интеграции.

[К оглавлению](#OOD)

# 24. Что такое JUnit? Как использовать ее для тестирования?

JUnit — это популярный фреймворк для модульного тестирования в Java.
Он позволяет проверять работоспособность отдельных частей программы (методов или классов) с помощью автоматизированных
тестов. С его помощью легко проверять отдельные методы и классы, а также интегрировать тестирование в процесс
разработки. Он помогает автоматизировать проверки, что значительно повышает качество и надёжность программного
обеспечения.

+ Открытый и бесплатный: активно используется разработчиками для написания тестов.
+ Поддерживаемым в экосистеме Java: интегрируется с инструментами сборки (Maven, Gradle) и CI/CD (Jenkins, GitHub
  Actions).
+ Используется в комбинации с другими библиотеками, такими как Mockito или AssertJ.

#### Преимущества JUnit

+ Упрощение тестирования. Тесты становятся простыми, лаконичными и читаемыми.
+ Автоматизация. Тесты можно запускать вручную или интегрировать с CI/CD для автоматического выполнения.
+ Отчёты и контроль качества. Лёгкий доступ к результатам тестирования.
+ Поддержка аннотаций. Простые аннотации (@Test, @BeforeEach, @AfterEach) помогают структурировать тесты.

#### Основные шаги для использования JUnit

1. Подключение JUnit
   Для использования JUnit в проекте нужно добавить его зависимость.
   Если вы используете Maven, добавьте в pom.xml:

```
xml

<dependency>
<groupId>org.junit.jupiter</groupId>
<artifactId>junit-jupiter</artifactId>
<version>5.10.0</version>
<scope>test</scope>
</dependency>

Для Gradle:

testImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
```

2. Написание теста.
   Допустим, у нас есть простой класс Calculator с методом сложения:

```java
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
}

Тестируем этот метод с помощью JUnit:

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class CalculatorTest {

    @Test
    public void testAdd() {
        Calculator calculator = new Calculator();
        int result = calculator.add(2, 3);
        assertEquals(5, result, "Сложение должно возвращать сумму аргументов");
    }
}
```

#### Основные аннотации JUnit

+ `@Test` Помечает метод как тестовый.
+ `@BeforeEach` Выполняется перед каждым тестом, используется для подготовки данных.
+ `@AfterEach` Выполняется после каждого теста, полезно для очистки данных.
+ `@BeforeAll` Выполняется один раз перед всеми тестами, используется для настройки общего состояния.
+ `@AfterAll` Выполняется один раз после всех тестов.
+ `@Disabled` Помечает тест, который временно не должен выполняться.

```java
Пример с дополнительными аннотациями:

import org.junit.jupiter.api.*;

public class ExampleTest {

    @BeforeAll
    static void initAll() {
        System.out.println("Настройка перед всеми тестами");
    }

    @BeforeEach
    void init() {
        System.out.println("Настройка перед каждым тестом");
    }

    @Test
    void testOne() {
        System.out.println("Выполнение теста 1");
        Assertions.assertTrue(true);
    }

    @Test
    void testTwo() {
        System.out.println("Выполнение теста 2");
        Assertions.assertEquals(4, 2 + 2);
    }

    @AfterEach
    void tearDown() {
        System.out.println("Очистка после каждого теста");
    }

    @AfterAll
    static void tearDownAll() {
        System.out.println("Очистка после всех тестов");
    }
}
```

#### Запуск тестов

+ Из IDE (например, IntelliJ IDEA или Eclipse). Кликните правой кнопкой мыши по классу или тестовому методу и выберите "
  Run".
+ Через инструмент сборки (Maven или Gradle)
    + Для Maven: mvn test.
    + Для Gradle: gradle test.
+ Интеграция с CI/CD. Добавьте выполнение тестов в ваш pipeline (например, Jenkins, GitHub Actions).

[К оглавлению](#OOD)

# 25. Что такое функциональное тестирование и чем отличается оно от модульного?

+ Функциональное тестирование оценивает работу системы как целого, проверяя её с точки зрения пользователя и
  бизнес-требований.
+ Модульное тестирование проверяет работу отдельных частей программы, ориентируясь на внутреннюю логику и корректность
  реализации.

| Критерий              | Функциональное тестирование	                     | Модульное тестирование                                       |
|-----------------------|--------------------------------------------------|--------------------------------------------------------------|
| Цель                  | Проверить, соответствует ли система требованиям. | Проверить правильность работы отдельных методов или классов. |
| Уровень тестирования	 | Уровень системы или её компонентов.	             | Уровень отдельных модулей (методов, классов).                |
| Подход                | Проверка внешнего поведения.                     | Проверка внутренней логики                                   |
| Ориентированность     | Ориентировано на пользователя.	                  | Ориентировано на разработчиков                               |
| Инструменты           | Selenium, Cucumber, Postman и др.                | JUnit, TestNG, Mockito и др                                  |
| Зависимости           | Проверяется взаимодействие модулей.              | Модули тестируются изолированно.                             |
| Типы проверок         | Функциональность, соответствие требованиям.      | Логика работы, корректность алгоритмов                       |

Эти подходы дополняют друг друга: модульное тестирование помогает выявить проблемы на ранних этапах разработки, а
функциональное гарантирует, что конечный продукт соответствует ожиданиям.

[К оглавлению](#OOD)

# 26. Расскажите про методологию TDD.

TDD (Test-Driven Development) — это методология разработки программного обеспечения, при которой процесс начинается с
написания тестов, а затем создаётся код, который эти тесты проходит.

Ключевой принцип TDD — разработка ориентирована на тесты. Основной цикл TDD описывается формулой "Red-Green-Refactor":

+ Red: Написать тест, который изначально не проходит (ошибка, красный статус).
+ Green: Написать минимальный код, чтобы тест начал проходить (зелёный статус).
+ Refactor: Улучшить код, сохраняя успешное выполнение теста.

#### Преимущества TDD

+ Высокое качество кода. Код соответствует требованиям с самого начала.
+ Снижение ошибок. Ошибки выявляются на ранних стадиях разработки.
+ Уверенность в изменениях. При внесении изменений можно быть уверенным, что тесты гарантируют сохранение
  работоспособности.
+ Чистый и понятный дизайн. TDD стимулирует написание модульного, легко тестируемого кода.
+ Документация в виде тестов. Тесты показывают, как должна работать каждая часть программы.

#### Недостатки TDD

+ Время на написание тестов. На начальном этапе тесты требуют значительных временных затрат.
+ Сложность обучения. Новичкам сложно сразу привыкнуть писать тесты перед кодом.
+ Подходит не для всех задач. Например, сложные алгоритмы или прототипы могут быть трудно реализуемы через TDD.

[К оглавлению](#OOD)

# 27. Расскажите про методологию BDD.

BDD (Behavior-Driven Development) — это методология разработки программного обеспечения, которая фокусируется на
поведении системы с точки зрения её пользователей и бизнеса. BDD ориентирован на совместное взаимодействие между
разработчиками, тестировщиками и заказчиками, чтобы обеспечить более ясное и точное понимание того, как должна работать
система. В отличие от TDD (где фокус на тестах и их написании перед кодом), в BDD внимание уделяется поведению системы в
терминах, понятных всем участникам процесса разработки.

#### Основные особенности BDD:

+ Язык и описание сценариев. В BDD используется спецификация на естественном языке, который легко понять и заказчику, и
  разработчику. Это помогает всем участникам проекта четко понимать, как система должна вести себя в различных
  ситуациях.
+ Сценарии как спецификация. Основой BDD являются сценарии, которые описывают поведение системы в терминах "
  Given-When-Then" (Gherkin). Это позволяет составить подробное описание функциональности системы:
    + Given: Исходное состояние (условия для теста).
    + When: Действие или событие (что происходит).
    + Then: Ожидаемый результат (что должно произойти).
+ Совместная работа всех участников. BDD активно вовлекает в процесс разработки не только разработчиков, но и
  заказчиков, аналитиков и тестировщиков. Каждый участник может внести свой вклад в описание требований и сценариев.
+ Инструменты для автоматизации. BDD включает использование инструментов, которые позволяют автоматизировать тесты на
  основе сценариев, написанных на естественном языке. Пример таких инструментов — Cucumber, SpecFlow (для .NET), Behat (
  для PHP) и другие.

#### Шаги в методологии BDD:

+ Определение требований. Вместо того чтобы сразу писать код, команда разрабатывает сценарии на основе
  бизнес-требований, которые описывают, как система должна вести себя в различных ситуациях. Эти сценарии можно
  использовать как спецификации.
+ Написание тестов с использованием естественного языка. Тесты пишутся в терминах "Given-When-Then", что позволяет
  понять требования и поведение системы.
+ Реализация функционала. На основе сценариев команда пишет код, который должен выполнить описанные шаги. Код
  проверяется с помощью автоматизированных тестов.
+ Автоматизация тестов. Бизнес-спецификации (сценарии) автоматически проверяются инструментами тестирования (например,
  Cucumber), чтобы убедиться, что система соответствует ожидаемому поведению.

#### Преимущества BDD:

+ Ясность и доступность требований. Сценарии на естественном языке легко понять всем участникам проекта, что снижает
  риск недопонимания и ошибок.
+ Лучшее взаимодействие между участниками проекта. BDD способствует тесному сотрудничеству между разработчиками,
  тестировщиками и заказчиками, что помогает уточнить требования до начала разработки.
+ Документация в виде тестов. Сценарии становятся не только тестами, но и документацией, что упрощает понимание
  функциональности системы для всех участников.
+ Автоматизация тестирования. Тесты, написанные в формате BDD, можно легко автоматизировать, что ускоряет процесс
  тестирования и помогает поддерживать высокое качество кода.

#### Недостатки BDD:

+ Сложности в написании сценариев для сложных бизнес-логик. Сценарии могут быть не такими простыми для сложных, высоко
  абстрактных бизнес-логик.
+ Требования к навыкам команды. Важно, чтобы команда имела понимание методологии BDD и опыта в написании сценариев. Это
  требует дополнительных усилий на этапе обучения.
+ Избыточность. В некоторых случаях, особенно если проект небольшой, методология BDD может быть излишней и привести к
  дополнительным затратам времени на написание и поддержание сценариев.

```
Пример сценария с использованием инструмента Cucumber (Java):

import io.cucumber.java.en.Given;
import io.cucumber.java.en.When;
import io.cucumber.java.en.Then;
import static org.junit.Assert.*;

public class LoginSteps {

private boolean isLoggedIn;

@Given("пользователь находится на странице входа")
public void givenUserIsOnLoginPage() {
// Инициализация состояния
isLoggedIn = false;
}

@When("пользователь вводит корректный логин и пароль")
public void whenUserEntersValidCredentials() {
// Реализация логики входа
isLoggedIn = true; // Допустим, вход успешен
}

@Then("пользователь должен попасть на главную страницу")
public void thenUserShouldBeRedirectedToHomePage() {
assertTrue(isLoggedIn);
 }
}

с помощью Cucumber, описан сценарий, который можно выполнить для проверки функциональности входа на сайт.
```

[К оглавлению](#OOD)

# 28. Что такое тестирование черным, белым, серым ящиком?

#### Тестирование чёрным ящиком (Black Box Testing)

Метод тестирования, при котором тестировщик не имеет доступа к внутреннему коду или архитектуре системы. Проверяются
только входные данные и выходные результаты, независимо от того, как они обрабатываются внутри.

Применение:

+ Подходит для проверки функциональности системы.
+ Используется для тестирования на уровне пользовательского интерфейса (UI), API и интеграции.
+ Выполняется тестировщиками, которые фокусируются на том, что система делает, а не как.

Преимущества:

+ Не требует знания языка программирования или внутренней структуры системы.
+ Упрощает тестирование с точки зрения конечного пользователя.
+ Эффективно для проверки соответствия системы требованиям.

Недостатки:

+ Не покрывает внутреннюю структуру кода, что может привести к пропуску ошибок.
+ Трудно определить, какие части кода остаются нетестированными.

Пример:
Тестировщик проверяет, что функция калькулятора правильно складывает два числа. Он вводит 2 + 2 и проверяет, что
результат равен 4, без анализа того, как код вычисляет сумму.

#### Тестирование белым ящиком (White Box Testing)

Метод тестирования, при котором тестировщик имеет доступ к исходному коду и внутренней логике системы. Фокусируется на
том, как система работает внутри.

Применение:

+ Подходит для проверки структуры кода, логики алгоритмов и выполнения ветвей (branch testing).
+ Используется для модульного тестирования, проверки безопасности и покрытия кода.
+ Выполняется разработчиками или техническими специалистами, знакомыми с внутренним устройством системы.

Преимущества:

+ Обеспечивает полное покрытие кода.
+ Помогает выявлять скрытые ошибки в логике и структуре.
+ Позволяет оптимизировать код.

Недостатки:

+ Требует знания кода и навыков программирования.
+ Сложно масштабировать для больших систем.

Пример:
Разработчик анализирует цикл for в методе сортировки массива и проверяет, что все элементы массива правильно
сравниваются и перемещаются на нужные места.

#### Тестирование серым ящиком (Gray Box Testing)

Комбинация подходов "чёрного" и "белого ящика". Тестировщик имеет ограниченный доступ к внутренней структуре системы (
например, документации или архитектурным схемам), но тестирует её как конечный пользователь.

Применение:

+ Подходит для интеграционного тестирования, API тестирования и проверки сложных бизнес-логик.
+ Выполняется тестировщиками, которые имеют базовое понимание кода или системы.

Преимущества:

+ Учитывает как поведение системы, так и её внутренние аспекты.
+ Помогает тестировать сложные системы с большими объемами данных или интеграцией.
+ Уменьшает риск пропуска ошибок, свойственных чёрному ящику.

Недостатки:

+ Требует частичного понимания кода, что может быть сложным для нефункциональных тестировщиков.
+ Может быть менее детальным, чем белый ящик, и менее независимым, чем чёрный.

Пример:
Тестировщик знает, что база данных использует индексацию для ускорения запросов, и проверяет, что результаты запросов
возвращаются быстро, вводя специфические тестовые данные.

| Критерий         | Чёрный ящик	                 | Белый ящик             | Серый ящик                   |
|------------------|------------------------------|------------------------|------------------------------|
| Знание системы   | Не требуется.                | Полное.                | Частичное                    |
| Уровень доступа	 | Только интерфейс.	           | Исходный код	          | Документация/структура       |
| Основной фокус   | Что делает система.          | Как работает система   | Комбинация подходов          |
| Исполнители      | Тестировщики.	               | Разработчики           | Тестировщики/аналитики       |
| Применение       | Функциональное тестирование	 | Модульное тестирование | Интеграция, API тестирование |
| Сложность        | Низкая.                      | Высокая.               | Средняя                      |

[К оглавлению](#OOD)

# 29. Опишите типы тестов: модульное, интеграционное, функциональное, приемочное?

+ Модульное гарантирует правильность отдельных компонентов.
+ Интеграционное проверяет связь между модулями.
+ Функциональное подтверждает выполнение требований.
+ Приемочное определяет готовность системы к выпуску.

Эти тесты не исключают друг друга и часто используются совместно для обеспечения качества программного обеспечения.

| Тип тестирования	 | Фокус	                           | Уровень         | Кто проводит              | Инструменты          |
|-------------------|----------------------------------|-----------------|---------------------------|----------------------|
| Модульное         | Отдельные модули                 | Низкий          | Разработчики              | JUnit, TestNG        |
| Интеграционное	   | Взаимодействие модулей	          | Средний	        | Разработчики/тестировщики | Postman, Spring Test |
| Функциональное    | Пользовательские сценарии        | Средний/Высокий | Тестировщики              | Selenium, JMeter     |
| Приемочное        | Соответствие бизнес-требованиям	 | Высокий         | Пользователи/заказчики    | Нет строгой привязки |

[К оглавлению](#OOD)

