## GC

[1. Чем Java отличается от C++?](#1-Чем-Java-отличается-от-C)

[2. Что такое менеджер памяти?](#2-что-такое-менеджер-памяти)

[3. Какой механизм используется в Java для управления памятью?](#3-какой-механизм-используется-в-java-для-управления-памятью)

[4. Опишите процесс работы сборщика мусора.](#4-опишите-процесс-работы-сборщика-мусора)

[5. Какие алгоритмы сборщика вы знаете?](#5-какие-алгоритмы-сборщика-вы-знаете)

[6. Чем отличаются сборщики мусора?](#6-чем-отличаются-сборщики-мусора)

[7. Расскажите про утилиты для анализа памяти?](#7-расскажите-про-утилиты-для-анализа-памяти)

[8. Что такое ссылки?](#8-что-такое-ссылки)

[9. Какие типы ссылок Вы знаете?](#9-какие-типы-ссылок-вы-знаете)

[10. Чем эти ссылки отличаются?](#10-чем-эти-ссылки-отличаются)

[11. Расскажите про String pool и Integer pool (Integer cache).](#11-расскажите-про-string-pool-и-integer-pool-integer-cache)

[12. Расскажите о методе String.intern().](#12-расскажите-о-методе-stringintern)

[13. Расскажите, что такое профайлер.](#13-расскажите-что-такое-профайлер)

[14. Расскажите, как использовать VisualVM.](#14-расскажите-как-использовать-visualvm)

[15. Расскажите, чем отличается sampling от profiling? (Это типы аудита. Режим работы в профайлере)](#15-расскажите-чем-отличается-sampling-от-profiling-это-типы-аудита-режим-работы-в-профайлерерасскажите-чем-отличается-sampling-от-profiling-это-типы-аудита-режим-работы-в-профайлере)

[16. Расскажите о методе finalize().](#16-расскажите-о-методе-finalize)

[17. Расскажите о методе clone(). Что такое Deep clone and Shallow clone?](#17-расскажите-о-методе-clone-что-такое-deep-clone-and-shallow-clone)

[18. Расскажите о Stack, Heap и Metaspace.](#18-расскажите-о-stack-heap-и-metaspace)

[19. Что такое ClassLoader? Перечислите основные реализации ClassLoader.](#19-что-такое-classloader-перечислите-основные-реализации-classloader)

[20. Расскажите иерархию штатных загрузчиков классов в Java. Какой загрузчик находится в корне иерархии?](#20-расскажите-иерархию-штатных-загрузчиков-классов-в-java-какой-загрузчик-находится-в-корне-иерархии)

[21. Какой загрузчик классов нельзя получить методом getClassLoader()? Почему?](#21-какой-загрузчик-классов-нельзя-получить-методом-getclassloader-почему)

[22. Расскажите алгоритм поиска и загрузки класса в JVM.](#22-расскажите-алгоритм-поиска-и-загрузки-класса-в-jvm)

# 1. Чем Java отличается от C++?

+ В C++ выделение и освобождение памяти - это ручной процесс (например, с помощью операторов new и delete).
+ В Java процесс освобождения памяти автоматически обрабатывается сборщиком мусора. (освобождает память в куче, занятой
  неиспользуемыми объектами)
  Т.е. в отличие от С++ нет явной необходимости уничтожать объект.

[К оглавлению](#GC)

# 2. Что такое менеджер памяти?

**Менеджер памяти** — часть компьютерной программы (как прикладной, так и операционной системы),
обрабатывающая запросы на выделение и освобождение оперативной памяти
или (для некоторых архитектур ЭВМ) запросы на включение заданной области памяти в адресное пространство процессора.

Основное назначение менеджера памяти в первом смысле — реализация динамической памяти, т.е.
выделение оперативной памяти компьютера для объектов в программе осуществляется во время ее выполнения.

Менеджеры памяти часто образуют иерархию, т.е. нижестоящие менеджеры задействуют какие-либо закономерности
выделения-освобождения
памяти и этим снижают нагрузку на вышестоящие. Например:

+ Системный - менеджер памяти, встроенный в ОС.
+ Принадлежащий процессу - менеджер памяти, встроенный в стандартную библиотеку языка программирования,
  берёт у ОС блоки памяти «оптом» и раздаёт их сообразно с нуждами программиста.
+ Специализированные - некоторые динамические структуры данных, например, `vector`,
  также берут память у стандартной библиотеки с запасом (обычно, блоками экспоненциально увеличивающегося размера).

Подобная иерархия приводит к тому, что на каждом из уровней «залёживается» свободная память.
Но это оправдано: снижается фрагментация памяти и повышается скорость.

[К оглавлению](#GC)

# 3. Какой механизм используется в Java для управления памятью?

Сборка мусора выполняется сборщиком мусора (Garbage Collector (GC)). GC – часть JVM,
прикладная программа, которая занимается очищением памяти. Прежде чем удалить объект, нужно знать, где он находится:

+ Важное отступление, выбор «поколенческой» (generational) модели памяти сделан не спроста. Опытным путем было доказано,
  что большинство объектов не живут долго. Это заключение, позволяет сделать young generation небольшим, а в old
  generation хранить объекты действительно «живущие» дольше обычного, тем самым эффективно использовать память.
  ![img](https://github.com/itlazykin/answers_to_exam_questions/blob/main/main/resources/meminjava.png)

#### Структура памяти в JVM:

+ Stack (Не управляется сборщиком мусора)
    + Permanent Generation — содержит необходимые для управления программой метаданные классов,
      в том числе метаданные о созданных объектах, методах и т.п.
    + Code Cache — используемая JVM память при включенной JIT-компиляции
      (в этой области памяти кешируется скомпилированный платформенно-зависимый код)

+ Heap - куча (тут работает GC)
    + New (Yang) Generation - хранит короткоживущие объекты.
        + Eden Space — сюда распределяются среднестатистические объекты*. Если нет места запускается малая сборка
          мусора (minor GC).
        + Survivor Space — точнее их два, S1 и S2, и они меняются ролями.
          Хранятся перемещенные из Eden Space объекты, признанные живыми во время сборки мусора (без разницы малой или
          полной).
          Объекты, пережившие несколько сборок мусора, перемещаются в следующую сборку Tenured Generation.
    + Old (Tenured) Generation - хранит долгоживущие объекты. Когда данная область памяти заполняется,
      выполняется полная сборка мусора (full GC).

#### Как сборщик мусора понимает, какие объекты нужно удалить?

Основным фактором здесь выступает тип ссылки. GC видит, что мы используем «обычные» ссылки. Далее он смотрит на
достижимость объекта по ссылке. Это значит, что если мы не можем получить к нему доступ из программы, т.е. у нас нет
ссылки на него, то он помечается как мусор и будет удален при следующей сборке мусора.

#### Сборка мусора

Сборка мусора происходит, когда заполнена вся область памяти. Память делится на два поколения, поэтому есть два типа
сборки мусора: minor GC и major GC. Первый происходит, когда переполняется young generation, второй, когда переполняется
область из old generation.

#### Стадии, которые проходят объекты до сборки мусора.

1. Объект рождается. Во время исполнения JVM видит, что стоит оператор new. Происходит выделение памяти под объект и
   возврат ссылки, которая будет ссылаться на занятый участок памяти. Все объекты рождаются в eden

![img](https://github.com/itlazykin/answers_to_exam_questions/blob/main/main/resources/mem1.png)

2. Этап 1 выполняет до тех пор, пока не будет заполнен eden. Когда eden заполнен происходит minor GC(малая сборка
   мусора) — это процесс в сборке мусора в Java, который запускается, когда область памяти Young Generation (молодое
   поколение) заполняется.

![img](https://github.com/itlazykin/answers_to_exam_questions/blob/main/main/resources/mem2.png)

3. Объекты, у которых уже нет ссылки удаляются.

![img](https://github.com/itlazykin/answers_to_exam_questions/blob/main/main/resources/mem3.png)

4. Объекты, у которых есть ссылки попадают в survivor space из eden. Причем survivor space делиться на две части. Между
   этими частями происходит перемещения объектов. В один момент времени одна из частей пуста, чтоб мочь вместить объекты
   пришедшие из eden.

![img](https://github.com/itlazykin/answers_to_exam_questions/blob/main/main/resources/mem4.png)

5. Объекты, которые уже были в одной части survivor space, перемещаются в другую, при этом растет их «возраст» (age).
   Сам процесс, перемещения объектов из различных частей survivor space и увеличения их возраста называется
   «взрослением» (aging).

![img](https://github.com/itlazykin/answers_to_exam_questions/blob/main/main/resources/mem5.png)

6. бъекты, которые достигли определенного возраста попадают в old generation. Этот процесс называется «продвижением»
   promotion.

![img](https://github.com/itlazykin/answers_to_exam_questions/blob/main/main/resources/mem6.png)

7. Этапы 1-6 происходят до тех пока не будет заполнен old generation, причем по ходу будут происходить minor GC, для
   очищения young generation.
8. Когда old generation заполняется производиться major GC
9. Этапы 1-7 происходят на протяжении работы программы

*объекты-акселераты, размер которых настолько велик, что создавать их в Eden,
а потом таскать за собой по Survivor’ам слишком накладно, размещаются сразу в Tenured Generation.

[К оглавлению](#GC)

# 4. Опишите процесс работы сборщика мусора.

см. 3 вопрос :

#### Сборка мусора

#### Стадии, которые проходят объекты до сборки мусора.

[К оглавлению](#GC)

# 5. Какие алгоритмы сборщика вы знаете?

Сборщики мусора различаются относительно характеристик какими они обладают.

+ Последовательное (Serial) vs параллельное (Parallel) исполнение сборки мусора. Для того, чтобы очистить память нужно
  остановить приложение - событие Stop The World.
  Причем сам процесс сборки может быть ускорен за счет использования нескольких процессоров, если они присутствуют
  физически.
  Если мы используем последовательную сборку, то она выполняется только в одном потоке и задействует только один
  процессор, что увеличивает время сборки.
  С другой стороны мы можем использовать несколько процессоров за счет распараллеливания сборки, что уменьшает время
  сборки, ценой затрат ресурсов (процессоров) и некоторых накладных расходов (overhead), требуемых для организации
  работы потоков исполнения (Thread).
+ Параллелизм (Concurrency) vs Stop The World. Еще одним способом уменьшения времени пауз является использование
  параллелизма. Данный подход заключается в том, что сборщик мусора работает одновременно с самим приложением. При этом
  он не ждет пока heap заполнится полностью, он периодически производит "мелкие" сборки.
  Причем эти сборки тоже вызывают событие Stop The World, но по времени оно занимает меньше чем если бы сборщик мусора
  чистил бы полностью heap.
  Использование данного подхода оправдано в системах, где требуется минимальный отклик от приложения и не допустимы
  долгие паузы.
  Однако эти минимальные паузы достигаются за счет того, что сборщик мусора требует heap больше.

#### Виды сборок мусора.

После того как сборщик мусора определил, что нужно удалить объекты, он может пользоваться следующими сборками:
Compacting, Non-compacting and Copying.

+ Compacting (Compact с англ. уплотнить): Собирает "живые" объекты в одном месте и очищает оставшуюся часть памяти, где
  находятся объекты, которые нужно уничтожить.
    + Преимущество такого подхода - легко можно выделять память для новых объектов.
    + Недостаток - требуется время на компоновку объектов в одном месте.
+ Non-compacting. Удаляет объекты по месту. Т.е. он понимает, что данную часть памяти занимает объект, который нужно
  удалить, и чистит эту часть памяти.
    + Преимущество: не нужно производить лишние действия, нужно просто удалить объекты.
    + Недостаток: при создании объекта нужно находить для него подходящее место, что приводит к фрагментации памяти (это
      когда большая часть вашей памяти выделена в большом количестве несмежных блоков, оставляя приличный процент вашей
      общей памяти нераспределенной, но при этом непригодной для большинства типичных сценариев использования памяти),
      то есть много свободных мест памяти между занятыми ячейками, но из-за малых ее размеров, ее практически ничем не
      занять, и эта память простаивает.
+ Copying. Копирует "живые" объекты в отдельную часть памяти, очистив старую часть, где они были (С этим типом вы
  встречались в прошлом задании).
    + Преимущество: нет препятствий выделению памяти.
    + Недостаток: требуется время на копирование.

#### Метрики оценки сборщиков мусора

Для того, чтобы оценить сборщик мусора смотрят на следующие характеристики:

- Throughput (Пропускная способность) - процентное соотношение, показывающее сколько GC может работать БЕЗ полной сборки
  мусора. Формально, (1 - время_на_сборки / общ_время) * 100
- GC Overhead - процентное соотношение, показывающее сколько требуется на времени на сборку. Формально, (
  время_на_сборки / общ_время) * 100
- Pause Time (или Latency) - это время на которое требуется остановить приложение, чтобы произвести сборку мусора
- Frequency of collection - это количество сборок проводимых за все время работы приложения.
- Promptness - это время между началом сборки мусора и моментом, когда память снова становится доступной для размещения
  объектов.
- Footprint - это количество памяти доступное приложению

1. `Serial GC`

+ Назначение: Однопоточный сборщик мусора, подходит для приложений с небольшими кучами и работающих в однопоточной
  среде.
+ Алгоритм:
  Использует копирование (Copying) для Young Generation.
  Маркировка-вычищение-компактификация (Mark-Sweep-Compact) для Old Generation.
+ Особенности:
  Приостанавливает все потоки приложения (Stop-the-World, STW) во время сборки.
  Прост и эффективен для малых куч.
+ Ключ: -XX:+UseSerialGC

2. `Parallel GC` (Throughput Collector)

+ Назначение: Многопоточный сборщик мусора для приложений с высокой пропускной способностью (например, серверные
  приложения).
+ Алгоритм:
  Для Young Generation используется копирование.
  Для Old Generation — маркировка-вычищение-компактификация.
+ Особенности:
  Минимизирует общее время, затраченное на сборку, за счёт использования нескольких потоков.
  Все ещё вызывает паузы STW.
+ Ключ: -XX:+UseParallelGC

3. `CMS (Concurrent Mark-Sweep)`

+ Назначение: Минимизирует паузы, подходит для интерактивных приложений.
+ Алгоритм:
  Использует маркировку и вычищение (Mark-Sweep).
  Выполняет большинство работы одновременно с приложением.
+ Особенности:
  Нет компактификации памяти, что может привести к её фрагментации.
  Устарел, начиная с Java 9, заменён на G1.
+ Ключ: -XX:+UseConcMarkSweepGC

4. `G1 GC (Garbage First GC)`

+ Назначение: Подходит для больших куч и приложений с требованиями к минимальным паузам.
+ Алгоритм:
  Разделяет кучу на регионы.
  Сначала очищает регионы с наибольшим количеством мусора (Garbage First).
  Использует комбинацию маркировки, копирования и компактификации.
+ Особенности:
  Снижает паузы за счёт распределения работы на мелкие порции.
  Частично выполняет сборку параллельно с работой приложения.
+ Ключ: -XX:+UseG1GC

5. `ZGC (Z Garbage Collector)`

+ Назначение: Для приложений с большими кучами (до терабайтов) и строгими требованиями к минимальным паузам.
+ Алгоритм: Использует маркировку и копирование. Работает преимущественно параллельно с приложением.
+ Особенности:
  Паузы обычно не превышают 10 миллисекунд.
  Фрагментация памяти минимальна.
  Требует поддержки современных процессоров.
+ Ключ: -XX:+UseZGC

| GC          | Цель                           | Подходит для                  | Паузы          | Примечания                                     |
|-------------|--------------------------------|-------------------------------|----------------|------------------------------------------------|
| Serial GC   | Однопоточные приложения        | Маленькие кучи                | Длинные        | Serial, Stop The World, Copying                |
| Parallel GC | Высокая пропускная способность | Многопоточные серверы         | Средние        | Parallel, Stop The World, Copying              |
| CMS         | Минимизация пауз               | Реалтайм-приложения           | Средние        | Parallel, Concurrent, Copying. Убран с JDK 14. |
| G1 GC       | Минимизация пауз               | Большие кучи                  | Короткие       | Parallel, Concurrent, Copying. Замена CMS      |
| ZGC         | Минимизация пауз               | Огромные кучи (до терабайтов) | Очень короткие | Parallel, Concurrent, Copying                  |

[К оглавлению](#GC)

# 6. Чем отличаются сборщики мусора?

Сборщики мусора (Garbage Collectors, GC) в Java различаются по тому, как они управляют памятью, устраняют мусор и
минимизируют паузы. Подробно рассмотрено в вопросе 5.

[К оглавлению](#GC)

# 7. Расскажите про утилиты для анализа памяти?

Эти инструменты предоставляются вместе с JDK и подходят для большинства задач по мониторингу и отладке:

`jconsole` Графический инструмент для мониторинга приложений Java в реальном времени.

+ Возможности: Просмотр использования кучи и метапространства. Отслеживание работы сборщика мусора. Мониторинг
  потоков. Работа с JMX (Java Management Extensions).

````java
Пример запуска:

C:\User\jconsole
````    

`jvisualvm` Универсальный инструмент с поддержкой плагинов для анализа производительности и памяти.

+ Возможности: Мониторинг использования памяти. Снимки кучи (heap dump). Анализ утечек памяти. Профилирование кода.

```java
Пример запуска:

C:\User\jvisualvm
```

`jmap` Инструмент для работы с дампами памяти.

+ Возможности: Снятие снимков кучи. Получение информации об объектах и классах в памяти.

```java
Пример запуска:

jmap -dump:format=b,file=heap_dump.hprof<pid>
```

`jhat`
Что это: Анализатор дампов памяти (устаревший, заменён сторонними утилитами).

+ Возможности:Анализ объектов в куче через веб-интерфейс.

```java
Пример запуска:

jhat heap_dump.hprof
 ``` 

`jcmd` Универсальный инструмент для управления JVM.

+ Возможности: Запрос текущей статистики памяти. Снятие снимков кучи. Мониторинг работы GC.

```java
Пример запуска:

jcmd<pid> JFR.start duration = 60s filename = myrecording.jfr
```

#### Как анализировать память: пошаговый процесс

+ Подготовка:
    + Определите, какую проблему нужно решить: утечки памяти, высокое использование кучи, или паузы GC.
    + Запустите приложение с флагами мониторинга (-Xlog:gc или -XX:+HeapDumpOnOutOfMemoryError).
+ Сбор данных:
    + Снимите дамп памяти с помощью jmap или jcmd.
    + Подключите мониторинг в реальном времени через jconsole или jvisualvm.
+ Анализ:
    + Загрузите снимок памяти в Eclipse MAT или YourKit.
    + Найдите объекты, которые занимают больше всего памяти.
    + Проверьте корневые ссылки (GC Root) для объектов, которые не очищаются.
+ Оптимизация:
    + Исправьте утечки, переработав код или убрав избыточные ссылки.
    + Настройте параметры JVM для оптимальной работы GC.

[К оглавлению](#GC)

# 8. Что такое ссылки?

Ссылки представляют собой способ обращения к объектам в памяти. Когда вы создаёте объект в Java, вы фактически создаёте
блок памяти в куче, а переменная, которой вы присваиваете этот объект, хранит ссылку на его адрес в памяти.

#### Как работают ссылки в Java

Ссылочная переменная — это указатель, который указывает на место в памяти, где находится объект.
Ссылки используются для управления объектами. Они позволяют работать с объектами, не передавая их "физически", а только
манипулируя указателями.
В отличие от C++ или других языков с указателями, ссылки в Java абстрагированы — вы не видите точный адрес памяти, а
работаете с именами переменных.

```java
String name = "Java"; // name — это ссылка на объект "Java" в памяти
```

#### Примитивы и ссылки

+ Примитивные типы (например, int, double) содержат сами значения.
+ Объектные типы (например, String, ArrayList) содержат ссылки на данные в куче.

```java
int x = 10;             // x хранит само значение 10
Integer y = 10;         // y хранит ссылку на объект Integer
```

#### Передача ссылок

В Java параметры всегда передаются по значению.

+ Для примитивов передаётся копия значения.
+ Для объектов передаётся копия ссылки. Изменение объекта через ссылку повлияет на оригинальный объект, но нельзя
  изменить саму ссылку.

```java
void changeValue(StringBuilder sb) {
    sb.append(" World!");  // Изменение объекта через ссылку
}

StringBuilder sb = new StringBuilder("Hello");

changeValue(sb);
System.out.println(sb); // Вывод: "Hello World!"

```

[К оглавлению](#GC)

# 9. Какие типы ссылок Вы знаете?

Абстрактный класс `java.lang.ref.Reference` предоставляет базу для ссылочных классов. В нём определены следующие методы:

+ `get` — метод, возвращающий сильную ссылку на объект, на который указывает ссылка.
+ `clear` — очищает ссылку.
+ `isEnqueued` и `enqueue`, отвечающие за взаимодействие ссылки и объекта `ReferenceQueue`.

`Сильные ссылки (Strong Reference)`Это обычные ссылки, которые не позволяют сборщику мусора удалять объект, пока
существует ссылка. Если на объект есть хоть одна жесткая ссылка, то данный объект не будет утилизирован при сборке
мусора.

```java
Object obj = new Object(); // obj — сильная ссылка на объект
```

`Слабые ссылки (Weak Reference)`Объект может быть удалён сборщиком мусора, даже если есть слабые ссылки. Используются
для кеширования. Создаются с помощью вызова `new WeakReference<T>(T obj, ReferenceQueue<T> queue)` или `new
WeakReference<T>(T obj)`. Если на объект есть только слабая ссылка, то будет выполнена попытка утилизации данного
объекта при сборке мусора.

```java
Counter counter = new Counter(); // сильная ссылка на объект
WeakReference<Counter> weakCounter = new WeakReference<Counter>(counter); //слабая ссылка
counter =null; // теперь объект Counter подлежит сборке мусора
```

`Мягкие ссылки (Soft Reference)`Объекты с мягкими ссылками удаляются только при нехватке памяти. Применяются для
реализации memory-sensitive кешей. Создаются с помощью вызова `new SoftReference<T>(T obj, ReferenceQueue<T> queue)` или
`new SoftReference(T obj)`. Если на объект есть только мягкая ссылка, то будет выполнена попытка утилизации данного
объекта при сборке мусора в случае, если приложению не хватает памяти.

```java
Counter prime = new Counter();  // prime имеет сильную ссылку - строка 2
SoftReference<Counter> soft = new SoftReference<Counter>(prime); //Переменная мягкой ссылки имеет SoftReference для объекта Counter, созданного в строке 2
prime =null;  // теперь объект Counter может быть подвергнут сборке мусора, но только тогда, когда JVM действительно нужна память
```

`Фантомные ссылки (Phantom Reference)` Используются для отслеживания удаления объекта из памяти. Создаются с помощью
вызова `new PhantomReference<T>(T obj, ReferenceQueue<T> queue)`. Если на объект есть только фантомная ссылка, то будет
выполнена попытка утилизации данного объекта при сборке мусора. Сам объект при этом не будет удален из памяти до тех
пор, пока на него существует фантомная ссылка или данная фантомная ссылка не очищена с помощью вызова метода `clear()`.
Так же стоит заметить, что метод `get()` фантомной ссылки всегда возвращает `null`.

```java
DigitalCounter digit = new DigitalCounter(); // digit имеет сильную ссылку - строка 3
PhantomReference<DigitalCounter> phantom = new PhantomReference<DigitalCounter>(digit); // фантомная ссылка на объект, созданный в строке 3
digit =null;
```

Сильные ссылки могут привести к утечкам памяти, если объекты остаются доступными через цепочку ссылок, но больше не
используются.

```java
List<Object> cache = new ArrayList<>();
cache.add(new Object()); // Объект не может быть удалён, пока он в списке
```

[К оглавлению](#GC)

# 10. Чем эти ссылки отличаются?

Сильные, слабые, мягкие и фантомные ссылки в Java отличаются степенью "удержания" объекта в памяти, то есть тем, как они
влияют на возможность удаления объекта сборщиком мусора (Garbage Collector, GC).

1. Сильная ссылка (Strong Reference). Это обычная ссылка, которая используется по умолчанию.
   Пока существует сильная ссылка на объект, он не может быть удалён сборщиком мусора.

```java
Пример:

Object obj = new Object(); // Сильная ссылка на объект
```

+ Особенности:
    + Объект остаётся в памяти, пока на него есть хотя бы одна сильная ссылка.
    + Это основной вид ссылок, который вы используете в повседневной работе.
+ Недостаток:
    + Может привести к утечке памяти, если сильная ссылка сохраняется на объект, который больше не нужен.

2. Слабая ссылка (Weak Reference). Слабая ссылка позволяет сборщику мусора удалить объект, даже если на него всё ещё
   есть ссылки такого типа. Используется для объектов, которые можно воссоздать, если потребуется, например, в кешах.

```java
Пример:

WeakReference<Object> weakRef = new WeakReference<>(new Object());
Object obj = weakRef.get(); // Получение объекта, если он ещё не удалён
```

+ Особенности:
    + Если сборщик мусора обнаружит, что на объект ссылаются только слабые ссылки, объект будет удалён.
    + После удаления объекта слабая ссылка возвращает null.
+ Применение:
    + Кеширование: слабые ссылки позволяют освобождать память автоматически, если она потребуется для других задач.

3. Мягкая ссылка (Soft Reference). Мягкие ссылки удерживают объект в памяти дольше, чем слабые, и позволяют GC удалять
   объект только при нехватке памяти.

```java
Пример:

SoftReference<Object> softRef = new SoftReference<>(new Object());
Object obj = softRef.get(); // Получение объекта, если он ещё не удалён
```

+ Особенности:
    + Объект с мягкой ссылкой удаляется, если JVM требуется память, но только после удаления всех объектов со слабой
      ссылкой.
    + Это делает мягкие ссылки полезными для реализации memory-sensitive кешей.
+ Применение:
    + Используется для кеширования данных, которые можно восстановить, если они были удалены.

4. Фантомная ссылка (Phantom Reference). Фантомные ссылки не дают доступ к объекту напрямую. Они используются для
   отслеживания момента, когда объект готов к удалению из памяти.
   Необходимы для выполнения действий после удаления объекта, например, освобождения ресурсов.

```java
Пример:

PhantomReference<Object> phantomRef = new PhantomReference<>(new Object(), new ReferenceQueue<>());
```

+ Особенности:
    + Объект с фантомной ссылкой удаляется сборщиком мусора, как только становится недостижимым.
    + Фантомная ссылка всегда возвращает null при вызове get().
+ Применение:
    + Используется в ReferenceQueue для выполнения дополнительных операций перед окончательным удалением объекта из
      памяти,
      например, очистки или логирования.

| Тип ссылки | Удерживает объект в памяти?          | Когда объект удаляется?           | Основные применения                |
|------------|--------------------------------------|-----------------------------------|------------------------------------|
| Сильная    | Да                                   | Никогда, пока есть сильные ссылки | Обычная работа с объектами         |
| Слабая     | Нет                                  | Когда больше нет сильных ссылок   | Кеши, где данные можно воссоздать  |
| Мягкая     | Условно (пока есть свободная память) | При нехватке памяти               | Memory-sensitive кеши              |
| Фантомная  | Нет                                  | Сразу после завершения работы GC  | Освобождение ресурсов, логирование |

Различия между ссылками в Java определяют их применение:

+ Сильные ссылки для обычной работы.
+ Слабые ссылки для данных, которые можно восстановить.
+ Мягкие ссылки для кешей с контролем памяти.
+ Фантомные ссылки для сложного управления ресурсами.

[К оглавлению](#GC)

# 11. Расскажите про String pool и Integer pool (Integer cache).

`String Pool` — это область в памяти JVM (часть Heap), предназначенная для хранения строковых литералов. Она помогает
уменьшить количество одинаковых строк в памяти, что экономит ресурсы.

#### Как это работает:

Когда вы создаёте строку с помощью литерала:

```java
String str1 = "Hello";
String str2 = "Hello";
```

JVM проверяет, существует ли строка "Hello" в String Pool. Если она есть, обе переменные (str1 и str2) будут ссылаться
на один и тот же объект в String Pool.
Если строки нет в пуле, JVM создаёт её и помещает в этот пул.
При создании строки через new объект всегда создаётся в обычной области Heap, даже если строка с таким же значением уже
есть в String Pool:

```java
String str3 = new String("Hello");

будет создан новый объект в Heap, а не в пуле.
```

#### Метод intern()

Метод intern() заставляет JVM проверить, находится ли строка в String Pool. Если её нет, она добавляется в пул:

```java
String str4 = new String("Hello").intern();

Теперь str4 будет ссылаться на строку из String.
```

#### Преимущества String Pool:

+ Экономия памяти: одинаковые строки хранятся в одном экземпляре.
+ Улучшение производительности: строковые сравнения с помощью == быстрее, если строки находятся в String Pool.

`Integer Pool (или Integer Cache)` — это механизм оптимизации памяти для объектов класса Integer. JVM кеширует объекты
Integer в пределах определённого диапазона, чтобы повторно использовать их.

#### Как это работает:

При создании объекта Integer через метод valueOf() JVM использует кеш для значений в диапазоне от -128 до 127:

```java
Integer i1 = Integer.valueOf(100);
Integer i2 = Integer.valueOf(100);
System.out.

println(i1 == i2); // true
```

Оба объекта (i1 и i2) будут ссылаться на один и тот же объект из кеша.

Если значение выходит за пределы диапазона, будет создан новый объект:

```java
Integer i3 = Integer.valueOf(128);
Integer i4 = Integer.valueOf(128);
System.out.

println(i3 == i4); // false
```

Объекты Integer, созданные через new, всегда уникальны:

```java
Integer i5 = new Integer(100);
Integer i6 = new Integer(100);
System.out.

println(i5 == i6); // false
```

#### Почему именно -128 до 127?

Этот диапазон выбран потому, что он покрывает наиболее часто используемые значения, например, индексы массивов,
результаты арифметических операций и пр. Диапазон можно настроить с помощью JVM-флага:

```java
-XX:AutoBoxCacheMax=<значение>
```

Похожее поведение у других классов:
Short, Byte, Character (для символов от \u0000 до \u007F), Long также имеют кеш для значений в пределах небольшого
диапазона.

Оба пула помогают экономить память и ускорять выполнение программы, повторно используя объекты. Однако String Pool
работает со строками, а Integer Pool и другие числовые кеши оптимизируют работу с числовыми значениями, поддерживая
диапазон часто используемых значений.

| Характеристика      | String Pool                   | Integer Pool                  |
|---------------------|-------------------------------|-------------------------------|
| Тип данных          | Только строки                 | Автобоксинг для Integer       |
| Диапазон значений   | Все строки литералы           | От -128 до 127 (по умолчанию) |
| Механизм управления | Автоматически управляется JVM | Управляется через кеш         |
| Метод доступа       | intern()                      | valueOf()                     |

[К оглавлению](#GC)

# 12. Расскажите о методе String.intern().

Метод String.intern() в Java используется для управления строками в String Pool. Этот метод позволяет гарантировать, что
строка существует в единственном экземпляре в String Pool и возвращает ссылку на неё.

#### Как работает intern()?

+ Когда вы вызываете intern() на строке, JVM проверяет, существует ли её значение в String Pool:
    + Если значение уже есть, возвращается ссылка на строку из пула.
    + Если строки с таким значением нет, её копия добавляется в String Pool, и возвращается ссылка на неё.
+ Это помогает экономить память и позволяет использовать строковые литералы, где это возможно.

```java
Пример работы

intern()

public class Main {
    public static void main(String[] args) {
// Создание строки через литерал
        String str1 = "Hello";

// Создание строки через конструктор
        String str2 = new String("Hello");

// Сравнение ссылок
        System.out.println(str1 == str2); // false (разные объекты)

        // Применение intern()
        String str3 = str2.intern();

        // Сравнение после intern()
        System.out.println(str1 == str3); // true (ссылки на один объект в String Pool)
    }
}
```

Объяснение:

+ str1 создаётся в String Pool.
+ str2 создаётся в Heap, так как используется new.
+ После вызова str2.intern(), строка "Hello" ищется в String Pool, и ссылка на неё присваивается str3.

#### Преимущества использования intern()

+ Экономия памяти: одинаковые строки хранятся в одном экземпляре в String Pool.
+ Оптимизация производительности: сравнение строк через == быстрее, чем через equals(), если строки находятся в String
  Pool.

#### Когда следует использовать intern()?

+ Когда вы обрабатываете большое количество строк и хотите уменьшить дублирование.
+ При работе с данными, где строки часто сравниваются (например, ключи в Map).

#### Особенности и ограничения

+ Начиная с Java 7, String Pool хранится в Heap, а не в PermGen (что улучшило масштабируемость).
+ Использование intern() для огромного числа строк может замедлить производительность и увеличить нагрузку на память.
+ Для строк, созданных через литералы, вызов intern() бесполезен, так как они уже находятся в String Pool:

```java
String str = "Example";
System.out.

println(str ==str.intern()); // true
```

#### Пример оптимизации с использованием intern()

Представьте, что мы анализируем массив строк, в котором часто встречаются повторяющиеся значения:

```java
public class Main {
    public static void main(String[] args) {
        String[] words = {"apple", "banana", "apple", "banana", "apple"};

        for (int i = 0; i < words.length; i++) {
            words[i] = words[i].intern();
        }

        // Все элементы массива теперь указывают на строки из String Pool
    }
}

intern() помогает убедиться,что все одинаковые строки ссылаются на один объект в памяти.
```

[К оглавлению](#GC)

# 13. Расскажите, что такое профайлер.

Профайлер — это инструмент для анализа производительности приложений. Он помогает разработчикам выявлять узкие места,
такие как избыточное потребление ресурсов (памяти, процессора) и медленные участки кода, а также отлаживать проблемы,
связанные с многопоточностью и сборкой мусора.

#### Основные задачи профайлера

+ Измерение производительности:
    + Время выполнения методов.
    + Распределение времени на выполнение кода в разных частях программы.
+ Анализ памяти:
    + Выявление утечек памяти.
    + Анализ использования Heap и PermGen/Metaspace.
+ Анализ потоков:
    + Состояние потоков (ожидание, выполнение).
    + Проблемы с блокировками (deadlocks, race conditions).
+ Мониторинг сборки мусора:
    + Частота и длительность сборок.
    + Влияние GC на производительность приложения.
+ Работа с базами данных:
    + Анализ SQL-запросов (например, медленные запросы, избыточное количество запросов).

#### Как работает профайлер?

Профайлер подключается к приложению и собирает метрики в реальном времени или анализирует заранее записанные логи. Он
может использовать:

+ Инструментальные методы: Вставка специальных инструкций в байт-код для сбора данных.
+ Событийные методы: Подписка на события JVM через API (например, Java Flight Recorder).
+ Статистические методы: Снятие "срезов" состояния программы через определённые интервалы времени.

#### Когда использовать профайлер

+ Приложение потребляет слишком много ресурсов (CPU, память).
+ Увеличивается время отклика на запросы.
+ Требуется оптимизация кода для улучшения производительности.
+ Появились подозрения на утечки памяти.
+ Обнаружены проблемы с потоками (например, deadlock).

#### Преимущества использования профайлеров

+ Быстрая диагностика проблем производительности.
+ Подробное понимание работы приложения в реальном времени.
+ Возможность оптимизации кода и конфигурации JVM.

[К оглавлению](#GC)

# 14. Расскажите, как использовать VisualVM.

+ Установите VisualVM (если JDK 8 или выше, он уже в комплекте).
+ Запустите ваше Java-приложение с параметрами JVM:

```java
java -Xmx512m -Xms256m - jar myapp.jar
```

+ Откройте VisualVM и подключитесь к работающему приложению.
+ Исследуйте разделы:
    + Threads — состояние потоков.
    + Memory — использование памяти (Heap, GC).
    + Sampler — временные метрики выполнения методов.

[К оглавлению](#GC)

# 15. Расскажите, чем отличается sampling от profiling? (Это типы аудита. Режим работы в профайлере)Расскажите, чем отличается sampling от profiling? (Это типы аудита. Режим работы в профайлере)

Sampling и profiling — это два подхода к аудиту производительности, используемые в профайлерах. Они отличаются способом
сбора данных, точностью и влиянием на производительность приложения. Давайте разберём их по порядку.

`Sampling` — это метод периодического сбора данных о состоянии приложения. Профайлер через регулярные интервалы времени
снимает "срезы" текущего состояния, например, стека вызовов, использование процессора или памяти.

#### Как работает Sampling

+ Профайлер проверяет состояние программы через определённые интервалы времени (например, каждые 10 миллисекунд).
+ Он фиксирует активные потоки, текущие методы и их загрузку процессора.
+ На основе множества таких срезов строится статистика использования ресурсов.

#### Плюсы Sampling

+ Низкое влияние на производительность. Поскольку данные собираются периодически, это минимально нагружает приложение.
+ Простота настройки. Обычно не требует сложной интеграции.
+ Подходит для долгоживущих приложений. Хорошо справляется с мониторингом производительности за длительное время.

#### Минусы Sampling

+ Меньшая точность. Из-за использования интервалов может пропустить кратковременные проблемы.
+ Ограниченная детализация. Трудно отследить точные причины проблем на уровне отдельных вызовов.

`Profiling` — это метод, при котором профайлер собирает детальную информацию о каждом вызове метода и использовании
ресурсов. Этот подход часто требует вставки специального кода (инструментирования) в приложение.

#### Как работает Profiling

+ Профайлер перехватывает каждый вызов метода.
+ Собирает полную информацию о времени выполнения, объёме потребляемых ресурсов и контексте вызова.
+ Записывает данные для последующего анализа.

#### Плюсы Profiling

+ Высокая точность. Полный отчёт о каждом вызове метода.
+ Детализация. Позволяет найти узкие места даже на уровне отдельных строк кода.
+ Идеально для поиска критических багов. Полезно для анализа кратковременных проблем.

#### Минусы Profiling

+ Высокое влияние на производительность. Инструментирование значительно замедляет работу приложения.
+ Большой объём данных. Требует больше ресурсов для хранения и анализа.
+ Сложность настройки. Необходимо правильно выбрать профилируемые участки, чтобы избежать избыточных данных.

#### Пример использования

+ Если вы хотите просто понять, какие методы загружают процессор в вашем приложении, используйте sampling.
+ Если у вас есть кратковременная, но критическая проблема (например, метод неожиданно долго выполняется), включайте
  profiling.
+ Sampling лучше всего подходит для общего анализа производительности с минимальной нагрузкой на приложение.
+ Profiling эффективен для детального изучения узких мест, но требует осторожного подхода, чтобы не замедлить
  приложение.

[К оглавлению](#GC)

# 16. Расскажите о методе finalize().

Метод finalize() — это специальный метод в Java, определённый в классе Object, который предназначен для выполнения
завершающих операций перед сборкой мусора объекта. Однако его использование считается устаревшим, и в современных
приложениях он практически не применяется.

#### Как работает метод finalize()

Метод finalize() вызывается сборщиком мусора до удаления объекта из памяти.
Предполагается, что разработчик может переопределить этот метод в своём классе, чтобы реализовать действия, которые
должны быть выполнены перед уничтожением объекта. Например, освобождение ресурсов (закрытие файлов, сокетов и т.д.).

```java
Пример кода:

class MyClass {
    @Override
    protected void finalize() throws Throwable {
        try {
            System.out.println("Finalize called for object: " + this);
        } finally {
            super.finalize();
        }
    }
}

Когда объект становится недостижимым, метод finalize()
может быть вызван автоматически сборщиком мусора.
```

#### Особенности finalize()

+ Не гарантируется вызов: Сборщик мусора не гарантирует, что метод finalize() будет вызван. Если JVM завершит работу до
  вызова сборщика, метод так и не выполнится.
+ Одна попытка вызова: Метод finalize() вызывается только один раз для объекта. Если объект "воскрешается" (снова
  становится доступным), он больше не будет участвовать в сборке мусора.
+ Медленное выполнение: Использование finalize() может замедлить сборку мусора, так как сборщику нужно дождаться
  выполнения этого метода.
+ Риск утечек памяти: Если объект "воскрешается" внутри finalize() (например, присваивается глобальной переменной), он
  может не быть удалён из памяти, что приведёт к утечке.

#### Почему использование finalize() не рекомендуется?

+ Устаревший подход: Начиная с Java 9 метод finalize() объявлен устаревшим (deprecated). Это связано с его ненадёжностью
  и сложностью в предсказании поведения.
+ Современные альтернативы:
    + try-with-resources: Автоматическое закрытие ресурсов для классов, реализующих интерфейс AutoCloseable.
    + Методы close() или dispose(): Ручной вызов освобождения ресурсов.
+ Влияние на производительность:Использование finalize() увеличивает нагрузку на сборщик мусора, так как требует
  выполнения дополнительных операций.

```java
Пример с
использованием try-with-resources:

        try(
BufferedReader reader = new BufferedReader(new FileReader("file.txt"))){
        System.out.println(reader.readLine());
        }catch(
IOException e){
        e.printStackTrace();
}
```

Альтернатива finalize() — Cleaner
Java предлагает класс java.lang.ref.Cleaner (начиная с Java 9) для выполнения завершающих операций в безопасном и
предсказуемом стиле.

```java
Пример с использованием Cleaner:

import java.lang.ref.Cleaner;

class MyResource {
    private static final Cleaner cleaner = Cleaner.create();
    private final Cleaner.Cleanable cleanable;

    public MyResource() {
        cleanable = cleaner.register(this, () -> System.out.println("Cleaning up resources!"));
    }

    public void close() {
        cleanable.clean();
    }
}

public class Main {
    public static void main(String[] args) {
        MyResource resource = new MyResource();
        resource.close(); // Явное освобождение ресурсов
    }
}

```

[К оглавлению](#GC)

# 17. Расскажите о методе clone(). Что такое Deep clone and Shallow clone?

Метод clone() в Java используется для создания копии объекта. Этот метод определён в классе Object и позволяет объекту "
клонировать себя".

#### Как работает clone()

+ Метод clone() возвращает копию текущего объекта.
+ Возвращаемый объект является новой копией с теми же значениями всех полей, что и у оригинала.
+ Он создаёт поверхностную копию объекта (по умолчанию), если не переопределён.

#### Требования для использования clone()

+ Реализация интерфейса Cloneable: Чтобы метод clone() мог работать, класс должен реализовать интерфейс Cloneable, иначе
  будет выброшено исключение CloneNotSupportedException.
+ Переопределение метода: Хотя метод clone() определён в классе Object, рекомендуется переопределить его, чтобы
  уточнить, как объект должен быть клонирован.

```java
class Person implements Cloneable {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + "}";
    }
}

public class Main {
    public static void main(String[] args) throws CloneNotSupportedException {
        Person person1 = new Person("Alice", 25);
        Person person2 = (Person) person1.clone();

        System.out.println("Original: " + person1);
        System.out.println("Clone: " + person2);
    }
}
```

`Shallow Clone (поверхностное клонирование)`

+ Поверхностное клонирование создаёт новый объект, но копирует только ссылки на внутренние объекты.
+ Если оригинальный объект содержит ссылочные поля, то клонированный объект будет ссылаться на те же экземпляры.

#### Проблема с Shallow Clone

Если изменяется объект, на который ссылается клонированный экземпляр, это изменение будет видно и в оригинальном
объекте, что может привести к неожиданным результатам.

```java
Пример проблемы:

class Address {
    String city;

    Address(String city) {
        this.city = city;
    }
}

class Person implements Cloneable {
    String name;
    Address address;

    Person(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

public class Main {
    public static void main(String[] args) throws CloneNotSupportedException {
        Address address = new Address("New York");
        Person person1 = new Person("Alice", address);
        Person person2 = (Person) person1.clone();

        person2.address.city = "Los Angeles";

        System.out.println("Original city: " + person1.address.city); // Los Angeles
    }
}
```

`Deep Clone (глубокое клонирование)`

+ Глубокое клонирование копирует не только объект, но и все объекты, на которые он ссылается.
+ Каждый внутренний объект создаётся заново, и ссылки на него будут уникальными для клонированного объекта.

#### Как реализовать Deep Clone?

+ Глубокое клонирование нужно реализовать вручную, переопределяя метод clone() и вызывая его для всех вложенных
  объектов.
+ Альтернативно можно использовать сериализацию и десериализацию для глубокого копирования.

```java
Пример Deep
Clone:

class Address implements Cloneable {
    String city;

    Address(String city) {
        this.city = city;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

}

class Person implements Cloneable {
    String name;
    Address address;

    Person(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        Person cloned = (Person) super.clone();
        cloned.address = (Address) address.clone(); // Глубокое клонирование
        return cloned;
    }

}

public class Main {
    public static void main(String[] args) throws CloneNotSupportedException {
        Address address = new Address("New York");
        Person person1 = new Person("Alice", address);
        Person person2 = (Person) person1.clone();

        person2.address.city = "Los Angeles";

        System.out.println("Original city: " + person1.address.city); // New York
    }

}
```

+ Shallow Clone: Быстрое, но не безопасное при наличии ссылочных полей.
+ Deep Clone: Гарантирует полную независимость клонированного объекта от оригинала, но требует больше усилий для
  реализации.
+ Метод clone() редко используется в реальных проектах из-за своей сложности и ограничений. Вместо этого часто
  используют
  другие подходы, например, копирующие конструкторы или библиотеки (например, Apache Commons Lang или Gson для
  сериализации).

[К оглавлению](#GC)

# 18. Расскажите о Stack, Heap и Metaspace.

В Java память делится на несколько областей, каждая из которых отвечает за хранение определённого типа данных. Основные
области — Stack, Heap и Metaspace.

`Stack (Стек)`Стек — это область памяти, используемая для хранения локальных переменных и вызовов методов. Он
организован по принципу LIFO (Last In, First Out).

+ Особенности:
    + Быстродействие: работа со стеком очень быстрая, так как он работает как стековая структура данных.
    + Размер ограничен: каждый поток имеет свой стек, а его размер задаётся при запуске программы.
    + Автоматическое управление: память освобождается, когда метод завершает выполнение.
+ Что хранится в стеке?
    + Примитивные типы (например, int, char, double), объявленные в методе.
    + Ссылки на объекты, которые создаются в куче (Heap).
    + Параметры метода и его локальные переменные.

```java
Пример:

void methodA() {
    int x = 5;          // Примитив хранится в стеке
    String str = "abc"; // Ссылка на объект в куче
    methodB();
}

Когда метод завершает выполнение, стек автоматически очищается
для этого вызова.
```

`Heap (Куча)`Куча — это область памяти, где хранятся объекты и данные, которые существуют дольше, чем время выполнения
метода. Это основной источник динамической памяти в Java.

+ Особенности:
    + Управляется сборщиком мусора (Garbage Collector), который освобождает память, занятую объектами, больше не
      имеющими ссылок.
    + Неограниченное время жизни объектов: объект остаётся в памяти, пока есть ссылки на него.
+ Что хранится в куче?
    + Объекты, созданные с помощью new (например, new String("Hello")).
    + Статические поля, если они являются объектами.
    + Поля экземпляра объектов, включая их примитивные типы.

```java
Пример:

Копировать код

class Car {
    int speed;      // Поле хранится в куче
    String model;   // Ссылка на строку в куче
}

Car car = new Car(); // Новый объект хранится в куче
```

#### Разделение кучи:

+ Young Generation: хранит молодые объекты (короткоживущие). Garbage Collector чаще всего работает здесь.
+ Old Generation: хранит более долгоживущие объекты.
+ Eden, Survivor Spaces (S0, S1): части Young Generation.

`Metaspace`Metaspace — это область памяти, используемая для хранения метаданных классов. С 2014 года (Java 8) Metaspace
заменил PermGen.

+ Особенности:
    + Metaspace динамически управляет своей памятью в отличие от фиксированного размера PermGen.
    + Хранит информацию о классах, включая:
        + Метаданные классов.
        + Информацию о методах и их байткоде.
        + Пул строк (String Pool) с версии Java 7.
+ Что хранится в Metaspace?
    + Классы и методы, загруженные ClassLoader'ами.
    + Информация о байткоде, используемая JVM.
    + Runtime-пул строк (до Java 7 он находился в PermGen).

Пример:
Если вы загружаете много классов (например, с помощью динамической загрузки), Metaspace может вырасти, что
увеличит потребление памяти.

#### Ключевые различия между Stack, Heap и Metaspace

| Характеристика   | Stack	                               | Heap                   | Metaspace          |
|------------------|--------------------------------------|------------------------|--------------------|
| Роль             | Локальные переменные, вызовы методов | Долговременные объекты | Метаданные классов |
| Управление       | Автоматическое, с завершением метода | Сборщик мусора         | Сборщик мусора     |
| Размер           | Задаётся на старте JVM               | Динамически растёт     | Динамически растёт |
| Скорость доступа | Очень высокая                        | Высокая                | Высокая            |
| Содержит         | Примитивы, ссылки на объекты	        | Объекты, их поля       | Метаданные классов |

#### Резюме

+ Stack: используется для выполнения методов и локальных переменных. Очень быстро очищается после завершения вызова.
+ Heap: для хранения объектов и данных, которые требуют более долгого времени жизни. Управляется сборщиком мусора.
+ Metaspace: для хранения информации о классах и методах. Динамически масштабируется, не имеет фиксированного размера.

[К оглавлению](#GC)

# 19. Что такое ClassLoader? Перечислите основные реализации ClassLoader.

ClassLoader в Java — это компонент JVM, который отвечает за загрузку классов в память во время выполнения программы. Он
преобразует байткод из файлов .class или других источников в объекты Class, которые JVM использует для выполнения
программы.
Классы в Java загружаются лениво, то есть только тогда, когда они требуются. Это позволяет оптимизировать использование
памяти и ускорить загрузку приложений.

#### Принцип работы ClassLoader

ClassLoader работает по иерархической модели: каждый загрузчик классов делегирует процесс загрузки своему родителю. Если
родительский загрузчик не может загрузить класс, только тогда текущий ClassLoader пытается загрузить его самостоятельно.
Этот принцип известен как делегирование загрузки (Delegation Model).

#### Основные функции ClassLoader:

+ Загрузка классов: чтение байткода из источника (например, файла .class) и его преобразование в объект Class.
+ Пространство имён: каждый загрузчик классов создаёт своё пространство имён. Это позволяет загружать классы с
  одинаковыми
  именами из разных источников.
+ Защита от конфликтов: благодаря делегированию загрузки, ClassLoader предотвращает конфликты между базовыми и
  пользовательскими классами.

#### Основные реализации ClassLoader

`Bootstrap ClassLoader`

+ Загрузчик ядра JVM.
+ Загружает классы из <JAVA_HOME>/lib и других стандартных библиотек.
+ Написан на C и является частью JVM.
+ Не подкласс ClassLoader (является встроенным компонентом).

`Extension ClassLoader`

+ Загружает классы из каталога <JAVA_HOME>/lib/ext или из путей, указанных в системной переменной java.ext.dirs.
+ Подкласс ClassLoader.
+ Расширяет функциональность стандартной библиотеки.

`System (Application) ClassLoader`

+ Загружает классы из пути, указанного в переменной CLASSPATH.
+ Это основной загрузчик пользовательских классов.
+ Используется для загрузки классов приложения и библиотек.

`Пользовательские (Custom) ClassLoader`

+ Разработчики могут создавать свои ClassLoader'ы, наследуясь от ClassLoader.
+ Используются для специфических задач, таких как загрузка классов из базы данных, сети или шифрованных файлов.

 ``` java
Иерархия ClassLoader'ов
   
Bootstrap ClassLoader
↑
Extension ClassLoader
↑
System (Application) ClassLoader
↑
Custom ClassLoader
Каждый загрузчик делегирует загрузку своему родителю, начиная с Bootstrap ClassLoader.
```

```java
Пример использования Custom ClassLoader
Пользовательский ClassLoader может пригодиться,  если нужно
загружать классы из нестандартных источников,например, из сети
или зашифрованных файлов .

public class CustomClassLoader extends ClassLoader {
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
// Загрузка байткода класса
        byte[] classData = loadClassData(name);
        return defineClass(name, classData, 0, classData.length);
    }

    private byte[] loadClassData(String className) {
        // Логика загрузки байткода из файла или другого источника
        return new byte[0]; // Заглушка
    }
}
```

#### Резюме

+ ClassLoader — это механизм, который загружает классы в память JVM во время выполнения программы.
+ Основные реализации:
    + Bootstrap ClassLoader — загружает стандартные классы JDK.
    + Extension ClassLoader — загружает расширения JDK.
    + System ClassLoader — загружает классы приложения.
    + Custom ClassLoader — реализуется для специфических задач.
+ Благодаря иерархии и делегированию, ClassLoader обеспечивает безопасность и предотвращает конфликты.

[К оглавлению](#GC)

# 20. Расскажите иерархию штатных загрузчиков классов в Java. Какой загрузчик находится в корне иерархии?

В Java загрузчики классов организованы в иерархическую структуру с делегированием загрузки. Каждый загрузчик классов
делегирует задачу загрузки своему родителю перед тем, как попытаться загрузить класс самостоятельно. Это помогает
избежать конфликтов, например, когда системный класс и пользовательский имеют одно и то же имя.

#### Иерархия штатных ClassLoaders

+ Bootstrap ClassLoader (в корне иерархии):
    + Отвечает за загрузку базовых классов Java, которые находятся в $JAVA_HOME/lib, например, java.lang.String,
      java.util.List.
    + Написан на C и встроен в JVM.
    + Не является экземпляром ClassLoader, поэтому его невозможно отобразить напрямую.
+ Extension ClassLoader:
    + Загружает классы из каталога $JAVA_HOME/lib/ext или других мест, указанных в системной переменной java.ext.dirs.
    + Это первый видимый экземпляр Java-класса ClassLoader.
+ System (Application) ClassLoader:
    + Загружает классы из CLASSPATH, который задаётся параметром -cp или переменной окружения CLASSPATH.
    + Используется для загрузки классов приложения и библиотек.

#### Схема иерархии

```java
Bootstrap ClassLoader(ядро JVM)
       ↑
Extension ClassLoader
       ↑
System(Application) ClassLoader

```

Каждый последующий ClassLoader делегирует задачу загрузки классов своему родителю. Если родительский загрузчик не может
найти класс, текущий ClassLoader пытается загрузить его самостоятельно.
Bootstrap ClassLoader находится в корне иерархии ClassLoader'ов. Он встроен в JVM и выполняет задачи по загрузке базовых
классов Java.

#### Как узнать загрузчик конкретного класса?

Можно использовать метод getClassLoader() класса Class для определения загрузчика:

```java
public class ClassLoaderExample {
    public static void main(String[] args) {
// Получаем ClassLoader для текущего класса
        ClassLoader classLoader = ClassLoaderExample.class.getClassLoader();
        System.out.println("ClassLoader for this class: " + classLoader);

        // Получаем ClassLoader для системного класса
        ClassLoader stringClassLoader = String.class.getClassLoader();
        System.out.println("ClassLoader for String class: " + stringClassLoader);
    }
}
```

Вывод:

+ Класс ClassLoaderExample будет загружен System ClassLoader.
+ Класс String будет загружен Bootstrap ClassLoader, и его getClassLoader() вернёт null (так как он не является
  экземпляром Java-класса).

#### Резюме

+ Корнем иерархии является Bootstrap ClassLoader, встроенный в JVM.
+ Делегирование между ClassLoader'ами обеспечивает безопасность и изоляцию классов.
+ Расширяемость позволяет разработчикам создавать пользовательские загрузчики для специфических нужд.

[К оглавлению](#GC)

# 21. Какой загрузчик классов нельзя получить методом getClassLoader()? Почему?

Bootstrap ClassLoader нельзя получить с помощью метода getClassLoader().

#### Почему?

+ Не является экземпляром Java-класса:
    + Bootstrap ClassLoader реализован на языке C (или другом нативном языке) как часть самой JVM. Он не является
      объектом класса ClassLoader и, соответственно, не доступен в пространстве объектов Java.
+ Возвращает null:
    + По соглашению, если у класса getClassLoader() возвращает null, это означает, что он был загружен Bootstrap
      ClassLoader. Это поведение стандартное и предусмотрено спецификацией Java.
+ Цель безопасности:
    + Скрытие Bootstrap ClassLoader помогает защитить базовые классы Java от вмешательства приложения. Если бы он был
      доступен, можно было бы повлиять на его работу, что нарушило бы целостность JVM.

```java
Пример кода:

public class ClassLoaderExample {
    public static void main(String[] args) {
        // Проверим загрузчик для класса приложения
        ClassLoader appClassLoader = ClassLoaderExample.class.getClassLoader();
        System.out.println("ClassLoader for ClassLoaderExample: " + appClassLoader);

        // Проверим загрузчик для базового класса String
        ClassLoader stringClassLoader = String.class.getClassLoader();
        System.out.println("ClassLoader for String class: " + stringClassLoader);
    }
}

Вывод:

ClassLoader for ClassLoaderExample:jdk.internal.loader.ClassLoaders$AppClassLoader@<hash>
ClassLoader for String class:null
```

+ Для пользовательского класса (ClassLoaderExample) используется System ClassLoader.
+ Для базового класса (String) возвращается null, указывая, что его загрузил Bootstrap ClassLoader.

#### Зачем это нужно?

+ Изоляция: Пользовательский код не может напрямую взаимодействовать с Bootstrap ClassLoader, что минимизирует риски
  изменений или подмены базовых классов Java.
+ Упрощение архитектуры: Bootstrap ClassLoader работает только с ядром JVM, что позволяет ему быть легче и быстрее, не
  перегружаясь функциональностью, нужной пользовательским загрузчикам.

#### Резюме

+ Нельзя получить Bootstrap ClassLoader с помощью getClassLoader(), потому что он не является объектом ClassLoader и
  возвращает null для всех загружаемых им классов.
+ Это сделано для безопасности и изоляции системных классов.

[К оглавлению](#GC)

# 22. Расскажите алгоритм поиска и загрузки класса в JVM.

JVM использует четко определенный процесс для поиска и загрузки класса, называемый Delegation Model (Модель
делегирования). Основные этапы этого алгоритма:

1. Проверка кеша загруженных классов

+ JVM сначала проверяет, был ли класс уже загружен.
  Если да, то возвращается ранее загруженный экземпляр класса (из кеша ClassLoader).

2. Делегирование загрузчику

+ JVM следует модели делегирования: каждый загрузчик передает задачу своему родителю (вверх по цепочке).
+ Иерархия загрузчиков:
    + Bootstrap ClassLoader (на уровне JVM)
    + Extension ClassLoader (для загрузки библиотек расширений)
    + System (Application) ClassLoader (загружает классы приложения)

3. Поиск класса

+ Если родительский загрузчик не может найти и загрузить класс, текущий загрузчик пытается найти его самостоятельно.

Поиск происходит следующим образом:

+ Для Bootstrap ClassLoader:
    + Класс ищется в стандартных библиотеках (rt.jar, java.base, и других).
+ Для Extension ClassLoader:
    + Класс ищется в папке расширений JVM ($JAVA_HOME/lib/ext).
+ Для Application ClassLoader:
    + Класс ищется в CLASSPATH (или в указанном пути).

4. Если класс не найден после проверки всех загрузчиков, JVM выбрасывает исключение: `java.lang.ClassNotFoundException`
5. Загрузка класса

+ Если класс найден, он загружается в JVM.
+ Сначала JVM считывает файл .class, а затем преобразует байт-код в объект Class.

6. После загрузки класса JVM инициализирует его:

+ Выполняет статические блоки инициализации.
+ Устанавливает значения статических переменных.
+ Готовит класс для использования.

#### Делегирующая модель (Delegation Model)

```java
Application ClassLoader
↓
Extension ClassLoader
↓
Bootstrap ClassLoader
```

#### Почему используется делегирование?

+ Безопасность: Гарантирует, что системные классы (например, `java.lang.String`) загружаются только из стандартной
  библиотеки, а не из пользовательского пути.
+ Оптимизация: Избегает повторной загрузки одного и того же класса.
+ Консистентность: Упрощает работу JVM, так как все классы имеют единую точку загрузки.

#### Пример на практике

Допустим, вы запускаете код:

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```

Поиск класса:
+ JVM вызывает Application ClassLoader для загрузки Main.
+ Application ClassLoader делегирует запрос Extension ClassLoader.
+ Extension ClassLoader делегирует запрос Bootstrap ClassLoader.
+ Bootstrap ClassLoader ищет класс Main в системных библиотеках, не находит и возвращает управление.
+ В итоге Application ClassLoader ищет класс в CLASSPATH и загружает его.

#### Резюме

Алгоритм загрузки классов в JVM включает:

+ Проверку уже загруженных классов.
+ Делегирование поиска родительским загрузчикам.
+ Поиск класса в установленном пути.
+ Загрузку байт-кода и его преобразование в объект Class.
+ Инициализацию класса.

[К оглавлению](#GC)
