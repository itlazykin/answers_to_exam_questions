## GC

[1. Чем Java отличается от C++?](#1-Чем-Java-отличается-от-C)

[2. Что такое менеджер памяти?](#2-что-такое-менеджер-памяти)

[3. Какой механизм используется в Java для управления памятью?](#3-какой-механизм-используется-в-java-для-управления-памятью)

[4. Опишите процесс работы сборщика мусора.](#4-опишите-процесс-работы-сборщика-мусора)

[5. Какие алгоритмы сборщика вы знаете?](#5-какие-алгоритмы-сборщика-вы-знаете)

[6. Чем отличаются сборщики мусора?](#6-чем-отличаются-сборщики-мусора)

[7. Расскажите про утилиты для анализа памяти?](#7-расскажите-про-утилиты-для-анализа-памяти)

[8. Что такое ссылки?](#8-что-такое-ссылки)

[9. Какие типы ссылок Вы знаете?](#9-какие-типы-ссылок-вы-знаете)

[10. Чем эти ссылки отличаются?](#10-чем-эти-ссылки-отличаются)

[11. Расскажите про String pool и Integer pool (Integer cache).](#11-расскажите-про-string-pool-и-integer-pool-integer-cache)

[12. Расскажите о методе String.intern().](#12-расскажите-о-методе-stringintern)

[13. Расскажите, что такое профайлер.](#13-расскажите-что-такое-профайлер)

[14. Расскажите, как использовать VisualVM.](#14-расскажите-как-использовать-visualvm)

[15. Расскажите, чем отличается sampling от profiling? (Это типы аудита. Режим работы в профайлере)](#15-расскажите-чем-отличается-sampling-от-profiling-это-типы-аудита-режим-работы-в-профайлерерасскажите-чем-отличается-sampling-от-profiling-это-типы-аудита-режим-работы-в-профайлере)

[16. Расскажите о методе finalize().](#16-расскажите-о-методе-finalize)

[17. Расскажите о методе clone(). Что такое Deep clone and Shallow clone?](#17-расскажите-о-методе-clone-что-такое-deep-clone-and-shallow-clone)

[18. Расскажите о Stack, Heap и Metaspace.](#18-расскажите-о-stack-heap-и-metaspace)

[19. Что такое ClassLoader? Перечислите основные реализации ClassLoader.](#19-что-такое-classloader-перечислите-основные-реализации-classloader)

[20. Расскажите иерархию штатных загрузчиков классов в Java. Какой загрузчик находится в корне иерархии?](#20-расскажите-иерархию-штатных-загрузчиков-классов-в-java-какой-загрузчик-находится-в-корне-иерархии)

[21. Какой загрузчик классов нельзя получить методом getClassLoader()? Почему?](#21-какой-загрузчик-классов-нельзя-получить-методом-getclassloader-почему)

[22. Расскажите алгоритм поиска и загрузки класса в JVM.](#22-расскажите-алгоритм-поиска-и-загрузки-класса-в-jvm)

# 1. Чем Java отличается от C++?
+ В C++ выделение и освобождение памяти - это ручной процесс (например, с помощью операторов new и delete).
+ В Java процесс освобождения памяти автоматически обрабатывается сборщиком мусора. (освобождает память в куче, занятой неиспользуемыми объектами)
Т.е. в отличие от С++ нет явной необходимости уничтожать объект.

[К оглавлению](#GC)

# 2. Что такое менеджер памяти?
**Менеджер памяти** — часть компьютерной программы (как прикладной, так и операционной системы),
обрабатывающая запросы на выделение и освобождение оперативной памяти
или (для некоторых архитектур ЭВМ) запросы на включение заданной области памяти в адресное пространство процессора.

Основное назначение менеджера памяти в первом смысле — реализация динамической памяти, т.е.
выделение оперативной памяти компьютера для объектов в программе осуществляется во время ее выполнения.

Менеджеры памяти часто образуют иерархию, т.е. нижестоящие менеджеры задействуют какие-либо закономерности выделения-освобождения
памяти и этим снижают нагрузку на вышестоящие. Например:

+ Системный - менеджер памяти, встроенный в ОС.
+ Принадлежащий процессу - менеджер памяти, встроенный в стандартную библиотеку языка программирования,
  берёт у ОС блоки памяти «оптом» и раздаёт их сообразно с нуждами программиста.
+ Специализированные - некоторые динамические структуры данных, например, `vector`,
  также берут память у стандартной библиотеки с запасом (обычно, блоками экспоненциально увеличивающегося размера).

Подобная иерархия приводит к тому, что на каждом из уровней «залёживается» свободная память.
Но это оправдано: снижается фрагментация памяти и повышается скорость.

[К оглавлению](#GC)

# 3. Какой механизм используется в Java для управления памятью?
+ Stack (структура non-heap до JDK 8)
    + Permanent Generation — содержит необходимые для управления программой метаданные классов,
      в том числе метаданные о созданных объектах, методах и т.п.
    + Code Cache — используемая JVM память при включенной JIT-компиляции
      (в этой области памяти кешируется скомпилированный платформенно-зависимый код)

+ Heap - куча (тут и работает GC)
    + New (Yang) Generation - хранит короткоживущие объекты.
        + Eden Space — сюда аллоцируются среднестатистические объекты*. Если нет места запускается малая сборка мусора (minor GC).
        + Survivor Space — точнее их два, S1 и S2, и они меняются ролями.
          Хранятся перемещенные из Eden Space объекты, признанные живыми во время сборки мусора (без разницы малой или полной).
          Объекты, пережившие несколько сборок мусора, перемещаются в следующую сборку Tenured Generation.
    + Old (Tenured) Generation - хранит долгоживущие объекты. Когда данная область памяти заполняется,
      выполняется полная сборка мусора (full GC).

Алгоритм GC исходит из того предположения, что большинство java-объектов живут недолго.
Быстро становятся мусором. От них необходимо довольно оперативно избавляться. Что и происходит в New Generation.
Там сбор мусора гораздо чаще, чем в Old Generation, где хранятся долгоживущие объекты.
После создания объект попадает в New Generation и имеет шанс попасть в Old Generation по прошествии нескольких циклов GC.

*объекты-акселераты, размер которых настолько велик, что создавать их в Eden,
а потом таскать за собой по Survivor’ам слишком накладно, размещаются сразу в Tenured Generation.

[К оглавлению](#GC)

# 4. Опишите процесс работы сборщика мусора.

[К оглавлению](#GC)

# 5. Какие алгоритмы сборщика вы знаете?

[К оглавлению](#GC)

# 6. Чем отличаются сборщики мусора?

[К оглавлению](#GC)

# 7. Расскажите про утилиты для анализа памяти?

[К оглавлению](#GC)

# 8. Что такое ссылки?

[К оглавлению](#GC)

# 9. Какие типы ссылок Вы знаете?

[К оглавлению](#GC)

# 10. Чем эти ссылки отличаются?

[К оглавлению](#GC)

# 11. Расскажите про String pool и Integer pool (Integer cache).

[К оглавлению](#GC)

# 12. Расскажите о методе String.intern().

[К оглавлению](#GC)

# 13. Расскажите, что такое профайлер.

[К оглавлению](#GC)

# 14. Расскажите, как использовать VisualVM.

[К оглавлению](#GC)

# 15. Расскажите, чем отличается sampling от profiling? (Это типы аудита. Режим работы в профайлере)Расскажите, чем отличается sampling от profiling? (Это типы аудита. Режим работы в профайлере)

[К оглавлению](#GC)

# 16. Расскажите о методе finalize().

[К оглавлению](#GC)

# 17. Расскажите о методе clone(). Что такое Deep clone and Shallow clone?

[К оглавлению](#GC)

# 18. Расскажите о Stack, Heap и Metaspace.

[К оглавлению](#GC)

# 19. Что такое ClassLoader? Перечислите основные реализации ClassLoader.

[К оглавлению](#GC)

# 20. Расскажите иерархию штатных загрузчиков классов в Java. Какой загрузчик находится в корне иерархии?

[К оглавлению](#GC)

# 21. Какой загрузчик классов нельзя получить методом getClassLoader()? Почему?

[К оглавлению](#GC)

# 22. Расскажите алгоритм поиска и загрузки класса в JVM.

[К оглавлению](#GC)
