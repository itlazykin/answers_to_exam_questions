## GC

[1. Чем Java отличается от C++?](#1-Чем-Java-отличается-от-C)

[2. Что такое менеджер памяти?](#2-что-такое-менеджер-памяти)

[3. Какой механизм используется в Java для управления памятью?](#3-какой-механизм-используется-в-java-для-управления-памятью)

[4. Опишите процесс работы сборщика мусора.](#4-опишите-процесс-работы-сборщика-мусора)

[5. Какие алгоритмы сборщика вы знаете?](#5-какие-алгоритмы-сборщика-вы-знаете)

[6. Чем отличаются сборщики мусора?](#6-чем-отличаются-сборщики-мусора)

[7. Расскажите про утилиты для анализа памяти?](#7-расскажите-про-утилиты-для-анализа-памяти)

[8. Что такое ссылки?](#8-что-такое-ссылки)

[9. Какие типы ссылок Вы знаете?](#9-какие-типы-ссылок-вы-знаете)

[10. Чем эти ссылки отличаются?](#10-чем-эти-ссылки-отличаются)

[11. Расскажите про String pool и Integer pool (Integer cache).](#11-расскажите-про-string-pool-и-integer-pool-integer-cache)

[12. Расскажите о методе String.intern().](#12-расскажите-о-методе-stringintern)

[13. Расскажите, что такое профайлер.](#13-расскажите-что-такое-профайлер)

[14. Расскажите, как использовать VisualVM.](#14-расскажите-как-использовать-visualvm)

[15. Расскажите, чем отличается sampling от profiling? (Это типы аудита. Режим работы в профайлере)](#15-расскажите-чем-отличается-sampling-от-profiling-это-типы-аудита-режим-работы-в-профайлерерасскажите-чем-отличается-sampling-от-profiling-это-типы-аудита-режим-работы-в-профайлере)

[16. Расскажите о методе finalize().](#16-расскажите-о-методе-finalize)

[17. Расскажите о методе clone(). Что такое Deep clone and Shallow clone?](#17-расскажите-о-методе-clone-что-такое-deep-clone-and-shallow-clone)

[18. Расскажите о Stack, Heap и Metaspace.](#18-расскажите-о-stack-heap-и-metaspace)

[19. Что такое ClassLoader? Перечислите основные реализации ClassLoader.](#19-что-такое-classloader-перечислите-основные-реализации-classloader)

[20. Расскажите иерархию штатных загрузчиков классов в Java. Какой загрузчик находится в корне иерархии?](#20-расскажите-иерархию-штатных-загрузчиков-классов-в-java-какой-загрузчик-находится-в-корне-иерархии)

[21. Какой загрузчик классов нельзя получить методом getClassLoader()? Почему?](#21-какой-загрузчик-классов-нельзя-получить-методом-getclassloader-почему)

[22. Расскажите алгоритм поиска и загрузки класса в JVM.](#22-расскажите-алгоритм-поиска-и-загрузки-класса-в-jvm)

# 1. Чем Java отличается от C++?

+ В C++ выделение и освобождение памяти - это ручной процесс (например, с помощью операторов new и delete).
+ В Java процесс освобождения памяти автоматически обрабатывается сборщиком мусора. (освобождает память в куче, занятой
  неиспользуемыми объектами)
  Т.е. в отличие от С++ нет явной необходимости уничтожать объект.

[К оглавлению](#GC)

# 2. Что такое менеджер памяти?

**Менеджер памяти** — часть компьютерной программы (как прикладной, так и операционной системы),
обрабатывающая запросы на выделение и освобождение оперативной памяти
или (для некоторых архитектур ЭВМ) запросы на включение заданной области памяти в адресное пространство процессора.

Основное назначение менеджера памяти в первом смысле — реализация динамической памяти, т.е.
выделение оперативной памяти компьютера для объектов в программе осуществляется во время ее выполнения.

Менеджеры памяти часто образуют иерархию, т.е. нижестоящие менеджеры задействуют какие-либо закономерности
выделения-освобождения
памяти и этим снижают нагрузку на вышестоящие. Например:

+ Системный - менеджер памяти, встроенный в ОС.
+ Принадлежащий процессу - менеджер памяти, встроенный в стандартную библиотеку языка программирования,
  берёт у ОС блоки памяти «оптом» и раздаёт их сообразно с нуждами программиста.
+ Специализированные - некоторые динамические структуры данных, например, `vector`,
  также берут память у стандартной библиотеки с запасом (обычно, блоками экспоненциально увеличивающегося размера).

Подобная иерархия приводит к тому, что на каждом из уровней «залёживается» свободная память.
Но это оправдано: снижается фрагментация памяти и повышается скорость.

[К оглавлению](#GC)

# 3. Какой механизм используется в Java для управления памятью?

Сборка мусора выполняется сборщиком мусора (Garbage Collector (GC)). GC – часть JVM,
прикладная программа, которая занимается очищением памяти. Прежде чем удалить объект, нужно знать, где он находится:

+ Важное отступление, выбор «поколенческой» (generational) модели памяти сделан не спроста. Опытным путем было доказано,
  что большинство объектов не живут долго. Это заключение, позволяет сделать young generation небольшим, а в old
  generation хранить объекты действительно «живущие» дольше обычного, тем самым эффективно использовать память.
  ![img](https://github.com/itlazykin/answers_to_exam_questions/blob/main/main/resources/meminjava.png)

#### Структура памяти в JVM:

+ Stack (Не управляется сборщиком мусора)
    + Permanent Generation — содержит необходимые для управления программой метаданные классов,
      в том числе метаданные о созданных объектах, методах и т.п.
    + Code Cache — используемая JVM память при включенной JIT-компиляции
      (в этой области памяти кешируется скомпилированный платформенно-зависимый код)

+ Heap - куча (тут работает GC)
    + New (Yang) Generation - хранит короткоживущие объекты.
        + Eden Space — сюда распределяются среднестатистические объекты*. Если нет места запускается малая сборка
          мусора (minor GC).
        + Survivor Space — точнее их два, S1 и S2, и они меняются ролями.
          Хранятся перемещенные из Eden Space объекты, признанные живыми во время сборки мусора (без разницы малой или
          полной).
          Объекты, пережившие несколько сборок мусора, перемещаются в следующую сборку Tenured Generation.
    + Old (Tenured) Generation - хранит долгоживущие объекты. Когда данная область памяти заполняется,
      выполняется полная сборка мусора (full GC).

#### Как сборщик мусора понимает, какие объекты нужно удалить?

Основным фактором здесь выступает тип ссылки. GC видит, что мы используем «обычные» ссылки. Далее он смотрит на
достижимость объекта по ссылке. Это значит, что если мы не можем получить к нему доступ из программы, т.е. у нас нет
ссылки на него, то он помечается как мусор и будет удален при следующей сборке мусора.

#### Сборка мусора

Сборка мусора происходит, когда заполнена вся область памяти. Память делится на два поколения, поэтому есть два типа
сборки мусора: minor GC и major GC. Первый происходит, когда переполняется young generation, второй, когда переполняется
область из old generation.

#### Стадии, которые проходят объекты до сборки мусора.

1. Объект рождается. Во время исполнения JVM видит, что стоит оператор new. Происходит выделение памяти под объект и
   возврат ссылки, которая будет ссылаться на занятый участок памяти. Все объекты рождаются в eden
   ![img](https://github.com/itlazykin/answers_to_exam_questions/blob/main/main/resources/mem1.png)
2. Этап 1 выполняет до тех пор, пока не будет заполнен eden. Когда eden заполнен происходит minor GC(малая сборка
   мусора) — это процесс в сборке мусора в Java, который запускается, когда область памяти Young Generation (молодое
   поколение) заполняется.
   ![img](https://github.com/itlazykin/answers_to_exam_questions/blob/main/main/resources/mem2.png)
3. Объекты, у которых уже нет ссылки удаляются
   ![img](https://github.com/itlazykin/answers_to_exam_questions/blob/main/main/resources/mem3.png)
4. Объекты, у которых есть ссылки попадают в survivor space из eden. Причем survivor space делиться на две части. Между
   этими частями происходит перемещения объектов. В один момент времени одна из частей пуста, чтоб мочь вместить объекты
   пришедшие из eden.
   ![img](https://github.com/itlazykin/answers_to_exam_questions/blob/main/main/resources/mem4.png)
5. Объекты, которые уже были в одной части survivor space, перемещаются в другую, при этом растет их «возраст» (age).
   Сам процесс, перемещения объектов из различных частей survivor space и увеличения их возраста называется
   «взрослением» (aging).
   ![img](https://github.com/itlazykin/answers_to_exam_questions/blob/main/main/resources/mem5.png)
6. бъекты, которые достигли определенного возраста попадают в old generation. Этот процесс называется «продвижением»
   promotion.
   ![img](https://github.com/itlazykin/answers_to_exam_questions/blob/main/main/resources/mem6.png)
7. Этапы 1-6 происходят до тех пока не будет заполнен old generation, причем по ходу будут происходить minor GC, для
   очищения young generation.
8. Когда old generation заполняется производиться major GC
9. Этапы 1-7 происходят на протяжении работы программы

*объекты-акселераты, размер которых настолько велик, что создавать их в Eden,
а потом таскать за собой по Survivor’ам слишком накладно, размещаются сразу в Tenured Generation.

[К оглавлению](#GC)

# 4. Опишите процесс работы сборщика мусора.

см. 3 вопрос :

#### Сборка мусора

#### Стадии, которые проходят объекты до сборки мусора.

[К оглавлению](#GC)

# 5. Какие алгоритмы сборщика вы знаете?

Сборщики мусора различаются относительно характеристик какими они обладают.

+ Последовательное (Serial) vs параллельное (Parallel) исполнение сборки мусора. Для того, чтобы очистить память нужно
  остановить приложение - событие Stop The World.
  Причем сам процесс сборки может быть ускорен за счет использования нескольких процессоров, если они присутствуют
  физически.
  Если мы используем последовательную сборку, то она выполняется только в одном потоке и задействует только один
  процессор, что увеличивает время сборки.
  С другой стороны мы можем использовать несколько процессоров за счет распараллеливания сборки, что уменьшает время
  сборки, ценой затрат ресурсов (процессоров) и некоторых накладных расходов (overhead), требуемых для организации
  работы потоков исполнения (Thread).
+ Параллелизм (Concurrency) vs Stop The World. Еще одним способом уменьшения времени пауз является использование
  параллелизма. Данный подход заключается в том, что сборщик мусора работает одновременно с самим приложением. При этом
  он не ждет пока heap заполнится полностью, он периодически производит "мелкие" сборки.
  Причем эти сборки тоже вызывают событие Stop The World, но по времени оно занимает меньше чем если бы сборщик мусора
  чистил бы полностью heap.
  Использование данного подхода оправдано в системах, где требуется минимальный отклик от приложения и не допустимы
  долгие паузы.
  Однако эти минимальные паузы достигаются за счет того, что сборщик мусора требует heap больше.

#### Виды сборок мусора.

После того как сборщик мусора определил, что нужно удалить объекты, он может пользоваться следующими сборками:
Compacting, Non-compacting and Copying.

+ Compacting (Compact с англ. уплотнить): Собирает "живые" объекты в одном месте и очищает оставшуюся часть памяти, где
  находятся объекты, которые нужно уничтожить.
    + Преимущество такого подхода - легко можно выделять память для новых объектов.
    + Недостаток - требуется время на компоновку объектов в одном месте.
+ Non-compacting. Удаляет объекты по месту. Т.е. он понимает, что данную часть памяти занимает объект, который нужно
  удалить, и чистит эту часть памяти.
    + Преимущество: не нужно производить лишние действия, нужно просто удалить объекты.
    + Недостаток: при создании объекта нужно находить для него подходящее место, что приводит к фрагментации памяти (это
      когда большая часть вашей памяти выделена в большом количестве несмежных блоков, оставляя приличный процент вашей
      общей памяти нераспределенной, но при этом непригодной для большинства типичных сценариев использования памяти),
      то есть много свободных мест памяти между занятыми ячейками, но из-за малых ее размеров, ее практически ничем не
      занять, и эта память простаивает.
+ Copying. Копирует "живые" объекты в отдельную часть памяти, очистив старую часть, где они были (С этим типом вы
  встречались в прошлом задании).
    + Преимущество: нет препятствий выделению памяти.
    + Недостаток: требуется время на копирование.

#### Метрики оценки сборщиков мусора

Для того, чтобы оценить сборщик мусора смотрят на следующие характеристики:

- Throughput (Пропускная способность) - процентное соотношение, показывающее сколько GC может работать БЕЗ полной сборки
  мусора. Формально, (1 - время_на_сборки / общ_время) * 100
- GC Overhead - процентное соотношение, показывающее сколько требуется на времени на сборку. Формально, (
  время_на_сборки / общ_время) * 100
- Pause Time (или Latency) - это время на которое требуется остановить приложение, чтобы произвести сборку мусора
- Frequency of collection - это количество сборок проводимых за все время работы приложения.
- Promptness - это время между началом сборки мусора и моментом, когда память снова становится доступной для размещения
  объектов.
- Footprint - это количество памяти доступное приложению

1. `Serial GC`

+ Назначение: Однопоточный сборщик мусора, подходит для приложений с небольшими кучами и работающих в однопоточной
  среде.
+ Алгоритм:
  Использует копирование (Copying) для Young Generation.
  Маркировка-вычищение-компактификация (Mark-Sweep-Compact) для Old Generation.
+ Особенности:
  Приостанавливает все потоки приложения (Stop-the-World, STW) во время сборки.
  Прост и эффективен для малых куч.
+ Ключ: -XX:+UseSerialGC

2. `Parallel GC` (Throughput Collector)

+ Назначение: Многопоточный сборщик мусора для приложений с высокой пропускной способностью (например, серверные
  приложения).
+ Алгоритм:
  Для Young Generation используется копирование.
  Для Old Generation — маркировка-вычищение-компактификация.
+ Особенности:
  Минимизирует общее время, затраченное на сборку, за счёт использования нескольких потоков.
  Все ещё вызывает паузы STW.
+ Ключ: -XX:+UseParallelGC

3. `CMS (Concurrent Mark-Sweep)`

+ Назначение: Минимизирует паузы, подходит для интерактивных приложений.
+ Алгоритм:
  Использует маркировку и вычищение (Mark-Sweep).
  Выполняет большинство работы одновременно с приложением.
+ Особенности:
  Нет компактификации памяти, что может привести к её фрагментации.
  Устарел, начиная с Java 9, заменён на G1.
+ Ключ: -XX:+UseConcMarkSweepGC

4. `G1 GC (Garbage First GC)`

+ Назначение: Подходит для больших куч и приложений с требованиями к минимальным паузам.
+ Алгоритм:
  Разделяет кучу на регионы.
  Сначала очищает регионы с наибольшим количеством мусора (Garbage First).
  Использует комбинацию маркировки, копирования и компактификации.
+ Особенности:
  Снижает паузы за счёт распределения работы на мелкие порции.
  Частично выполняет сборку параллельно с работой приложения.
+ Ключ: -XX:+UseG1GC

5. `ZGC (Z Garbage Collector)`

+ Назначение: Для приложений с большими кучами (до терабайтов) и строгими требованиями к минимальным паузам.
+ Алгоритм: Использует маркировку и копирование. Работает преимущественно параллельно с приложением.
+ Особенности:
  Паузы обычно не превышают 10 миллисекунд.
  Фрагментация памяти минимальна.
  Требует поддержки современных процессоров.
+ Ключ: -XX:+UseZGC

| GC          | Цель                           | Подходит для                  | Паузы          | Примечания                                     |
|-------------|--------------------------------|-------------------------------|----------------|------------------------------------------------|
| Serial GC   | Однопоточные приложения        | Маленькие кучи                | Длинные        | Serial, Stop The World, Copying                |
| Parallel GC | Высокая пропускная способность | Многопоточные серверы         | Средние        | Parallel, Stop The World, Copying              |
| CMS         | Минимизация пауз               | Реалтайм-приложения           | Средние        | Parallel, Concurrent, Copying. Убран с JDK 14. |
| G1 GC       | Минимизация пауз               | Большие кучи                  | Короткие       | Parallel, Concurrent, Copying. Замена CMS      |
| ZGC         | Минимизация пауз               | Огромные кучи (до терабайтов) | Очень короткие | Parallel, Concurrent, Copying                  |

[К оглавлению](#GC)

# 6. Чем отличаются сборщики мусора?

Сборщики мусора (Garbage Collectors, GC) в Java различаются по тому, как они управляют памятью, устраняют мусор и
минимизируют паузы. Подробно рассмотрено в вопросе 5.

[К оглавлению](#GC)

# 7. Расскажите про утилиты для анализа памяти?

Эти инструменты предоставляются вместе с JDK и подходят для большинства задач по мониторингу и отладке:

+ jconsole. Графический инструмент для мониторинга приложений Java в реальном времени.
    + Возможности: Просмотр использования кучи и метапространства. Отслеживание работы сборщика мусора. Мониторинг
      потоков. Работа с JMX (Java Management Extensions).

````java
Пример запуска:

C:\User\jconsole
````    
+ jvisualvm. Универсальный инструмент с поддержкой плагинов для анализа производительности и памяти.
    + Возможности: Мониторинг использования памяти. Снимки кучи (heap dump). Анализ утечек памяти. Профилирование кода.
```java
Пример запуска:

C:\User\jvisualvm
```
+ jmap Инструмент для работы с дампами памяти.
    + Возможности: Снятие снимков кучи. Получение информации об объектах и класлах в памяти.
```java
Пример запуска:

jmap -dump:format=b,file=heap_dump.hprof <pid>
```
jhat
Что это: Анализатор дампов памяти (устаревший, заменён сторонними утилитами).
Возможности:
Анализ объектов в куче через веб-интерфейс.
Пример запуска:
Копировать код
jhat heap_dump.hprof
jcmd
Что это: Универсальный инструмент для управления JVM.
Возможности:
Запрос текущей статистики памяти.
Снятие снимков кучи.
Мониторинг работы GC.
Пример запуска:
php
Копировать код
jcmd <pid> GC.heap_dump heap_dump.hprof

[К оглавлению](#GC)

# 8. Что такое ссылки?

[К оглавлению](#GC)

# 9. Какие типы ссылок Вы знаете?

[К оглавлению](#GC)

# 10. Чем эти ссылки отличаются?

[К оглавлению](#GC)

# 11. Расскажите про String pool и Integer pool (Integer cache).

[К оглавлению](#GC)

# 12. Расскажите о методе String.intern().

[К оглавлению](#GC)

# 13. Расскажите, что такое профайлер.

[К оглавлению](#GC)

# 14. Расскажите, как использовать VisualVM.

[К оглавлению](#GC)

# 15. Расскажите, чем отличается sampling от profiling? (Это типы аудита. Режим работы в профайлере)Расскажите, чем отличается sampling от profiling? (Это типы аудита. Режим работы в профайлере)

[К оглавлению](#GC)

# 16. Расскажите о методе finalize().

[К оглавлению](#GC)

# 17. Расскажите о методе clone(). Что такое Deep clone and Shallow clone?

[К оглавлению](#GC)

# 18. Расскажите о Stack, Heap и Metaspace.

[К оглавлению](#GC)

# 19. Что такое ClassLoader? Перечислите основные реализации ClassLoader.

[К оглавлению](#GC)

# 20. Расскажите иерархию штатных загрузчиков классов в Java. Какой загрузчик находится в корне иерархии?

[К оглавлению](#GC)

# 21. Какой загрузчик классов нельзя получить методом getClassLoader()? Почему?

[К оглавлению](#GC)

# 22. Расскажите алгоритм поиска и загрузки класса в JVM.

[К оглавлению](#GC)
