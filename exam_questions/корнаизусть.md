# КорНаизусть

[Иерархия коллекций](#иерархия-коллекций)

[Сравнить ArrayList и LinkedList, области применения, как происходит вставка в середину](#сравнить-arraylist-и-linkedlist-области-применения-как-происходит-вставка-в-середину)

[Что такое Set, его реализации, как внутри работает механизм уникальности элементов](#что-такое-set-его-реализации-как-внутри-работает-механизм-уникальности-элементов)

[Что такое HashMap и её внутренне устройство (как можно подробнее)](#что-такое-hashmap-и-её-внутренне-устройство-как-можно-подробнее)

[Какие критерии должен соблюдать объект чтобы использовать его в качестве ключа в мапе](#какие-критерии-должен-соблюдать-объект-чтобы-использовать-его-в-качестве-ключа-в-мапе)

[Как сделать объект иммутабельным](#как-сделать-объект-иммутабельным)

[Конструктор копирования](#конструктор-копирования)

[Методы из collections](#методы-из-collections)

[Алгоритмы сортировки и их сложность, какая сортировка используется в java](#алгоритмы-сортировки-и-их-сложность-какая-сортировка-используется-в-java)

[Стримы, типы методов в стримах](#стримы-типы-методов-в-стримах)

[Что такое функциональные интерфейсы, примеры функциональных интерфейсов](#что-такое-функциональные-интерфейсы-примеры-функциональных-интерфейсов)

[Какие функциональные интерфейсы используются в стримах](#какие-функциональные-интерфейсы-используются-в-стримах)

[Как работает метод filter() в стримах](#как-работает-метод-filter-в-стримах)

[Что делает метод map() в стримах](#что-делает-метод-map-в-стримах)

[Чем flatMap() отличается от map() в стримах](#чем-flatmap-отличается-от-map-в-стримах)

[Исключения, практический пример обработки исключения](#исключения-практический-пример-обработки-исключения)

[Как создать свое исключение](#)

[Зачем разработчики java придумали checked исключения](#)

[Расскажите про методы Object hashCode и equals?](#расскажите-про-методы-object-hashcode-и-equals)

# Иерархия коллекций

Collection<E> — это базовый интерфейс для всех коллекций, за исключением Map. Он включает в себя методы для добавления,
удаления элементов и их проверки.

List<E> — коллекция с упорядоченными элементами, которая допускает дубликаты. Примеры:

+ ArrayList — динамический массив, быстрый доступ по индексу.
+ LinkedList — двусвязный список, эффективен при вставке/удалении в середине.

Set<E> — коллекция, которая не допускает дубликатов. Примеры:

+ HashSet — неупорядоченная коллекция, основанная на хешировании.
+ TreeSet — отсортированное множество, элементы хранятся в порядке возрастания.

Queue<E> — коллекция, представляющая очередь, обычно с операциями добавления в конец и извлечения из начала. Пример:

+ PriorityQueue — очередь с приоритетами.

Map<K, V> — это структура данных для хранения пар "ключ-значение", которая не является наследником Collection, но также
является частью коллекций. Примеры:

+ HashMap — хранит пары ключ-значение, быстрый поиск по ключу.
+ TreeMap — отсортированное по ключам хранилище пар ключ-значение.

В 21 джаве были добавлены три новых интерфейса:

+ `SequencedCollection` - расширяет Collection и добавляет методы для работы с элементами в начале и конце коллекции.
+ `SequencedSet` - специализированный интерфейс для Set, которые сохраняют порядок элементов. Он также предоставляет
  методы для работы с первым и последним элементами
+ `SequencedMap` - интерфейс расширяет Map и добавляет методы для работы с первым и последним элементами в отображении.

[К оглавлению](#КорНаизусть)

# Сравнить ArrayList и LinkedList, области применения, как происходит вставка в середину

— ArrayList реализован внутри в виде обычного массива.
Поэтому при вставке элемента в середину, приходится сначала сдвигать на один все элементы после него, а уже затем в
освободившееся место вставлять новый элемент.
Зато в нем быстро реализованы поиск и изменение элемента – операции get, set, так как в них мы просто обращаемся
к соответствующему элементу массива.

— LinkedList реализован внутри по-другому.
Он реализован в виде двух - связного списка: набора отдельных элементов, каждый из которых хранит ссылку на следующий и
предыдущий элементы. Чтобы вставить элемент в середину такого списка, достаточно поменять ссылки его будущих соседей.
Чтобы получить элемент с номером 200 из 500 элетментов, нужно пройтись последовательно по всем объектам от 0 до 200.
Другими словами операции set и get тут реализованы очень медленно

LinkedList требует больше памяти для хранения такого же количества элементов, потому что кроме
самого элемента хранятся еще указатели на следующий и предыдущий элементы списка, тогда как в ArrayList элементы просто
идут по порядку

LinkedList предпочтительно применять, когда нужны частые операции вставки/удаления или в случаях, когда необходимо
гарантированное время добавления элемента в список.
В остальных случаях ArrayList.

[К оглавлению](#КорНаизусть)

# Что такое Set, его реализации, как внутри работает механизм уникальности элементов

Set — это коллекция, которая хранит уникальные элементы. Она не допускает дубликатов, и порядок элементов не
гарантирован (за исключением некоторых реализаций).

#### Реализации Set:

HashSet

+ На основе хеширования.
+ Быстрый поиск, добавление и удаление элементов (O(1) в среднем).
+ Не гарантирует порядок элементов, так как использует хеш-функцию для хранения.

LinkedHashSet

+ Основан на HashSet, но поддерживает порядок вставки.
+ Хранит элементы в том порядке, в котором они были добавлены.

TreeSet

+ Основан на красно-черном дереве (структура данных).
+ Хранит элементы в отсортированном порядке (по умолчанию по возрастанию, можно задать свой компаратор).
+ Вставка, удаление и поиск занимают O(log n).

#### Как работает механизм уникальности элементов в Set?

Каждый элемент в Set должен быть уникальным, что обеспечивается с помощью метода equals() и hashCode():

+ Когда добавляется новый элемент, коллекция сначала вычисляет его хеш-код с помощью hashCode().
+ Если элемент с таким хеш-кодом уже существует, вызывается метод equals() для сравнения объектов.
+ Если элементы равны (метод equals() возвращает true), новый элемент не добавляется.

Пример:

+ В HashSet два элемента считаются одинаковыми, если их хеш-коды совпадают и методы equals() возвращают true.
+ В TreeSet: Использует Comparable или Comparator для сравнения элементов. Если результат сравнения равен 0, элемент
  считается дубликатом и не добавляется.

[К оглавлению](#КорНаизусть)

# Что такое HashMap и её внутренне устройство (как можно подробнее)

HashMap — это реализация интерфейса Map, которая хранит данные в виде пар "ключ-значение". Она позволяет быстро
добавлять, удалять и искать элементы по ключу. Ключи в HashMap уникальны, а значения могут дублироваться.
Порядок элементов не гарантируется, если добавляется дубликат ключа, старое значение заменяется новым,
можно использовать null как ключ и как значение, в среднем операции добавления, удаления и поиска выполняются за O(1).

#### Устройство HashMap

HashMap состоит из «корзин» (bucket). С технической точки зрения «корзины» — это элементы массива, которые хранят ссылки
на списки элементов. При добавлении новой пары «ключ-значение», вычисляет хэш-код ключа, на основании которого
вычисляется номер корзины (номер ячейки массива), в которую попадет новый элемент. Если корзина пустая, то в нее
сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, то происходит последовательный переход по
ссылкам между элементами в цепочке, в поисках последнего элемента, от которого и ставится ссылка на вновь добавленный
элемент. Если в списке был найден элемент с таким же ключом, то он заменяется.

#### Процесс увеличения размера (resize)

Когда выполняется:

+ Когда количество элементов превышает порог (threshold), вычисляемый как capacity * loadFactor.

Что происходит:

+ Создаётся новый массив с удвоенной ёмкостью.
+ Все элементы копируются в новый массив.
+ Индексы пересчитываются, так как длина массива изменилась.

Основные поля объекта hashmap:

+ Node<K, V>[] table: Массив типа Entry[], для хранения пар ключ-значение.
+ int size: Текущее количество элементов в HashMap.
+ float loadFactor: Коэффициент загрузки, определяющий, когда массив должен быть увеличен(по умолчанию 0.75)
+ int threshold: Предельное количество элементов, при достижении которого, размер хэш-таблицы увеличивается вдвое.
  Рассчитывается по формуле (capacity * loadFactor);

Класс Node:

+ Каждая запись представлена объектом Node, который содержит:
+ int hash: Хэш-код ключа.
+ K key: Ключ.
+ V value: Значение.
+ Node<K, V> next: Ссылка на следующий элемент в случае коллизии

#### Как работает HashMap

1. Добавление элемента (put)

Метод hashCode() ключа вычисляет целочисленный хэш-код.
Этот хэш-код преобразуется в индекс массива с использованием операции побитового AND.

Хэш-код делится на длину массива, чтобы определить индекс бакета (ячейки).

Если бакет пуст, элемент добавляется напрямую.
Если бакет уже содержит элементы (коллизия), происходит:

+ Поиск существующего ключа.
+ Если ключ совпадает, значение обновляется.
+ Если ключ уникален, новый узел добавляется в конец связного списка или дерева.

2. Поиск элемента (get)

Вычисляется хэш-код ключа, который преобразуется в индекс массива.

В указанном бакете ищется ключ, используя метод equals().

+ Если ключ найден, возвращается значение.
+ Если ключ отсутствует, возвращается null.

3. Удаление элемента (remove)

Вычисляется индекс бакета для удаления.

Поиск ключа с помощью метода equals()

Если элемент найден:

+ Удаляется узел.
+ Ссылки обновляются (если использовался связный список).

[К оглавлению](#КорНаизусть)

# Какие критерии должен соблюдать объект чтобы использовать его в качестве ключа в мапе

Необходимо:

Переопределять методы equals() и hashCode()

+ Метод hashCode() должен возвращать одно и то же значение для одного и того же объекта при каждом вызове
+ Метод equals() должен правильно определять, являются ли два объекта равными
+ Если два объекта считаются равными (equals() возвращает true), то их хеш-коды (hashCode()) тоже должны совпадать

Объект не должен изменяться после добавления в Map, те ключ должен быть иммутабельным.

[К оглавлению](#КорНаизусть)

# Как сделать объект иммутабельным

Чтобы создать иммутабельный объект, нужно соблюсти несколько правил:

+ Класс должен быть final, чтобы предотвратить его наследование. Это важно, чтобы не было возможности изменить поведение
  объекта через подклассы.
+ Поля объекта должны быть private final только для чтения. Это гарантирует, что значения этих полей могут быть
  присвоены
  только один раз — в конструкторе.
+ Поля должны быть инициализированы только через конструктор, и не должно быть сеттеров, которые позволяют изменять их
  после создания объекта.

[К оглавлению](#КорНаизусть)

# Конструктор копирования

Конструктор копирования — это конструктор, который создаёт новый объект на основе существующего, копируя значения его
полей. Это особенно полезно, когда нужно создать новый объект с теми же значениями, но не изменить исходный объект.

[К оглавлению](#КорНаизусть)

# Методы из collections

Главным набором методов, который важен при рассмотрении любой коллекции является набор CRUD-операций (create, read,
update, delete). На уровне Collection не существует способа обновить запись в коллекции

- add(Object o) - добавляет элемент в коллекцию.
- iterator() - возвращает итератор для перебора элементов коллекции.
- remove(Object o) - удаляет элемент из коллекции.
- contains(Object o) - проверяет, есть ли элемент в коллекции.
- size() - возвращает количество элементов в коллекции.
- clear() - очищает коллекцию (удаляет все элементы).
- toArray() - возвращает массив, содержащий все элементы коллекции

[К оглавлению](#КорНаизусть)

# Алгоритмы сортировки и их сложность, какая сортировка используется в java

Сортировка пузырьком (Bubble Sort): Простой, но неэффективный метод сортировки. В каждом проходе он сравнивает соседние
элементы и меняет их местами, если они в неправильном порядке. Процесс повторяется, пока все элементы не окажутся в
нужном порядке.

+ В худшем и среднем случае: O(n²)
+ В лучшем случае (если список уже отсортирован): O(n)

Сортировка вставками (Insertion Sort): Проходит по списку, вставляя каждый элемент в правильную позицию в уже
отсортированную часть списка. Эффективен для небольших или почти отсортированных данных.

+ В худшем и среднем случае: O(n²)
+ В лучшем случае (если список уже отсортирован): O(n)

Сортировка выбором (Selection Sort): Находит минимальный (или максимальный) элемент в списке и меняет его местами с
первым элементом. Затем повторяет процесс для оставшейся части списка.

+ В худшем и среднем случае: O(n²)

Сортировка слиянием (Merge Sort): Разделяет массив пополам и рекурсивно сортирует каждую половину, затем соединяет их
обратно в отсортированный массив.

+ В худшем, среднем и лучшем случае: O(n log n)

Быстрая сортировка (Quick Sort): Выбирается опорный элемент, массив разделяется на элементы, меньшие и большие опорного,
затем
процесс рекурсивно повторяется для каждой из частей.

+ В худшем случае: O(n²) (когда выбор опорного элемента неудачный)
+ В среднем случае: O(n log n)

В java для сортировки используется Timsort, для примитивных типов Dual-Pivot Quick Sort.
Dual-Pivot Quick Sort — сортировки, который используется в Java для примитивных
типов. Он быстрее классического Quick Sort благодаря использованию двух опорных элементов и более эффективному
разделению массива.(массив делится на 3 части, а у быстрой сортировки на 2)

Timsort — это гибридный алгоритм сортировки, который сочетает в себе идеи сортировки вставками (Insertion Sort) и
сортировки слиянием (Merge Sort).

+ Использует сортировку вставками для небольших подмассивов (так как она эффективна для малых данных).

+ Использует сортировку слиянием для объединения отсортированных подмассивов (так как она эффективна для больших данных
  и устойчива).

[К оглавлению](#КорНаизусть)

# Стримы, типы методов в стримах

Стримы в Java — это способ обработки коллекций и данных в функциональном стиле. Стримы позволяют выполнять различные
операции, такие как фильтрация, сортировка, агрегация и преобразование данных, не изменяя исходные коллекции.

Методы стримов делятся на два типа:

+ Промежуточные операции (intermediate operations): Это операции, которые возвращают новый стрим и выполняются "
  лениво" (то есть только когда начинается терминальная операция). Пример: filter(), map(), distinct(), sorted(),
  flatMap().

+ Конечные операции (terminal operations): Это операции, которые завершает обработку стрима и возвращают результат,
  например, коллекцию или агрегированное значение. Пример: collect(), forEach(), count(), min(), max().

Основные моменты:

+ Стримы не изменяют исходные данные, а возвращают новый результат.
+ Промежуточные операции выполняются только тогда, когда вызывается конечная операция.

[К оглавлению](#КорНаизусть)

# Что такое функциональные интерфейсы, примеры функциональных интерфейсов

Функциональный интерфейс — это интерфейс с одним абстрактным методом. Он может иметь несколько методов по умолчанию (
default) или статических методов, но только один абстрактный. Функциональные интерфейсы активно используются в
лямбда-выражениях, что делает код более компактным

Comparator<T>:
Интерфейс для сравнения объектов. Он имеет один абстрактный метод compare(), который принимает два объекта и возвращает
целое число, которое указывает на их порядок.

Function<T, R>:
Функциональный интерфейс, который принимает объект типа T и возвращает объект типа R.

Predicate<T>:
Интерфейс для логических выражений, который принимает объект типа T и возвращает boolean.

Supplier<T>:
Интерфейс, который не принимает аргументов, но возвращает результат типа T.

Consumer<T>:
Интерфейс, который принимает объект типа T и не возвращает значения.

[К оглавлению](#КорНаизусть)

# Какие функциональные интерфейсы используются в стримах

+ Predicate<T> — используется для фильтрации элементов стрима (метод filter()).
+ Function<T, R> — применяется для преобразования элементов стрима (методы map(), flatMap()).
+ Consumer<T> — используется для выполнения действия над элементами (метод forEach()).
+ Supplier<T> — применяется в методах, генерирующих элементы, например, generate().
+ UnaryOperator<T> — используется в map() для выполнения операций над элементами одного типа.
+ BinaryOperator<T> — применяется в методах агрегации, например, reduce().
+ Comparator<T> — используется для сортировки элементов стрима (метод sorted()).

[К оглавлению](#КорНаизусть)

# Как работает метод filter() в стримах

+ Метод filter() работает по принципу ленивых вычислений, то есть элементы фильтруются только при реальном вызове
  терминальных операций, таких как collect(), forEach().
+ filter() не изменяет исходный стрим, а возвращает новый.
+ Фильтрация происходит на основе предиката, который является условием, по которому элементы либо проходят, либо
  отбрасываются.
  [К оглавлению](#КорНаизусть)

# Что делает метод map() в стримах

+ map() используется для преобразования элементов в стриме.
+ Этот метод не изменяет исходный стрим, а создаёт новый с преобразованными элементами.
  Он работает лениво, что означает, что элементы преобразуются только при необходимости (например, когда вызывается
  терминальная операция).
+ map() может быть полезен для таких задач, как преобразование типов (например, из строки в число) или изменение
  значений
  в коллекции.

[К оглавлению](#КорНаизусть)

# Чем flatMap() отличается от map() в стримах

+ map(): каждый элемент преобразуется в один новый элемент.
+ flatMap(): каждый элемент может быть преобразован в несколько элементов (например, коллекцию или стрим), которые
  распрямляются в один плоский стрим.
+ flatMap() полезен для работы с вложенными структурами, такими как коллекции внутри коллекций или стримы внутри
  стримов.

[К оглавлению](#КорНаизусть)

# Исключения, практический пример обработки исключения

![exceptions_hierarchy_1.png](../main/resources/exceptions_hierarchy_1.png)
Исключения — это события, которые возникают во время выполнения программы и нарушают её нормальную работу. Это могут
быть ошибки ввода-вывода, деление на ноль, отсутствие файла и т.д. В Java исключения делятся на два типа:

+ Проверяемые исключения (Checked exceptions) — это исключения, которые компилятор требует обработать. Например,
  IOException, SQLException.
+ Непроверяемые исключения (Unchecked exceptions) — это исключения, которые не требуют обязательной обработки. Это
  ошибки времени выполнения, такие как NullPointerException, ArrayIndexOutOfBoundsException.

+ Обработка исключений помогает сделать программу более надёжной, предотвращая её аварийное завершение.
+ finally гарантирует выполнение кода, связанного с освобождением ресурсов.
+ try-catch используется для обработки различных исключений, что позволяет программе продолжать работу в случае ошибок,
  а не завершаться с аварийным завершением.

```java
import java.io.*;

public class Example {
    public static void main(String[] args) {
        try {
            FileReader reader = new FileReader("file.txt");
            int data = reader.read();
            reader.close();
        } catch (FileNotFoundException e) {
            System.out.println("Файл не найден: " + e.getMessage());
        } catch (IOException e) {
            System.out.println("Ошибка ввода-вывода: " + e.getMessage());
        } finally {
            System.out.println("Блок finally выполнен.");
        }
    }
}

В данном
примере,
если файл
file.txt не
найден,
будет выброшено
исключение FileNotFoundException,
и оно
будет обработано
в соответствующем
блоке catch.
Блок finally
        выполняется всегда, независимо
от того,
было исключение
        или нет, и
его обычно
используют
для освобождения
ресурсов,например,
закрытия файлов
или соединений."
```

[К оглавлению](#КорНаизусть)

# Как создать свое исключение

Чтобы создать собственное исключение в Java, нужно создать класс, который наследует от Exception или RuntimeException.
Если исключение должно быть проверяемым, мы наследуем от Exception, а если оно может быть непроверяемым, то от
RuntimeException.

[К оглавлению](#КорНаизусть)

# Зачем разработчики java придумали checked исключения

Checked исключения были введены в Java, чтобы заставить разработчиков явно обрабатывать ошибки, которые могут возникнуть
в процессе работы программы, например, при работе с внешними ресурсами (файлы, базы данных, сеть). Это помогает улучшить
надежность программы, так как ошибки, которые могут быть предсказуемыми, обязательно будут обработаны, и разработчик не
забудет их учесть.

Основной принцип заключается в том, что, если есть вероятность ошибки в процессе выполнения, например, при работе с
файлом, с сетью или базой данных, то Java требует, чтобы мы явно обработали такие ошибки, чтобы избежать неожиданных
сбоев или аварийного завершения программы. Это повышает предсказуемость и стабильность приложения

[К оглавлению](#КорНаизусть)

# Расскажите про методы Object hashCode и equals?

Методы, необходимые для определения равенства объектов.
Метод `hashCode()` используется для числового представления объекта, метод `equals()` для сравнения двух объектов.
HashCode() и equals() взаимосвязаны, используются для определения равенства между объектами.

Сначала вычисляется hashCode() объектов, тк эта операция быстрее equals(). Если hashCode равны, то начинается проверка
на equals.
Если hashCode не равны, то дальнейшая проверка на равенство не проводится.

#### Правила equals

- Объект должен быть равен самому себе: `x.equals(x) == true`
- Если x.equals(y) возвращает true, то y.equals(x) также должен возвращать true: `x.equals(y) == y.equals(x)`
- Если x.equals(y) и y.equals(z) возвращают true, то x.equals(z) также должен возвращать true:
  `if (x.equals(y) && y.equals(z)) then x.equals(z) == true`
- Метод equals должен всегда возвращать одно и то же значение, если объекты не изменяются: `x.equals(y) == x.equals(y)`
- Любой объект должен быть не равен null: `x.equals(null) == false`

#### Контракт equals + hashcode:

- Если два объекта равны по equals, их hashCode должен быть одинаковым:
  `if (x.equals(y)) then x.hashCode() == y.hashCode()` Важно: Обратное не обязательно. Объекты с одинаковым hashCode
  могут быть неравными по equals.
- Метод hashCode должен всегда возвращать одно и то же значение, если объект не изменяется:
  `x.hashCode() == x.hashCode()`
- Разные объекты могут иметь одинаковый. Это называется коллизией. Хэш-таблицы умеют обрабатывать коллизии, но слишком
  много коллизий снижает производительность.

Какова роль equals() и hashCode() в HashMap?
hashCode позволяет определить корзину для поиска элемента, а equals используется для сравнения ключей элементов в списке корзины и искомого ключа.

[К оглавлению](#КорНаизусть)
