# КорНаизусть

[Иерархия коллекций](#иерархия-коллекций)

[Сравнить ArrayList и LinkedList, области применения, как происходит вставка в середину](#сравнить-arraylist-и-linkedlist-области-применения-как-происходит-вставка-в-середину)

[Что такое Set, его реализации, как внутри работает механизм уникальности элементов](#что-такое-set-его-реализации-как-внутри-работает-механизм-уникальности-элементов)

[Что такое HashMap и её внутренне устройство (как можно подробнее)](#что-такое-hashmap-и-её-внутренне-устройство-как-можно-подробнее)

[Методы из collections](#методы-из-collections)

[Стримы, типы методов в стримах](#стримы-типы-методов-в-стримах)

[Как работает метод filter() в стримах](#как-работает-метод-filter-в-стримах)

[Что делает метод map() в стримах](#что-делает-метод-map-в-стримах)

[Чем flatMap() отличается от map() в стримах](#чем-flatmap-отличается-от-map-в-стримах)

[Расскажите про методы Object hashCode и equals?](#расскажите-про-методы-object-hashcode-и-equals)

[Что такое дженерики? Для чего нужны?](#что-такое-дженерики-для-чего-нужны)

[Что такое лямбда выражение? Чем его можно заменить](#что-такое-лямбда-выражение-чем-его-можно-заменить)

# Иерархия коллекций

![Collections.png](../main/resources/Collections.png)

Collection<E> — это базовый интерфейс для всех коллекций, за исключением Map. Он включает в себя методы для добавления,
удаления элементов и их проверки.

List<E> — коллекция с упорядоченными элементами, которая допускает дубликаты. Примеры:

+ ArrayList — динамический массив, быстрый доступ по индексу.
+ LinkedList — двусвязный список, эффективен при вставке/удалении в середине.

Set<E> — коллекция, которая не допускает дубликатов. Примеры:

+ HashSet — неупорядоченная коллекция, основанная на хешировании.
+ TreeSet — отсортированное множество, элементы хранятся в порядке возрастания.

Queue<E> — коллекция, представляющая очередь, обычно с операциями добавления в конец и извлечения из начала. Пример:

+ PriorityQueue — очередь с приоритетами.

Map<K, V> — это структура данных для хранения пар "ключ-значение", которая не является наследником Collection, но также
является частью коллекций. Примеры:

+ HashMap — хранит пары ключ-значение, быстрый поиск по ключу.
+ TreeMap — отсортированное по ключам хранилище пар ключ-значение.

В 21 джаве были добавлены три новых интерфейса:

+ `SequencedCollection` - расширяет Collection и добавляет методы для работы с элементами в начале и конце коллекции.
+ `SequencedSet` - специализированный интерфейс для Set, которые сохраняют порядок элементов. Он также предоставляет
  методы для работы с первым и последним элементами
+ `SequencedMap` - интерфейс расширяет Map и добавляет методы для работы с первым и последним элементами в отображении.

[К оглавлению](#КорНаизусть)

# Сравнить ArrayList и LinkedList, области применения, как происходит вставка в середину

— ArrayList реализован внутри в виде обычного массива.
Поэтому при вставке элемента в середину, приходится сначала сдвигать на один все элементы после него, а уже затем в
освободившееся место вставлять новый элемент.
Зато в нем быстро реализованы поиск и изменение элемента – операции get, set, так как в них мы просто обращаемся
к соответствующему элементу массива.

— LinkedList реализован внутри по-другому.
Он реализован в виде двух - связного списка: набора отдельных элементов, каждый из которых хранит ссылку на следующий и
предыдущий элементы. Чтобы вставить элемент в середину такого списка, достаточно поменять ссылки его будущих соседей.
Чтобы получить элемент с номером 200 из 500 элетментов, нужно пройтись последовательно по всем объектам от 0 до 200.
Другими словами операции set и get тут реализованы очень медленно

LinkedList требует больше памяти для хранения такого же количества элементов, потому что кроме
самого элемента хранятся еще указатели на следующий и предыдущий элементы списка, тогда как в ArrayList элементы просто
идут по порядку

Если часто вставляете/удаляете элементы - выбирайте в пользу LinkedList, в противном случае ArrayList

[К оглавлению](#КорНаизусть)

# Что такое Set, его реализации, как внутри работает механизм уникальности элементов

Set — это коллекция, которая хранит уникальные элементы. Она не допускает дубликатов, и порядок элементов не
гарантирован (за исключением некоторых реализаций).

#### Реализации Set:

HashSet

+ HashSet использует HashMap для хранения элементов
+ Быстрый поиск, добавление и удаление элементов (O(1) в среднем).
+ Не гарантирует порядок элементов, так как использует хеш-функцию для хранения.

LinkedHashSet

+ Основан на HashSet, но поддерживает порядок вставки.
+ Хранит элементы в том порядке, в котором они были добавлены.

TreeSet

+ Основан на красно-черном дереве (структура данных).
+ Хранит элементы в отсортированном порядке (по умолчанию по возрастанию, можно задать свой компаратор).
+ Вставка, удаление и поиск занимают O(log n).

#### Как работает механизм уникальности элементов в Set?

HashSet использует HashMap под капотом: объекты являются ключами, а вместо значений используется константа-заглушка. Поэтому алгоритм добавления идентичен HashMap (элемент HashSet == ключ HashMap)

+ Вычисляем хэш-код объекта и бакет, в который будем добавлять объект
+ Если бакет пустой — объект добавляется в бакет, если нет:
  + идем по ключам элементов связного списка (или TreeMap) и сравниваем с добавляемым объектом по хеш-коду и equals()
  + если ключ элемента и объект равны — добавление игнорируется, если нет — переходим к следующему элементу
  + если совпадений не найдено — добавляем объект в конец связного списка (или в TreeMap)

[К оглавлению](#КорНаизусть)

# Что такое HashMap и её внутренне устройство (как можно подробнее)

Ассоциативный массив, хранит пары “ключ-значение”. Ключ-уникальный, значение-может повторяться. Каждая ячейка массива -
бакет(корзина), хранящий в себе односвязный список узлов. Если у односвязного списка node больше 8 элементов (коллизии),
он превращается в красно-чёрное дерево, обратно - если количество элементов в бакете уменьшилось до 6. Может содержать
один ключ null и любое количество значений null. Не отсортирован и не упорядочен. Возможны коллизии - возникают, когда у
разных объектов одинаковые хеш-коды. 

#### сложность операций
+ Добавление (put)	O(1), худшая O(n)
+ Удаление (remove)	O(1), худшая O(n)
+ Поиск (get)	O(1), худшая O(n)
+ Проверка наличия (containsKey / containsValue) O(1) / O(n) , худшая O(n)
+ Итерация по элементам	O(n), худшая O(n)

#### Устройство HashMap

В HashMap бакет — это элемент массива, в котором хранятся записи (ключ-значение). Если у нескольких ключей совпадает
хеш, их записи попадают в один бакет, где организуются в виде связного списка или сбалансированного дерева (в
зависимости от Java версии). Изначально создается 16 бакетов. Если массив бакетов заполнен на 75 процентов - создается х2 от начального размера.

Чтобы определить номер бакета есть формула: `bucketIndex = (hash & (capacity - 1));` Операция побитового & (AND) используется вместо %, так как она быстрее и эффективнее для степеней двойки.
+ hash — хэш-код ключа, который возвращает метод key.hashCode().
+ capacity — текущая ёмкость таблицы (всегда степень двойки, например, 16, 32). 
+ bucketIndex — индекс бакета, в котором будет храниться элемент.

#### Как работает HashMap

1. Добавление элемента (put)

Метод hashCode() ключа вычисляет целочисленный хэш-код.

Если бакет пуст, элемент добавляется напрямую.
Если бакет уже содержит элементы (коллизия), происходит:

+ идем по ключам элементов связного списка (или TreeMap) и сравниваем с ключом добавляемого элемента по хеш-коду и equals()
+ если ключи равны — перезаписываем значение по этому ключу, если нет — переходим к следующему элементу
+ если не нашли ключ добавляемого элемента (равный и по хеш-коду, и по equals()) — добавляем этот элемент в конец связного списка (или в TreeMap)

2. Поиск элемента (get)

Вычисляется хэш-код ключа, который преобразуется в индекс массива.

В указанном бакете ищется ключ, используя метод equals().

+ Если ключ найден, возвращается значение.
+ Если ключ отсутствует, возвращается null.

3. Удаление элемента (remove)

Вычисляется индекс бакета для удаления.

Поиск ключа с помощью метода equals()

Если элемент найден:

+ Удаляется узел.
+ Ссылки обновляются (если использовался связный список).

[К оглавлению](#КорНаизусть)

# Методы из collections

Главным набором методов, который важен при рассмотрении любой коллекции является набор CRUD-операций (create, read,
update, delete). На уровне Collection не существует способа обновить запись в коллекции

- add(Object o) - добавляет элемент в коллекцию.
- iterator() - возвращает итератор для перебора элементов коллекции.
- remove(Object o) - удаляет элемент из коллекции.
- contains(Object o) - проверяет, есть ли элемент в коллекции.
- size() - возвращает количество элементов в коллекции.
- clear() - очищает коллекцию (удаляет все элементы).
- toArray() - возвращает массив, содержащий все элементы коллекции

Collection — это интерфейс, который определяет базовые операции для работы с коллекциями, такими как List, Set и Queue.
Collections — это утилитный класс, который предоставляет статические методы для работы с коллекциями, например,
сортировку, поиск, синхронизацию.

[К оглавлению](#КорНаизусть)

# Стримы, типы методов в стримах

Представляет собой последовательность элементов, над которой можно производить различные операции. Его задача -
упростить работу с наборами данных , в частности, упростить операции фильтрации, сортировки и другие манипуляции данными

Методы стримов делятся на два типа:

+ Промежуточные операции (intermediate operations): Преобразовывают элементы потока, возвращают новый стрим и выполняются "
  лениво" (то есть только когда будет вызвана терминальная операция). Методов данного
  типа может быть сколько угодно в цепочке преобразований элементов потока.  Пример: filter(), map(), distinct(), sorted(),
  flatMap().

+ Конечные операции (terminal operations): Это операции, которые завершает обработку стрима и возвращают результат, метод данного типа в цепочке всегда один, располагается в конце цепочки промежуточных методов. Терминальный метод собирает результаты обработки элементов потока и возвращает единый результат
  , терминальный метод обязателен для завершения потока. Пример: collect(), forEach(), count(), min(), max().

Основные моменты:

+ Стримы не изменяют исходные данные, а возвращают новый результат.
+ Промежуточные операции выполняются только тогда, когда вызывается конечная операция.

### Какие существуют способы создания Stream? 
+ Пустой стрим. Stream.empty()
+ Стрим из List. list.stream()
+ Стрим из Map. map.entrySet().stream()
+ Стрим из массива. Arrays.stream(array)
+ Стрим из указанных элементов. Stream.of(”1”, “2”, “3”)
+ Конкатенацией двух стримов

[К оглавлению](#КорНаизусть)

# Как работает метод filter() в стримах

Конвейерная операция. Используется для фильтра элементов в коллекции.
Он принимает функцию-предикат в качестве аргумента и возвращает новый поток, содержащий только те элементы,
для которых функция-предикат возвращает истину.

[К оглавлению](#КорНаизусть)

# Что делает метод map() в стримах

Конвейерная операция. Метод map() принимает в качестве аргумента функциональный интерфейс Function, задающий
преобразование, применяемое к каждому элементу. Возвращаемый поток содержит преобразованные элементы.
Метод map() возвращает новый поток. Он не изменяет исходный поток и коллекцию. Обычно он используется для выполнения
операций, таких как преобразование элементов из одного типа в другой.

[К оглавлению](#КорНаизусть)

# Чем flatMap() отличается от map() в стримах

Метод map() преобразует элемент исходного потока из одного типа в другой. В отличие от этого, метод flatMap()
позволяет получить новый поток из элементов коллекций, которые были внутри элементов первого потока.
Таким образом, если вам нужно изменить каждый элемент и получить стрим простых объектов, используйте map().
Если ваши элементы сами содержат коллекции или стримы, и вы хотите "сплющить" их в один стрим, используйте flatMap().

[К оглавлению](#КорНаизусть)

# Расскажите про методы Object hashCode и equals?

Методы, необходимые для определения равенства объектов.
Метод `hashCode()` используется для числового представления объекта, метод `equals()` для сравнения двух объектов.
HashCode() и equals() взаимосвязаны, используются для определения равенства между объектами.

Сначала вычисляется hashCode() объектов, тк эта операция быстрее equals(). Если hashCode равны, то начинается проверка
на equals.
Если hashCode не равны, то дальнейшая проверка на равенство не проводится.

#### Контракт equals + hashcode:

+ Если hashCode() двух объектов возвращает разные значения, то они не могут быть равны
+ Если equals() объектов true, то и хеш-коды должны быть равны
+ Переопределив equals(), всегда переопределять hashCode()
+ Если у объектов одинаковый hashCode(), то они не обязательно equals()
+ При каждом вызове hashCode() для одного и того же объекта должен возвращаться один и тот же хеш-код

#### Свойства equals

- Рефлексивность. Объект должен быть равен самому себе (x.equals(x) == true)
- Симметричность. Любые два объекта должны иметь одно и то же мнение относительно своего равенства или неравенства (
  x.equals(y) == true и y.equals(x) == true)
- Транзитивность. Если один объект равен второму, а второй равен третьему, то и первый объект должен быть равен
  третьему (x.equals(y) == true и y.equals(z) == true и x.equals(z) == true)
- Непротиворечивость. Если два объекта равны, они должны быть равны всегда, пока один из них (или оба они) не будет
  изменен
- Для любой ненулевой ссылки на значение х выражение х.equals(null) должно возвращать false

### Свойства hashCode():

+ Согласованность. При каждом вызове hashCode() для одного и того же объекта в рамках одной программы должно
  возвращаться одно и то же значение, если поля объекта, участвующие в расчете хеш-кода, не изменились
+ Равенство и хеш-код. Если два объекта равны по методу equals(), их хеш-коды тоже должны быть равны. Однако обратное не
  обязательно — объекты с одинаковым хеш-кодом могут быть не равны
+ Распределение. Реализация hashCode(), возвращающая разный хеш-код для неравных объектов позволяет увеличить
  эффективность работы с хеш-структурами данных (такими как HashMap или HashSet) за счёт распределения объектов по
  разным корзинам хеш-таблицы

### Что будет, если переопределить equals() не переопределяя hashCode()?

+ Объект, который по equals() равен существующему ключу в HashMap, может не быть найден, если их хеш-коды различаются. Это связано с тем, что HashMap сначала использует hashCode() для поиска корзины, а уже потом сравнивает объекты по equals().
+ При попытке удалить ключ, который равен другому ключу по equals(), но имеет другой hashCode(), удаление может не сработать.

Какова роль equals() и hashCode() в HashMap?
hashCode позволяет определить корзину для поиска элемента, а equals используется для сравнения ключей элементов в списке корзины и искомого ключа.

[К оглавлению](#КорНаизусть)

# Что такое дженерики? Для чего нужны?

Дженерики - параметризованные типы в Java. Позволяют создавать классы, интерфейсы и методы с типами, заданными как
параметры. Позволяют использовать один класс для разных типов данных `(List<String>, List<Integer>)`

Набор рекомендаций от Oracle о том, когда какие обозначения лучше использовать в дженериках:

+ E — element, для элементов параметризованных коллекций; 
+ K — key, для ключей map-структур; 
+ V — value, для значений map-структур; 
+ N — number, для чисел; 
+ T — type, для обозначения типа параметра в произвольных классах; 
+ S, U, V и так далее — применяются, когда в дженерик-классе несколько параметров.

[К оглавлению](#КорНаизусть)

# Что такое лямбда выражение? Чем его можно заменить

Лямбда – набор инструкций, которые можно выделить в отдельную переменную и затем многократно использовать. Являются сокращённой формой внутренних анонимных классов.

Чем его можно заменить?
+ Анонимным классом 
+ Обычным классом, реализующим интерфейс 
+ Ссылкой на метод (method reference)

#### Анонимный класс vs лямбда

Это два способа реализации интерфейсов или создания компактного кода в Java. Они имеют сходства, но различаются по
способу использования, синтаксису и некоторым ограничениям.

+ Анонимный класс — это локальный класс без имени, который объявляется и создаётся одновременно. 
+ Лямбда — это краткий способ объявления реализации функционального интерфейса (интерфейса с одним методом).

[К оглавлению](#КорНаизусть)
