# Test

[Что такое пирамида тестирования](#что-такое-пирамида-тестирования)

[Как правильно писать юнит тесты](#как-правильно-писать-юнит-тесты)

[Можно ли сделать моки без использования мокито](#можно-ли-сделать-моки-без-использования-мокито)

[Как происходит сравнение фактического и ожидаемого ответа в тестах](#как-происходит-сравнение-фактического-и-ожидаемого-ответа-в-тестах)

[Mock. Как работает](#mock-как-работает)

# Что такое пирамида тестирования

Пирамида тестирования – это стратегия, где внизу много быстрых юнит-тестов(JUnit, AssertJ, Mockito.), в середине –
немного интеграционных тестов(Testcontainers, Spring Boot Test), а на вершине – несколько медленных UI-тестов(Selenium,
Cypress).

[К оглавлению](#Test)

# Как правильно писать юнит тесты

Хорошие юнит-тесты должны быть изолированными, быстрыми, читаемыми и проверять один конкретный сценарий. Они пишутся по
принципу AAA (Arrange, Act, Assert) и должны быть независимыми друг от друга

AAA – это структура теста:

    Arrange (Подготовка) – создаем объекты, задаем входные данные.
    Act (Действие) – вызываем тестируемый метод.
    Assert (Проверка) – проверяем результат.

Используем JUnit для тестирования логики и Mockito для мокирования зависимостей

[К оглавлению](#Test)

# Можно ли сделать моки без использования мокито

Да, можно. Моки можно делать вручную через анонимные классы, лямбды или классов заглушек. Mockito автоматизирует
этот процесс, упрощая проверку вызовов и управление поведением заглушек.

[К оглавлению](#Test)

# Как происходит сравнение фактического и ожидаемого ответа в тестах

В тестах сравнение ожидаемого и фактического результата выполняется с помощью assertEquals() (JUnit) или assertThat() (AssertJ). Если значения не совпадают, тест падает.

[К оглавлению](#Test)

# Mock. Как работает

Mock – это объект, который полностью подменяет реальный объект и позволяет вам контролировать его поведение для тестов.
Mock не выполняет фактическую логику, а просто возвращает заранее определенные значения, которые вы укажете в тестах.

Основное назначение Mock:

Для того, чтобы тестировать код в изоляции, не задействуя реальные объекты или зависимости, например, БД или внешние
API.
Вы можете определить, что вернет метод (например, return 42), но не заботиться о том, как он это делает.

Пример использования Mock (Mockito)

Предположим, у нас есть сервис, который зависит от репозитория для получения данных. Вместо того чтобы подключаться к
реальной базе данных, мы подменяем репозиторий на mock-объект, который будет просто возвращать заранее заданные данные.

```java
public class UserService {
    private UserRepository repository;

    public UserService(UserRepository repository) {
        this.repository = repository;
    }

    public String getUserName(int id) {
        return repository.findNameById(id);  // Ищем имя пользователя по id
    }
}

@Test
public void testMock() {
    // Создаем mock-объект
    UserRepository mockRepo = mock(UserRepository.class);
    
    // Указываем поведение mock-объекта
    when(mockRepo.findNameById(1)).thenReturn("Alice");

    // Используем mock-объект в сервисе
    UserService service = new UserService(mockRepo);
    
    // Проверяем результат
    assertEquals("Alice", service.getUserName(1));
}
```
В данном примере мы подменяем UserRepository с помощью mock-объекта и говорим ему, что он должен возвращать "Alice", когда вызывается метод findNameById(1).

[К оглавлению](#Test)