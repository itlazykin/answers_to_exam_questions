## Lambda

[1. Что такое lambda-выражение?](#1-Что-такое-lambda-выражение)

[2. Что такое функциональные интерфейсы?](#2-Что-такое-функциональные-интерфейсы)

[3. Перечислите функциональные интерфейсы из пакета java util function](#3-Перечислите-функциональные-интерфейсы-из-пакета-java-util-function)

[4. Что такое функции высшего порядка?](#4-Что-такое-функции-высшего-порядка)

[5. Какие функциональные интерфейсы из пакета java util function поддерживают функции высшего порядка?](#5-Какие-функциональные-интерфейсы-из-пакета-java-util-function-поддерживают-функции-высшего-порядка)

[6. Что такое ссылки на методы?](#6-Что-такое-ссылки-на-методы)

[7. Что такое ссылки на конструкторы?](#7-Что-такое-ссылки-на-конструкторы)

[8. Расскажите о зоне видимости переменных в lambda выражениях?](#8-Расскажите-о-зоне-видимости-переменных-в-lambda-выражениях)

[9. Как быть в ситуации, если внутри lambda выражения операторы могут выкинуть исключение?](#9-Как-быть-в-ситуации-если-внутри-lambda-выражения-операторы-могут-выкинуть-исключение)

[10. Что такое Stream API?](#10-Что-такое-Stream-API)

[11. Расскажите, какие шаблоны проектирования используются внутри Stream API? (Builder, Strategy, Decorator, Factory Method, Pipeline).](#11-Расскажите-какие-шаблоны-проектирования-используются-внутри-Stream-API-Builder-Strategy-Decorator-Factory-Method-Pipeline)

[12. Объясните, где они используются в Stream API.](#12-Объясните-где-они-используются-в-Stream-API)

[13. Что такое конвейерные и терминальные операции?](#13-Что-такое-конвейерные-и-терминальные-операции)

[14. Перечислите конвейерные (промежуточные) методы Stream API.](#14-Перечислите-конвейерные-промежуточные-методы-Stream-API)

[15. Перечислите терминальные методы Stream API.](#15-Перечислите-терминальные-методы-Stream-API)

[16. Что такое отложенное выполнение lambda?](#16-Что-такое-отложенное-выполнение-lambda)

[17. Что делает метод filter()?](#17-Что-делает-метод-filter)

[18. Что делает метод map()?](#18-Что-делает-метод-map)

[19. Что делает метод flatMap()?](#19-Что-делает-метод-flatMap)

[20. Что делает метод collect?](#20-Что-делает-метод-collect)

[21. Что делает метод findFirst?](#21-Что-делает-метод-findFirst)

[22. Что делает метод reduce?](#22-Что-делает-метод-reduce)

[23. Что делают методы min и max?](#23-Что-делают-методы-min-и-max)

[24. Что делают методы count, sum, average?](#24-Что-делают-методы-count-sum-average)

[25. Что делают методы forEach и peek?](#25-Что-делают-методы-forEach-и-peek)

[26. Что делают методы skip и limit?](#26-Что-делают-методы-skip-и-limit)

[27. Что делают методы allMatch(), noneMatch() и anyMatch()?](#27-Что-делают-методы-allMatch-noneMatch-и-anyMatch)

[28. Что делают методы mapToInt(), flatMapToInt(), mapToObj()?](#28-Что-делают-методы-mapToInt-flatMapToInt-mapToObj)

[29. Что такое числовой поток?](#29-Что-такое-числовой-поток)

[30. Чем отличается Stream <<Integer>> от IntStream <<int>> ?](#30-Чем-отличается-Stream-Integer-от-IntStream-int)

[31. Что делает метод boxed?](#31-Что-делает-метод-boxed)

[32. Возможно ли прервать выполнение потока по аналогии с break?](#32-Возможно-ли-прервать-выполнение-потока-по-аналогии-с-break)

[33. Возможно ли пропустить элемент потока по аналогии с continue?](#33-Возможно-ли-пропустить-элемент-потока-по-аналогии-с-continue)

[34. Что такое Optional?](#34-Что-такое-Optional)

[35. Перечислите методы Optional.](#35-Перечислите-методы-Optional)

[36. В чем разница между методами orElse и orElseGet?](#36-В-чем-разница-между-методами-orElse-и-orElseGet)

[37. Расскажите про фабричные методы List of, Set of, Map of?](#37-Расскажите-про-фабричные-методы-List-of-Set-of-Map-of)

[38. Для чего используется var?](#38-Для-чего-используется-var)

[39. В каких случаях можно использовать var?](#39-В-каких-случаях-можно-использовать-var)

## 1. Что такое lambda-выражение?

Лямбда-выражение — это компактная форма записи анонимных функций (без объявления класса или метода), которая позволяет
передавать поведение как аргумент в методы.
Основу лямбда-выражения составляет лямбда-оператор, который представляет стрелку `->`. Этот оператор разделяет
лямбда-выражение на две части: левая часть содержит список параметров выражения, а правая собственно представляет тело
лямбда-выражения, где выполняются все действия.
Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в функциональном интерфейсе.
При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.

```java
До лямбд.

List<String> list = Arrays.asList("яблоко", "банан", "апельсин");

Collections.sort(list, new Comparator<String>() {
  @Override
  public int compare(String s1, String s2) {
    return s1.compareTo(s2);
  }
});

После лямбд.

List<String> list = Arrays.asList("яблоко", "банан", "апельсин");

// Использование лямбда-выражения
Collections.sort(list, (s1, s2) -> s1.compareTo(s2));
```
```java
Пример: (String s1, String s2) -> s1.compareTo(s2) можно записать как (s1, s2) -> s1.compareTo(s2).
```

[К оглавлению](#Lambda)

## 2. Что такое функциональные интерфейсы?

Функциональный интерфейс в Java - это интерфейс, который содержит один абстрактный метод.
Абстрактный метод - метод у которого нет реализации.

Ключевые особенности:
+ Один абстрактный метод: интерфейс может содержать дополнительные методы по умолчанию и статические методы, но должен иметь ровно один абстрактный метод, который должен быть реализован при использовании интерфейса.
+ Аннотация `@FunctionalInterface`:  эта аннотация не является обязательной, но рекомендуется использовать ее, чтобы явно показать, что интерфейс предназначен для использования в функциональном стиле. Компилятор проверяет, что интерфейс действительно соответствует определению функционального интерфейса, и выдает ошибку, если это не так.

Зачем использовать функциональные интерфейсы?
+ Лямбда-выражения:  функциональные интерфейсы позволяют использовать лямбда-выражения, которые являются более кратким и лаконичным способом  определения анонимных функций.
+ Методы ссылок:  функциональные интерфейсы могут использоваться для создания ссылок на методы, что делает код более читаемым и компактным.
+ Функциональное программирование:  функциональные интерфейсы являются ключевой частью функционального программирования в Java, позволяя писать код, который является более чистым, более легким для тестирования и более надежным.

[К оглавлению](#Lambda)

## 3. Перечислите функциональные интерфейсы из пакета java util function

Supplier (поставщик) используется для создания какого-либо объекта и при этом ему не требуется входной параметр.

```java

@FunctionalInterface
public interface Supplier<T> {
    T get();
}
```

Consumer (потребитель) используется в том случае, если нам нужно применить какое-то действие или операцию к параметру (
для BiConsumer два параметра) и при этом у метода нет возвращаемого значения. Два интерфейса отличаются только одним –
количеством параметров, которые принимает метод в этом интерфейсе. Параметры в Bi-consumer могут быть разных типов.

```java

@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);
}

@FunctionalInterface
public interface BiConsumer<T, U> {
    void accept(T t, U u);
}
```

Predicate (утверждение) наиболее часто применяется в фильтрах и сравнении. В метод test() передается один или два
параметра, в зависимости от функционального интерфейса и возвращает логическое значение true или false.

```java

@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
}

@FunctionalInterface
public interface BiPredicate<T, U> {
    boolean test(T t, U u);
}
```

Function используется для преобразования входного параметра или двух параметров (для Bi-формы этого функционального
интерфейса) в какое-либо значение, тип возвращаемого значения может не совпадать с типом входных параметров. Все три
типа в обобщениях в BiFunction могут быть разными: принимает на вход 2 разных типа и возвращает третий тип.

```java

@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
}

@FunctionalInterface
public interface BiFunction<T, U, R> {
    R apply(T t, U u);
}
```

UnaryOperator и BinaryOperator – это разновидность Function, в которых входные и выходные обобщенные параметры должны
совпадать.

```java

@FunctionalInterface
public interface UnaryOperator<T> extends Function<T, T> {
}

@FunctionalInterface
public interface BinaryOperator<T> extends BiFunction<T, T, T> {
}
```

Помимо абстрактных методов функциональные интерфейсы могут иметь целый набор статических методов или методы по
умолчанию.

Predicate<Integer> predicate = x -> x > 5;

Consumer<Integer> consumer = x -> System.out.println(x);

Function<Integer, String> function = x -> x.toString();

Supplier<Integer> supplier = () -> new Integer(5);

UnaryOperator<Integer> unaryOperator = x -> x*x;

BinaryOperator<Integer> binaryOperator = (x, y) -> x * y

BiConsumer<T,U>;
BiFunction<T,U,R>;
BinaryOperator<T>;
BiPredicate<T,U>;
BooleanSupplier;
Consumer<T>;
DoubleBinaryOperator;
DoubleConsumer;
DoubleFunction<R>;
DoublePredicate;
DoubleSupplier;
DoubleToIntFunction;
DoubleToLongFunction;
DoubleUnaryOperator;
Function<T,R>;
IntBinaryOperator;
IntConsumer;
IntFunction<R>;
IntPredicate;
IntSupplier;
IntToDoubleFunction;
IntToLongFunction;
IntUnaryOperator;
LongBinaryOperator;
LongConsumer;
LongFunction<R>;
LongPredicate;
LongSupplier;
LongToDoubleFunction;
LongToIntFunction;
LongUnaryOperator;
ObjDoubleConsumer<T>;
ObjIntConsumer<T>;
ObjLongConsumer<T>;
Predicate<T>;
Supplier<T>;
ToDoubleBiFunction<T,U>;
ToDoubleFunction<T>;
ToIntBiFunction<T,U>;
ToIntFunction<T>;
ToLongBiFunction<T,U>;
ToLongFunction<T>;
UnaryOperator<T>;

[К оглавлению](#Lambda)

## 4. Что такое функции высшего порядка?

Функции высшего порядка (Higher-order functions) – это функции, которые могут принимать другие функции в качестве
аргументов или возвращать функции в качестве результата. В Java эта концепция появилась с версии 8 и стала возможной
благодаря появлению лямбда-выражений и функциональных интерфейсов.

Основные характеристики:

+ Принимают функции в качестве аргументов: Функция может принимать другую функцию как параметр, позволяя ей выполнять
  операции с другими функциями.
+ Возвращают функции в качестве результата: Функция может вернуть другую функцию как результат, предоставляя возможность создания новых функций на основе входных данных.

[К оглавлению](#Lambda)

## 5. Какие функциональные интерфейсы из пакета java util function поддерживают функции высшего порядка?

В пакете `java.util.function` все функциональные интерфейсы поддерживают функции высшего порядка.

Как функциональные интерфейсы поддерживают функции высшего порядка?

Принимая функции в качестве аргументов:
+ Методы `andThen()`, `compose()`, `apply()` в `Function<T, R>` принимают другие функции в качестве аргументов.
+ Методы `and()`, `negate()` в `Predicate<T>` принимают другие предикаты в качестве аргументов.
+ Методы `andThen()`, `compose()` в `Consumer<T>` принимают другие действия в качестве аргументов.
+ Методы `andThen()`, `compose()` в `UnaryOperator<T>` и `BinaryOperator<T>` принимают другие операторы в качестве аргументов.
+ Методы `thenComparing()`, `reversed()` в `Comparator<T>` принимают другие компараторы в качестве аргументов.

Возвращая функции в качестве результата:
+ Методы `andThen()`, `compose()` в `Function<T, R>` возвращают новые функции.
+ Методы `and()`, `negate()` в `Predicate<T>` возвращают новые предикаты.
+ Методы `andThen()`, `compose()` в `Consumer<T>` возвращают новые действия.
+ Методы `andThen()`, `compose()` в `UnaryOperator<T>` и `BinaryOperator<T>` возвращают новые операторы.
+ Методы `thenComparing()`, `reversed()` в `Comparator<T>` возвращают новые компараторы.

Примеры:

```java
// Пример использования andThen() в Function
Function<String, Integer> toInteger = Integer::parseInt;
Function<Integer, String> toString = Object::toString;
Function<String, String> convertToString = toInteger.andThen(toString);
String result = convertToString.apply("123"); // result == "123"

// Пример использования and() в Predicate
Predicate<Integer> isEven = i -> i % 2 == 0;
Predicate<Integer> isPositive = i -> i > 0;
Predicate<Integer> isEvenAndPositive = isEven.and(isPositive);
boolean result = isEvenAndPositive.test(4); // result == true
```

[К оглавлению](#Lambda)

## 6. Что такое ссылки на методы?

Вызов метода через двойное двоеточие -> :: 

Ссылки на методы в Java — это одна из возможностей, введенных в Java 8,
которая позволяет ссылаться на существующие методы или конструкторы и использовать их в контексте,
где ожидается функциональный интерфейс.
Это сокращает количество кода, делая его более читаемым и выразительным.
Ссылки на методы (Method References) – это компактные лямбда выражения для методов у которых уже есть имя. Такая ссылка
позволяет обращаться к методу, не вызывая его. Для создания ссылки на метод служит следующая общая форма:
`имя_класса :: имя_метода`

Было:

```java
Consumer<String> consumer = str -> System.out.println(str);
```

Стало:

```java
Consumer<String> consumer = System.out::println;
```

Вызов метода println идет через двойное двоеточие (::), а не через точку (.)

[К оглавлению](#Lambda)

## 7. Что такое ссылки на конструкторы?

Аналогично ссылкам на методы, ссылки также можно объявлять и на конструкторы.

`ИмяКласса::new`

Такую ссылку можно присвоить любой ссылке на функциональный интерфейс, где определяется метод, совместимый с
конструктором. При этом "ИмяКласса" не может быть интерфейсом или абстрактным классом. При использовании конструкторов
методы функционального интерфейса должны принимать тот же список параметров, что и конструкторы класса, и должны
возвращать объект данного класса.

[К оглавлению](#Lambda)

## 8. Расскажите о зоне видимости переменных в lambda выражениях

В lambda-выражениях в Java существуют определённые ограничения на использование переменных, которые связаны с зоной видимости. Эти ограничения помогают избежать ошибок и делают код предсказуемым.
+ Локальные переменные — переменные, объявленные в теле метода, где используется лямбда.
+ Параметры метода — переменные, переданные в метод, где объявлено лямбда-выражение.
+ Переменные-члены класса (или поля) — переменные, объявленные как поля текущего объекта или класса.

Самый важный аспект при работе с лямбда-выражениями — это локальные переменные. Лямбда-выражение имеет доступ к локальным переменным из окружающего его контекста, но с определённым ограничением: локальная переменная должна быть эффективно финальной. Локальная переменная считается "эффективно финальной", если после её инициализации её значение не меняется. Даже если она не объявлена с ключевым словом final, компилятор всё равно требует, чтобы переменная вела себя как final, если её используют внутри лямбды.
```java
Пример использования локальных переменных
public class LambdaExample {
  public void printNumbers() {
    int multiplier = 2;  // Локальная переменная, которая эффективно финальная

    List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
    numbers.forEach(n -> System.out.println(n * multiplier));  // Использование локальной переменной
  }
}
В данном примере переменная multiplier используется внутри лямбды, но её значение не изменяется после инициализации, 
поэтому она считается "эффективно финальной".
```
Если попытаться изменить локальную переменную, которая используется внутри лямбды, компилятор выдаст ошибку.
```java
public void example() {
    int count = 0;  // Локальная переменная

    Runnable r = () -> {
        // Ошибка компиляции, так как count нельзя изменять
        count++;
        System.out.println(count);
    };
}
Ошибка возникает, потому что count изменяется внутри лямбды, нарушая правило "эффективно финальной" переменной.
```
Переменные-члены класса (или поля) могут свободно изменяться внутри лямбда-выражений, так как они не зависят от контекста вызова метода. Лямбда-выражение, как и анонимный класс, имеет доступ к ним.
```java
public class LambdaExample {
    private int count = 0;  // Переменная-член класса

    public void example() {
        Runnable r = () -> {
            count++;  // Можно изменять переменные-члены класса
            System.out.println(count);
        };
    }
}
```
Параметры метода можно использовать в лямбдах, как и локальные переменные, но они также должны быть "эффективно финальными".
```java
public void printNumbers(int multiplier) {
    List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
    numbers.forEach(n -> System.out.println(n * multiplier));  // Параметр метода
}
```
Ограничение на использование локальных переменных объясняется природой лямбд в Java:
+ Лямбды могут выполняться асинхронно или в другом потоке, отличном от исходного. Если бы локальные переменные можно было свободно изменять, это могло бы привести к неконсистентности данных и непредсказуемым ошибкам.
+ Чтобы избежать потенциальных проблем с многопоточностью и сделать лямбда-выражения безопасными, компилятор требует, чтобы локальные переменные были неизменяемыми (или "эффективно финальными").

### Вывод по зонам видимости
+ Лямбда-выражение имеет доступ к переменным-членам класса и может их изменять.
+ Лямбда-выражение имеет доступ к параметрам метода, если они "эффективно финальные".
+ Лямбда-выражение имеет доступ к локальным переменным метода, если они "эффективно финальные".
+ Локальные переменные, которые используются в лямбдах, не могут изменяться после своей инициализации, чтобы избежать проблем с параллелизмом и многопоточностью.

[К оглавлению](#Lambda)

## 9. Как быть в ситуации, если внутри lambda выражения операторы могут выкинуть исключение?

Если внутри лямбда-выражения операторы могут выбросить проверяемое исключение (checked exception), это может вызвать проблемы, так как синтаксис лямбд не позволяет напрямую обрабатывать такие исключения. В Java все проверяемые исключения должны быть либо обработаны (catch), либо объявлены в throws метода, что иногда затрудняет использование лямбд.

Что делать ?

+ Обработка исключения внутри лямбда-выражения. Самый простой подход — это обработка исключения внутри самого лямбда-выражения с помощью блока try-catch. Это позволяет локально поймать исключение и обработать его.
```java
List<String> list = Arrays.asList("1", "2", "a", "3");

list.forEach(item -> {
    try {
        int number = Integer.parseInt(item);
        System.out.println("Parsed number: " + number);
    } catch (NumberFormatException e) {
        System.out.println("Unable to parse: " + item);
    }
});

Плюсы: Простота реализации.
Минусы: Код может стать менее читабельным, если нужно много обработок исключений.
```
+ Создание вспомогательного метода. Можно вынести логику обработки исключений во вспомогательный метод, который уже будет вызывать нужный функционал и обрабатывать исключения.
```java
list.forEach(item -> handleParse(item));

private static void handleParse(String item) {
    try {
        int number = Integer.parseInt(item);
        System.out.println("Parsed number: " + number);
    } catch (NumberFormatException e) {
        System.out.println("Unable to parse: " + item);
    }
}

Плюсы: Повышение читаемости лямбда-выражения.
Минусы: Создание дополнительных методов может увеличивать объем кода.
```
+ Использование обёртки для лямбда-выражения. Можно создать специальный метод-обёртку, который принимает лямбду и обрабатывает исключения. Это подход, который позволяет разделить обработку исключений и логику самой лямбды.
```java
list.forEach(rethrowConsumer(item -> {
    int number = Integer.parseInt(item);
    System.out.println("Parsed number: " + number);
}));

// Метод-обёртка
@FunctionalInterface
interface ThrowingConsumer<T> {
    void accept(T t) throws Exception;
}

public static <T> Consumer<T> rethrowConsumer(ThrowingConsumer<T> throwingConsumer) {
    return item -> {
        try {
            throwingConsumer.accept(item);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    };
}

Плюсы: Чистота кода и отделение обработки исключений от основной логики.
Минусы: Исключение преобразуется в непроверяемое (unchecked), что не всегда допустимо.
```
+ Преобразование проверяемого исключения в непроверяемое. Можно преобразовать проверяемое исключение в непроверяемое (RuntimeException), если это приемлемо в конкретной ситуации. Это позволяет обойти ограничение Java на проверяемые исключения в лямбдах.
```java
list.forEach(item -> {
    try {
        int number = Integer.parseInt(item);
        System.out.println("Parsed number: " + number);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
});

Плюсы: Упрощает использование лямбд.
Минусы: Исключение становится непроверяемым, что может сделать код менее безопасным и устойчивым к ошибкам.
```

[К оглавлению](#Lambda)

## 10. Что такое Stream API?

Начиная с JDK 8 в Java появился новый API - Stream API.
Его задача - упростить работу с наборами данных, в частности,
упростить операции фильтрации, сортировки и другие манипуляции с данными.

Вся основная функциональность данного API сосредоточена в
пакете java.util.stream.

Ключевым понятием в Stream API является поток данных.

Поток представляет канал передачи данных из источника данных.
Причем в качестве источника могут выступать как файлы, так и массивы и коллекции.

Одной из отличительных черт Stream API является применение лямбда-выражений.

[К оглавлению](#Lambda)

## 11. Расскажите, какие шаблоны проектирования используются внутри Stream API? (Builder, Strategy, Decorator, Factory Method, Pipeline).

"Builder" (Строитель),
"Strategy" (Стратегия),
"Decorator" (Декоратор),
"Factory Method" (Фабричный метод),
"Pipeline" (Конвейер),
"Filter" (Фильтр),
"Iterator" (Итератор)
"Template Method" (Шаблонный метод)

[К оглавлению](#Lambda)

## 12. Объясните, где они используются в Stream API.

- Шаблон Итератор позволяет последовательно перебирать элементы коллекции без раскрытия её внутренней структуры. В Stream API используется внутренний итератор, который отличается от классического внешнего итератора (Iterator). Внутренний итератор берет на себя управление процессом итерации, позволяя использовать функциональные методы, такие как map, filter, forEach, и другие.
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream()
       .filter(n -> n % 2 == 0)
       .forEach(System.out::println);  // Внутренний итератор

Преимущество внутреннего итератора в том, что он освобождает программиста от необходимости вручную управлять циклом, 
делая код более декларативным и удобным для чтения.
```

- Шаблон Строитель (Builder) используется для создания сложных объектов пошагово. В Stream API этот шаблон проявляется через класс Stream.Builder, который позволяет создать поток элементов с использованием удобного интерфейса.
```java
Stream<Integer> stream = Stream.<Integer>builder()
                                .add(1)
                                .add(2)
                                .add(3)
                                .build();
stream.forEach(System.out::println);

Преимущество строителя в том, что он позволяет пошагово настраивать поток, добавляя элементы в удобном порядке, 
что особенно полезно при создании сложных потоков данных.
```

- Шаблон Фильтр — это структура, которая позволяет последовательно обрабатывать данные и исключать ненужные элементы. В Stream API метод filter реализует этот шаблон, позволяя отфильтровать элементы по заданным критериям.
```java
List<String> names = Arrays.asList("John", "Jane", "Jack", "Doe");
names.stream()
     .filter(name -> name.startsWith("J"))
     .forEach(System.out::println);

Фильтр помогает отделять данные, которые соответствуют критериям, от тех, что не соответствуют,
сохраняя при этом потоковый подход.
```
- Шаблон Стратегия позволяет определить семейство алгоритмов, инкапсулировать каждый из них и сделать их взаимозаменяемыми. В Stream API функциональные интерфейсы, такие как Predicate, Function, и Consumer, используются в качестве стратегий, которые можно передавать в методы обработки данных (filter, map, forEach и т. д.).
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Predicate<Integer> isEven = n -> n % 2 == 0;  // Стратегия
numbers.stream()
       .filter(isEven)  // Используем стратегию
       .forEach(System.out::println);

Преимущество стратегии в том, что это позволяет легко изменять поведение программы, 
передавая разные функции (или стратегии) для обработки данных.
```
- Шаблон Декоратор позволяет динамически добавлять поведение объекту. В Stream API метод peek можно рассматривать как пример использования декоратора, так как он позволяет выполнить действие над элементами потока, не изменяя сам поток.
```java
List<Integer> numbers = Arrays.asList(1, 2, 3);
numbers.stream()
       .peek(n -> System.out.println("Original: " + n))  // Декоратор
       .map(n -> n * 2)
       .peek(n -> System.out.println("Modified: " + n))  // Декоратор
       .forEach(System.out::println);

Метод peek добавляет дополнительное поведение (логирование), не изменяя структуру данных потока.
```
- Шаблон Шаблонный метод определяет алгоритм в методе, оставляя некоторые шаги для подклассов. В Stream API есть схожий принцип, где методы, такие как reduce или collect, определяют общий процесс, но позволяют программисту указать детали, передавая конкретные функции.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream()
                 .reduce(0, Integer::sum);  // reduce как шаблонный метод
System.out.println("Sum: " + sum);

Метод reduce позволяет определить общий алгоритм аккумуляции данных, 
а конкретная функция суммирования передается как часть реализации.
```

- Шаблон Pipeline организует обработку данных в виде цепочки последовательных шагов, где результат одного шага передаётся как вход для следующего. В контексте Stream API, это означает последовательное применение множества промежуточных операций (таких как filter, map, sorted) к данным и завершение их терминальной операцией (например, collect, forEach или reduce).
```java
List<String> names = Arrays.asList("John", "Jane", "Jack", "Doe");

List<String> filteredNames = names.stream()  // Источник данных
                                  .filter(name -> name.startsWith("J"))  // Промежуточная операция
                                  .map(String::toUpperCase)  // Промежуточная операция
                                  .sorted()  // Промежуточная операция
                                  .collect(Collectors.toList());  // Терминальная операция
                                  
System.out.println(filteredNames);  // [JACK, JANE, JOHN]

```
- В Stream API мы часто создаём потоки с использованием фабричных методов, которые позволяют легко инициализировать потоки данных из различных источников, таких как коллекции, массивы, строки, файлы и другие.
```java
1)
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> stream = list.stream();  // Фабричный метод

Метод stream() в интерфейсе Collection — это фабричный метод, который возвращает поток элементов коллекции. 
Он скрывает внутренние детали создания потока и предоставляет готовый интерфейс для работы с данными.
        
2)
String[] array = {"a", "b", "c"};
Stream<String> stream = Arrays.stream(array);  // Фабричный метод

Метод Arrays.stream() — это ещё один пример фабричного метода, который создаёт поток данных из массива.
        
3)
Stream<String> stream = Stream.of("a", "b", "c");  // Фабричный метод

Метод Stream.of() — это статический фабричный метод, который позволяет создать поток из набора элементов. 
Это удобный способ быстро инициализировать поток с заранее известными данными.
        
4)
Stream<String> emptyStream = Stream.empty();  // Фабричный метод

Метод Stream.empty() создаёт пустой поток. Это типичный пример использования фабричного метода для возврата
специфичной реализации потока (в данном случае пустого).

5)
Stream<Double> randomNumbers = Stream.generate(Math::random);  // Фабричный метод
Stream<Integer> infiniteNumbers = Stream.iterate(0, n -> n + 1);  // Фабричный метод

Методы Stream.generate() и Stream.iterate() — это фабричные методы для создания бесконечных потоков.
Они предоставляют гибкий способ инициализации потоков, позволяя указать правила генерации данных.
```
[К оглавлению](#Lambda)

## 13. Что такое конвейерные и терминальные операции?

- Промежуточные (конвейерные). Преобразовывают элементы потока, возвращая новый преобразованный поток. Методов данного
  типа может быть сколько угодно в цепочке преобразований элементов потока. Данные методы ленивы, то есть отрабатывают
  только когда для потока вызван конечный метод. Промежуточных методов у потока может и не быть. Промежуточные операции
  не выполняются без конечных. Промежуточные методы ленивы - они начинают вычисляться только когда начнется терминальная
  операция, то есть вычисление происходит только тогда, когда оно нужно.


- Конечные (терминальные). Метод данного типа всегда один, располагается в конце цепочки промежуточных методов (если
  они есть). Данный метод возвращает другой тип объекта (например, Optional, коллекцию и т.д.). То есть конечный
  метод собирает результаты обработки элементов потока и возвращает единый результат. Конечный метод для завершения
  потока обязателен.

[К оглавлению](#Lambda)

## 14. Перечислите конвейерные (промежуточные) методы Stream API.

- filter() - фильтрует элементы потока, возвращая только элементы, удовлетворяющие условию.
- map() - преобразует каждый элемент потока.
- mapToInt() - тот же map(), но возвращает поток примитивов int (также есть соответствующие mapToDouble() и
  mapToLong()).
- flatMap() - трансформирует каждый объект потока в поток других объектов, то есть все элементы коллекции коллекций или
  потока потоков трансформирует в единый поток. (также поддерживает возврат потоков примитивов с помощью методов
  flatMapToInt(), flatMapToDouble(), flatMapToLong()). Может преобразовывать элементы, применяя указанную функцию к
  каждому элементу.
- peek() - выполняет действие для каждого элемента потока, возвращая поток, состоящий из измененных элементов.
- sorted() - сортирует элементы потока по возрастанию. Возможна сортировка по убыванию при передаче соответствующего
  компаратора.
- skip() - пропускает указанное число элементов с начала потока.
- limit() - делает выборку первых элементов из родного потока в указанном количестве (отбирает элементы из потока, пока
  не достигнет указанного количества).
- distinct() - убирает дубликаты из потока.
- mapToObj() - трансформирует числовой поток в объектный.

[К оглавлению](#Lambda)

## 15. Перечислите терминальные методы Stream API.

- forEach() - используется для выполнения действия над каждым элементом потока завершая поток. Он применяется,
  когда вам нужно выполнить какую-то операцию над каждым элементом потока, но при этом не требуется возвращать
  результат.
- collect() - собирает все элементы потока в структуру данных.
- findFirst() - получает первый элемент из потока.
- toArray() - собирает элементы потока в массив.
- count() - возвращает количество элементов в потоке.
- min() - возвращает минимальный элемент (условие передается в компараторе).
- max() - возвращает максимальный элемент (условие передается в компараторе).
- sum() - возвращает сумму всех элементов потока (только для числовых потоков).
- average() - возвращает среднее арифметическое всех элементов потока (только для числовых потоков).
- allMatch() - возвращает true, если все элементы удовлетворяют условию.
- noneMatch() - возвращает true, если все элементы не удовлетворяют условию.
- reduce() - используется для выполнения агрегатных операций над элементами потока.

[К оглавлению](#Lambda)

## 16. Что такое отложенное выполнение lambda?

Лямбда обладает свойством отложенного выполнения. Отложенное выполнение начинает вычисление только тогда, когда
пользователь запросил его результат. У отложенного выполнения есть и "брат-близнец" - ленивая загрузка (lazy load).
Ленивая загрузка упоминается чаще в контексте загрузки элементов или объектов.
Например, загрузка классов ссылочных полей загружаемого класса будет выполняться только тогда,
когда к ним произойдёт явное обращение в программе.

Другой способ - это eager aka энергичная загрузка, когда вся последовательность элементов загружается сразу,
а не только когда элемент необходим.

Отложенное выполнение более точно описывает процесс, происходящий в лямбде -
код внутри неё начнет выполняться только тогда, когда произойдёт обращение за его результатом.

[К оглавлению](#Lambda)

## 17. Что делает метод filter()?

Конвейерная операция. Используется для фильтра элементов в коллекции.
Он принимает функцию-предикат в качестве аргумента и возвращает новый поток, содержащий только те элементы,
для которых функция-предикат возвращает истину.

[К оглавлению](#Lambda)

## 18. Что делает метод map()?

Конвейерная операция. Метод map() принимает в качестве аргумента функциональный интерфейс Function, задающий
преобразование, применяемое к каждому элементу. Возвращаемый поток содержит преобразованные элементы.
Метод map() возвращает новый поток. Он не изменяет исходный поток и коллекцию. Обычно он используется для выполнения
операций, таких как преобразование элементов из одного типа в другой.

[К оглавлению](#Lambda)

## 19. Что делает метод flatMap()?

Конвейерная операция. Метод flatMap() используется для создания одного потока из множества потоков.
Он принимает функцию в качестве аргумента, которая применяется к каждому элементу исходного потока.
Эта функция принимает элемент исходного потока и возвращает новый поток.

Разница между map() и flatMap()
Метод map() преобразует элемент исходного потока из одного типа в другой. В отличие от этого, метод flatMap()
позволяет получить новый поток из элементов коллекций, которые были внутри элементов первого потока.
Таким образом, если вам нужно изменить каждый элемент и получить стрим простых объектов, используйте map().
Если ваши элементы сами содержат коллекции или стримы, и вы хотите "сплющить" их в один стрим, используйте flatMap().

[К оглавлению](#Lambda)

## 20. Что делает метод collect?

Терминальная операция. Используется для сбора элементов в коллекции с использованием заданной функции.
Он принимает функцию в качестве аргумента и применяет ее к каждому элементу коллекции,
собирая результаты в новую коллекцию. (toList(); toSet(); toMap())

[К оглавлению](#Lambda)

## 21. Что делает метод findFirst?

Терминальная операция. Метод findFirst в Java предназначен для поиска первого элемента в коллекции,
удовлетворяющий заданному условию. Он принимает предикат в качестве параметра и возвращает первый элемент коллекции,
для которого предикат вернет true, возвращает значение, обернутое в тип Optional.
Если такого элемента не существует, метод бросает исключение NoSuchElementException.

[К оглавлению](#Lambda)

## 22. Что делает метод reduce?

Терминальная операция. Метод reduce() в Java Stream API используется для выполнения агрегатных операций над элементами
потока.
Метод reduce() позволяет свести последовательность элементов к одному значению,
что полезно для задач, связанных с обработкой коллекций данных.
Он берет элементы потока, объединяет их с помощью указанной операции и возвращает одно значение.
В основном, reduce() используется для таких задач, как суммирование, нахождение произведения,
объединение строк и других операций, которые сводятся к одному результату. Он отличается от метода collect() тем,
что использует ассоциативную функцию, принимающую два значения и объединяющую их в одно.

[К оглавлению](#Lambda)

## 23. Что делают методы min и max?

Терминальные операции.

- min() - возвращает минимальный элемент потока. Наименьший элемент определяется с помощью компаратора, который
  передается в параметр метода.
- max() - возвращает максимальный элемент потока. Наибольший элемент определяется с помощью компаратора, который
  передается в параметр метода.

[К оглавлению](#Lambda)

## 24. Что делают методы count, sum, average?

Терминальные операции.

- count() - возвращает число элементов в потоке.
- sum() - суммирует все элементы потока. Применяется только к числовым потокам.
- average() - возвращает среднее арифметическое всех элементов потока. Применяется только к числовым потокам.

[К оглавлению](#Lambda)

## 25. Что делают методы forEach и peek?

- peek() - это конвейерная операция. Выполняет действие для каждого элемента потока, возвращая поток, состоящий из
  измененных элементов.
- forEach() - это терминальная операция. Выполняет действие для каждого элемента потока, завершая поток. Он применяется,
  когда вам нужно выполнить какую-то операцию над каждым элементом потока, но при этом не требуется возвращать
  результат.

Peek() чаще используется в отладочных целях для вывода состояния элемента в потоке, нежели для каких-либо
преобразований.

[К оглавлению](#Lambda)

## 26. Что делают методы skip и limit?

Конвейерные операции.

- skip(n) - пропускает первые n элементов с начала потока. То есть задает начальную границу
  диапазона перебираемых элементов. Параметром нельзя задать отрицательное число, а если заданное значение параметра
  равно или превышает число элементов в исходной структуре данных, то будет возвращен пустой поток.
- limit(n) - возвращает новый поток, содержащий только первые n элементов из исходного потока,
  то есть задает конечную границу диапазона перебираемых элементов. Нельзя задать отрицательное значение параметра. Этот
  метод перебирает элементы, пока не накопит указанное количество элементов, после чего завершает перебор исходной
  структуры данных и возвращает новый поток из собранных элементов.

[К оглавлению](#Lambda)

## 27. Что делают методы allMatch(), noneMatch() и anyMatch()?

Это терминальные методы проверки элементов на соответствие заданному условию. Все эти методы принимают Predicate в
качестве параметра (условия для проверки).

- noneMatch() - возвращает true, если ни один из элементов потока не удовлетворяет условию.
- anyMatch() - возвращает true, если как минимум один из элементов потока удовлетворяет условию.
- allMatch() - возвращает true, если все элементы потока удовлетворяют условию.

[К оглавлению](#Lambda)

## 28. Что делают методы mapToInt(), flatMapToInt(), mapToObj()?

Это конвейерные методы преобразования потока объектов в поток примитивов и преобразования потока примитивов обратно в
поток объектов.

- mapToInt() - преобразовывает поток объектов в поток примитивных чисел типа int. Применяется, если исходящий поток
  состоит из элементов-объектов, а в результате их обработки будет получен примитивный
  тип int. Метод mapToInt возвращает объект интерфейса IntStream (числовой поток), который в дальнейшем обрабатывается
  как поток примитивных чисел. Класс Stream помимо метода mapToInt() также имеет аналогичные ему методы mapToDouble() и
  mapToLong(), работающие с Double и Long типами соответственно.
- flatMapToInt() - трансформирует поток массивов в поток примитивных чисел int. flatMapToInt() последовательно запускает
  поток из каждого массива исходящего потока, в результате чего все элементы этих массивов объединяются в один общий
  поток примитивных чисел int.
- mapToObj() - преобразует поток примитивных чисел в поток объектов.

[К оглавлению](#Lambda)

## 29. Что такое числовой поток?

Это специальный тип потоков, предназначенный для работы с примитивными типами данных: int, long и double.
Использование числовых потоков позволяет избежать авто упаковки и авто распаковки (boxing/unboxing),
что улучшает производительность при работе с большими объемами данных.

Типы числовых потоков:
IntStream — поток целых чисел типа int.
LongStream — поток целых чисел типа long.
DoubleStream — поток чисел с плавающей точкой типа double.
Методы этих интерфейсов предоставляют набор удобных методов для работы с числами, что делает код более лаконичным и
производительным.(sum, average, min, max, count, range, rangeCloset, mapToObj)

[К оглавлению](#Lambda)

## 30. Чем отличается Stream Integer от IntStream int?

- Stream<Integer<Integer>> - это поток объектов типа Integer.
- IntStream <int<int>> - это поток примитивных чисел int.
  Отличаются по типу данных, в производительности и наборе методов. Когда используем Stream - происходит авто упаковка и
  авто распаковка, увеличивая затраты на производительность, особенно при обработке больших объемов данных.
  Stream<Integer>: Предоставляет стандартные методы для работы с потоками, такие как filter(), map(), reduce(), и так
  далее. Но если вы хотите выполнить какие-то специфические операции с числами (например, посчитать сумму или среднее
  значение), нужно будет использовать дополнительные преобразования или методы.
  IntStream: Предоставляет специализированные методы для работы с числами, такие как sum(), average(), min(), max(),
  range(), rangeClosed(), и другие, что упрощает и ускоряет выполнение числовых операций.

  [К оглавлению](#Lambda)

## 31. Что делает метод boxed?

Метод полезен, когда нужно перейти от работы с примитивными типами к объектам. Он оборачивает примитивы и делает их
объектами.

[К оглавлению](#Lambda)

## 32. Возможно ли прервать выполнение потока по аналогии с break?

В Java Stream API нет прямого аналога оператора break, который можно было бы использовать для прерывания выполнения потока, как это делается в обычных циклах (for, while). Однако существует несколько способов добиться схожего поведения в зависимости от задачи. 

- Использование терминальной операции findFirst() или findAny(). Если ваша цель — найти первый подходящий элемент и прекратить обработку дальше, можно использовать методы findFirst() или findAny(). Эти методы возвращают результат как Optional, и как только подходящий элемент найден, обработка потока завершается.
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

Optional<Integer> firstEven = numbers.stream()
                                     .filter(n -> n % 2 == 0)  // Найдём первое чётное число
                                     .findFirst();  // Прекращаем поток, как только нашли элемент

firstEven.ifPresent(System.out::println);  // Выведет 2

В этом случае обработка потока завершится, как только найдётся первый элемент, удовлетворяющий условию.
```
- Использование anyMatch(), allMatch() или noneMatch(). Эти методы позволяют проверить условие для элементов потока и завершить обработку, как только результат будет определён. Это тоже можно рассматривать как своего рода "прерывание".
```java
boolean hasEven = numbers.stream()
                         .anyMatch(n -> n % 2 == 0);  // Прекращает поток при нахождении первого чётного
System.out.println(hasEven);  // true

Метод anyMatch() завершит поток, как только найдёт первый элемент, соответствующий условию.
```
- Прерывание потока с использованием takeWhile() (Java 9+). Если вам нужно обрабатывать элементы потока до тех пор, пока они соответствуют определённому условию, можно использовать метод takeWhile(). Он завершит поток, как только найдёт элемент, который не удовлетворяет условию.
```java
List<Integer> sortedNumbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);

List<Integer> lessThanFive = sortedNumbers.stream()
                                          .takeWhile(n -> n < 5)  // Прекратит обработку при первом n >= 5
                                          .collect(Collectors.toList());

System.out.println(lessThanFive);  // [1, 2, 3, 4]

Важно отметить, что takeWhile() работает корректно только с отсортированными потоками, где порядок элементов имеет значение.
```
- Использование limit() для ограничения количества элементов. Метод limit() позволяет задать максимальное количество элементов, которые нужно обработать в потоке. Хотя это не полный аналог break, иногда он может быть полезен для прерывания обработки после определённого количества элементов.
```java
List<Integer> limitedNumbers = numbers.stream()
                                      .filter(n -> n % 2 == 0)  // Чётные числа
                                      .limit(3)  // Обработаем только первые 3 чётных числа
                                      .collect(Collectors.toList());

System.out.println(limitedNumbers);  // [2, 4, 6]
```
- С использованием dropWhile() (Java 9+). Если вам нужно "отфильтровать" начальную часть потока до тех пор, пока элементы удовлетворяют условию, а затем прекратить фильтрацию, можно использовать метод dropWhile(). Он будет обрабатывать поток до первого элемента, который не соответствует условию, а затем продолжит обработку оставшихся элементов.
```java
List<Integer> numbersToProcess = sortedNumbers.stream()
                                              .dropWhile(n -> n < 5)  // Пропустит элементы < 5, затем продолжит
                                              .collect(Collectors.toList());

System.out.println(numbersToProcess);  // [5, 6, 7, 8, 9]
```
[К оглавлению](#Lambda)

## 33. Возможно ли пропустить элемент потока по аналогии с continue?

Можно использовать filter - фильтрует элементы по условию или return.

```java
    public static void main(String[] args) {
    ArrayList<String> stringList = new ArrayList<>();
    stringList.add("a");
    stringList.add("b");
    stringList.add("c");
    stringList.stream().forEach(str -> {
        if (str.equals("b")) return; // only skips this iteration.
        System.out.println(str); // a c
    });
}
```

[К оглавлению](#Lambda)

## 34. Что такое Optional?

Optional - это класс обертка, основная цель которого предотвратить NullPointerException.

[К оглавлению](#Lambda)

## 35. Перечислите методы Optional.

- Optional.empty() - возвращает Optional с null внутри.
- Optional.of(T value) - возвращает Optional с not null значением внутри.
- Optional.ofNullable(T value) - возвращает Optional который может содержать null значение внутри.

Методы конкретного объекта Optional:

- filter(Predicate<? super T> predicate) - дает возможность отфильтровать значение опционального типа. Мы передаем ему в
  параметр Predicate (это стандартный функциональный интерфейс), он возвращает булево значение. Если значение true, то
  возвращается этот же option, если значение false, то возвращается пустой option Optional.empty().
- flatMap() применяется для изменения значения установленного в option. Функция,
  которая передается в метод flatMap должна возвращать option. Если значение не установлено, вернется Optional.empty().
- get() - возвращает значение из объекта Optional. Нужно аккуратно использовать этот метод, т.к. он может бросить
  исключение NoSuchElementException, если значение в option равно null. Чтобы безопасно использовать этот метод, перед
  его
  вызовом надо вызвать метод isPresent().
- isPresent() - возвращает булево значение true, если в option значение есть и возвращает false, если в option
  значение null.
- orElse(T other) - используется для того, чтобы установить значение по-умолчанию в том случае, если значение в option
  отсутствует.
- orElseGet(Supplier<? extends T> other) - это аналог метода orElse, только принимает в себя функциональный интерфейс,
  который должен вернуть значение.
- orElseThrow(Supplier<? extends X> exceptionSupplier) - используется для того, чтобы бросить исключение, которое
  передается в метод orElseThrow, если значения в option не установлено.
- ifPresent(Consumer<? super T> consumer) - исполняет функциональный интерфейс Consumer, если значение в option
  присутствует. Т.е. в ifPresent передается функция, которая принимает один параметр - значение из Optional.

[К оглавлению](#Lambda)

## 36. В чем разница между методами orElse и orElseGet?

Методы orElse() и orElseGet() в Java относятся к классу Optional и используются для обработки случаев, когда Optional не содержит значения (то есть пуст). Оба метода позволяют задать альтернативное значение на случай, если внутри Optional нет значения, но работают они по-разному.
- Метод orElse() принимает конкретное значение, которое будет возвращено, если Optional пуст. Если Optional содержит значение, то возвращается это значение. Если Optional пуст, то возвращается значение, переданное в метод orElse().
```java
Optional<String> optional = Optional.ofNullable(null);

String result = optional.orElse("Значение по умолчанию");
System.out.println(result);  // Вывод: Значение по умолчанию
```

Проблема с производительностью: Аргумент, передаваемый в orElse(), вычисляется всегда, независимо от того, пуст Optional или нет. То есть, даже если в Optional есть значение, то альтернативное значение всё равно будет создано или вычислено.
```java
String result = optional.orElse(getDefaultValue());  // getDefaultValue() вызовется всегда, даже если Optional не пуст
```
- Метод orElseGet() принимает лямбда-выражение или поставщика (Supplier), который возвращает значение только в том случае, если Optional пуст. Если Optional содержит значение, то возвращается это значение. Если Optional пуст, то вызывается переданный Supplier для получения значения.
```java
Optional<String> optional = Optional.ofNullable(null);

String result = optional.orElseGet(() -> "Значение по умолчанию");
System.out.println(result);  // Вывод: Значение по умолчанию
```

Преимущества orElseGet(): 

1)Код, переданный в orElseGet() (лямбда или метод), выполняется только при необходимости, то есть только если Optional пуст.
2)Это позволяет избежать ненужных вычислений и улучшить производительность в ситуациях, когда получение значения по умолчанию требует времени или ресурсов.

Основные различия:

| **Характеристика** | **orElse()** | **orElseGet()** |
| --- | --- | --- |
| **Тип параметра** | Конкретное значение (всегда вычисляется) | `Supplier` (вычисляется только при необходимости) |
| **Производительность** | Потенциально менее эффективно, если получение значения дорогое | Более эффективно, так как вычисляется только при пустом `Optional` |
| **Когда использовать** | Когда значение по умолчанию просто и не требует вычислений | Когда значение по умолчанию сложно или требует вычислений |

### Вывод:
- orElse() подходит для простых, быстро вычисляемых значений по умолчанию.
- orElseGet() предпочтителен для случаев, когда получение значения по умолчанию требует ресурсов, так как он выполнит вычисление только при необходимости.

[К оглавлению](#Lambda)

## 37. Расскажите про фабричные методы List of, Set of, Map of?

Фабричные методы List.of(), Set.of() и Map.of() были введены в Java 9 для удобного создания неизменяемых коллекций. Эти
методы позволяют быстро и легко создавать коллекции без
необходимости использовать стандартные конструкторы и добавлять элементы вручную.

Основные особенности:

Неизменяемость: Коллекции, созданные с помощью этих методов, неизменяемы, то есть их нельзя изменить после создания.
Попытка добавить или удалить элемент приведет к выбросу исключения UnsupportedOperationException.

Отсутствие null: Эти методы не допускают null в качестве элементов коллекции. Если попытаться передать null в любой из
методов, будет выброшено NullPointerException.

Оптимизация: Коллекции, созданные с помощью этих методов, оптимизированы по производительности и занимаемой памяти,
особенно в случае небольших коллекций.

Почему неизменяемые:
- Безопасность и Надёжность: Неизменяемые коллекции защищены от изменений после их создания. 
Это предотвращает случайные изменения данных, что особенно важно в многопоточных приложениях,
где изменения коллекций из разных потоков могут привести к ошибкам.

- Упрощение кода: Неизменяемые объекты проще использовать, потому что их состояние не меняется. 
Это упрощает понимание и отладку кода, так как не нужно беспокоиться о том, 
что состояние коллекции может быть изменено в любой момент.

- Повышение производительности: Неизменяемые коллекции могут быть оптимизированы лучше, 
так как не нужно учитывать возможность изменения их структуры (например, добавления или удаления элементов).
Это может привести к улучшению производительности, особенно в случаях, когда неизменяемые коллекции часто передаются 
между методами.

- Удобство использования в функциональном программировании: Java с каждым обновлением всё больше поддерживает элементы 
функционального программирования, и неизменяемость является важной концепцией в этой парадигме. Неизменяемые коллекции 
хорошо сочетаются с такими функциональными стилями программирования, как лямбда-выражения и стримы.

- Снижение вероятности ошибок: Изменяемые коллекции могут приводить к ошибкам, связанным с изменением состояния 
(например, изменение коллекции во время её обхода). Неизменяемость помогает избежать таких проблем.

[К оглавлению](#Lambda)

## 38. Для чего используется var?

Использование var может сделать код более кратким без ущерба для удобочитаемости, а в некоторых случаях может улучшить
читаемость благодаря устранению избыточности.

Нельзя использовать var без самого значения, потому что JDK нужно знать тип переменной, а тип можно извлечь только из
значения.

[К оглавлению](#Lambda)

## 39. В каких случаях можно использовать var?

Может использоваться при объявлении локальных переменных, включая индексные переменные цикла for и ресурсные переменные
оператора try-with-resources

[К оглавлению](#Lambda)



