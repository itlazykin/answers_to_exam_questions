## Lambda

[1. Что такое lambda-выражение?](#1-Что-такое-lambda-выражение)

[2. Что такое функциональные интерфейсы?](#2-Что-такое-функциональные-интерфейсы)

[3. Перечислите функциональные интерфейсы из пакета java util function](#3-Перечислите-функциональные-интерфейсы-из-пакета-java-util-function)

[4. Что такое функции высшего порядка?](#4-Что-такое-функции-высшего-порядка)

[5. Какие функциональные интерфейсы из пакета java util function поддерживают функции высшего порядка?](#5-Какие-функциональные-интерфейсы-из-пакета-java-util-function-поддерживают-функции-высшего-порядка)

[6. Что такое ссылки на методы?](#6-Что-такое-ссылки-на-методы)

[7. Что такое ссылки на конструкторы?](#7-Что-такое-ссылки-на-конструкторы)

[8. Расскажите о зоне видимости переменных в lambda выражениях?](#8-Расскажите-о-зоне-видимости-переменных-в-lambda-выражениях)

[9. Как быть в ситуации, если внутри lambda выражения операторы могут выкинуть исключение?](#9-Как-быть-в-ситуации-если-внутри-lambda-выражения-операторы-могут-выкинуть-исключение)

[10. Что такое Stream API?](#10-Что-такое-Stream-API)

[11. Расскажите, какие шаблоны проектирования используются внутри Stream API? (Builder, Strategy, Decorator, Factory Method, Pipeline).](#11-Расскажите-какие-шаблоны-проектирования-используются-внутри-Stream-API-Builder-Strategy-Decorator-Factory-Method-Pipeline)

[12. Объясните, где они используются в Stream API.](#12-Объясните-где-они-используются-в-Stream-API)

[13. Что такое конвейерные и терминальные операции?](#13-Что-такое-конвейерные-и-терминальные-операции)

[14. Перечислите конвейерные (промежуточные) методы Stream API.](#14-Перечислите-конвейерные-промежуточные-методы-Stream-API)

[15. Перечислите терминальные методы Stream API.](#15-Перечислите-терминальные-методы-Stream-API)

[16. Что такое отложенное выполнение lambda?](#16-Что-такое-отложенное-выполнение-lambda)

[17. Что делает метод filter()?](#17-Что-делает-метод-filter)

[18. Что делает метод map()?](#18-Что-делает-метод-map)

[19. Что делает метод flatMap()?](#19-Что-делает-метод-flatMap)

[20. Что делает метод collect?](#20-Что-делает-метод-collect)

[21. Что делает метод findFirst?](#21-Что-делает-метод-findFirst)

[22. Что делает метод reduce?](#22-Что-делает-метод-reduce)

[23. Что делают методы min и max?](#23-Что-делают-методы-min-и-max)

[24. Что делают методы count, sum, average?](#24-Что-делают-методы-count-sum-average)

[25. Что делают методы forEach и peek?](#25-Что-делают-методы-forEach-и-peek)

[26. Что делают методы skip и limit?](#26-Что-делают-методы-skip-и-limit)

[27. Что делают методы allMatch(), noneMatch() и anyMatch()?](#27-Что-делают-методы-allMatch-noneMatch-и-anyMatch)

[28. Что делают методы mapToInt(), flatMapToInt(), mapToObj()?](#28-Что-делают-методы-mapToInt-flatMapToInt-mapToObj)

[29. Что такое числовой поток?](#29-Что-такое-числовой-поток)

[30. Чем отличается Stream <<Integer>> от IntStream <<int>> ?](#30-Чем-отличается-Stream-Integer-от-IntStream-int)

[31. Что делает метод boxed?](#31-Что-делает-метод-boxed)

[32. Возможно ли прервать выполнение потока по аналогии с break?](#32-Возможно-ли-прервать-выполнение-потока-по-аналогии-с-break)

[33. Возможно ли пропустить элемент потока по аналогии с continue?](#33-Возможно-ли-пропустить-элемент-потока-по-аналогии-с-continue)

[34. Что такое Optional?](#34-Что-такое-Optional)

[35. Перечислите методы Optional.](#35-Перечислите-методы-Optional)

[36. В чем разница между методами orElse и orElseGet?](#36-В-чем-разница-между-методами-orElse-и-orElseGet)

[37. Расскажите про фабричные методы List of, Set of, Map of?](#37-Расскажите-про-фабричные-методы-List-of-Set-of-Map-of)

[38. Для чего используется var?](#38-Для-чего-используется-var)

[39. В каких случаях можно использовать var?](#39-В-каких-случаях-можно-использовать-var)

## 1. Что такое lambda-выражение?

Лямбда-выражение (или lambda-выражение) — это компактный способ представления анонимной функции в Java. Оно было введено
в Java 8 и позволяет выразить функциональность более лаконично, особенно при работе с функциональными интерфейсами.
Лямбда-выражение — это блок кода, который можно передать и выполнить в другом месте.

Ключевые особенности:
+ Анонимность: lambda-выражения не имеют имени и не объявляются как отдельные методы.
+ Функциональный интерфейс: lambda-выражения должны соответствовать одному функциональному интерфейсу (интерфейсу с одним абстрактным методом).
+ Компактность: они предоставляют краткий и удобный способ выражения функциональности без необходимости создания отдельных классов или методов.
+ Более читаемый код: lambda-выражения могут сделать код более читабельным, особенно в контексте событийных обработчиков, коллекций и потоков.

Синтаксис:

```java
(параметры) -> { тело выражения }
```

Пример:

```java
// Интерфейс с одним абстрактным методом
interface MathOperation {
  int operation(int a, int b);
}

// Lambda-выражение, реализующее интерфейс MathOperation
MathOperation addition = (a, b) -> a + b;

// Использование lambda-выражения
int result = addition.operation(5, 3); // result = 8
```

Преимущества:
+ Сокращение кода: lambda-выражения делают код более кратким и лаконичным.
+ Улучшенная читабельность: Они могут сделать код более читаемым, особенно в контексте функционального программирования.
+ Гибкость: lambda-выражения могут использоваться в разных контекстах, например, в потоках, событиях и лямбда-выражениях.
+ Функциональное программирование: lambda-выражения позволяют использовать парадигму функционального программирования в Java.

Использование:
+ Обработки событий: в GUI-приложениях и других сценариях обработки событий.
+ Коллекции: для фильтрации, сортировки, преобразования элементов в коллекциях.
+ Потоки: для параллельной обработки данных.
+ Функциональное программирование: для создания функциональных объектов и применения функциональных операций.


[К оглавлению](#Lambda)

## 2. Что такое функциональные интерфейсы?

Функциональный интерфейс в Java - это интерфейс, который содержит один абстрактный метод.

Ключевые особенности:
+ Один абстрактный метод: интерфейс может содержать дополнительные методы по умолчанию и статические методы, но должен иметь ровно один абстрактный метод, который должен быть реализован при использовании интерфейса.
+ Аннотация `@FunctionalInterface`:  эта аннотация не является обязательной, но рекомендуется использовать ее, чтобы явно показать, что интерфейс предназначен для использования в функциональном стиле. Компилятор проверяет, что интерфейс действительно соответствует определению функционального интерфейса, и выдает ошибку, если это не так.

Зачем использовать функциональные интерфейсы?
+ Лямбда-выражения:  функциональные интерфейсы позволяют использовать лямбда-выражения, которые являются более кратким и лаконичным способом  определения анонимных функций.
+ Методы ссылок:  функциональные интерфейсы могут использоваться для создания ссылок на методы, что делает код более читаемым и компактным.
+ Функциональное программирование:  функциональные интерфейсы являются ключевой частью функционального программирования в Java, позволяя писать код, который является более чистым, более легким для тестирования и более надежным.

[К оглавлению](#Lambda)

## 3. Перечислите функциональные интерфейсы из пакета java util function

Supplier (поставщик) используется для создания какого-либо объекта и при этом ему не требуется входной параметр.

```java

@FunctionalInterface
public interface Supplier<T> {
    T get();
}
```

Consumer (потребитель) используется в том случае, если нам нужно применить какое-то действие или операцию к параметру (
для BiConsumer два параметра) и при этом у метода нет возвращаемого значения. Два интерфейса отличаются только одним –
количеством параметров, которые принимает метод в этом интерфейсе. Параметры в Bi-consumer могут быть разных типов.

```java

@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);
}

@FunctionalInterface
public interface BiConsumer<T, U> {
    void accept(T t, U u);
}
```

Predicate (утверждение) наиболее часто применяется в фильтрах и сравнении. В метод test() передается один или два
параметра, в зависимости от функционального интерфейса и возвращает логическое значение true или false.

```java

@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
}

@FunctionalInterface
public interface BiPredicate<T, U> {
    boolean test(T t, U u);
}
```

Function используется для преобразования входного параметра или двух параметров (для Bi-формы этого функционального
интерфейса) в какое-либо значение, тип возвращаемого значения может не совпадать с типом входных параметров. Все три
типа в обобщениях в BiFunction могут быть разными: принимает на вход 2 разных типа и возвращает третий тип.

```java

@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
}

@FunctionalInterface
public interface BiFunction<T, U, R> {
    R apply(T t, U u);
}
```

UnaryOperator и BinaryOperator – это разновидность Function, в которых входные и выходные обобщенные параметры должны
совпадать.

```java

@FunctionalInterface
public interface UnaryOperator<T> extends Function<T, T> {
}

@FunctionalInterface
public interface BinaryOperator<T> extends BiFunction<T, T, T> {
}
```

Помимо абстрактных методов функциональные интерфейсы могут иметь целый набор статических методов или методы по
умолчанию.

Predicate<Integer> predicate = x -> x > 5;

Consumer<Integer> consumer = x -> System.out.println(x);

Function<Integer, String> function = x -> x.toString();

Supplier<Integer> supplier = () -> new Integer(5);

UnaryOperator<Integer> unaryOperator = x -> x*x;

BinaryOperator<Integer> binaryOperator = (x, y) -> x * y

BiConsumer<T,U>;
BiFunction<T,U,R>;
BinaryOperator<T>;
BiPredicate<T,U>;
BooleanSupplier;
Consumer<T>;
DoubleBinaryOperator;
DoubleConsumer;
DoubleFunction<R>;
DoublePredicate;
DoubleSupplier;
DoubleToIntFunction;
DoubleToLongFunction;
DoubleUnaryOperator;
Function<T,R>;
IntBinaryOperator;
IntConsumer;
IntFunction<R>;
IntPredicate;
IntSupplier;
IntToDoubleFunction;
IntToLongFunction;
IntUnaryOperator;
LongBinaryOperator;
LongConsumer;
LongFunction<R>;
LongPredicate;
LongSupplier;
LongToDoubleFunction;
LongToIntFunction;
LongUnaryOperator;
ObjDoubleConsumer<T>;
ObjIntConsumer<T>;
ObjLongConsumer<T>;
Predicate<T>;
Supplier<T>;
ToDoubleBiFunction<T,U>;
ToDoubleFunction<T>;
ToIntBiFunction<T,U>;
ToIntFunction<T>;
ToLongBiFunction<T,U>;
ToLongFunction<T>;
UnaryOperator<T>;

[К оглавлению](#Lambda)

## 4. Что такое функции высшего порядка?

Функции высшего порядка (Higher-order functions) – это функции, которые могут принимать другие функции в качестве
аргументов или возвращать функции в качестве результата. В Java эта концепция появилась с версии 8 и стала возможной
благодаря появлению лямбда-выражений и функциональных интерфейсов.

Основные характеристики:

+ Принимают функции в качестве аргументов: Функция может принимать другую функцию как параметр, позволяя ей выполнять
  операции с другими функциями.
+ Возвращают функции в качестве результата: Функция может вернуть другую функцию как результат, предоставляя возможность создания новых функций на основе входных данных.

[К оглавлению](#Lambda)

## 5. Какие функциональные интерфейсы из пакета java util function поддерживают функции высшего порядка?

В пакете `java.util.function` все функциональные интерфейсы поддерживают функции высшего порядка.

Как функциональные интерфейсы поддерживают функции высшего порядка?

Принимая функции в качестве аргументов:
+ Методы `andThen()`, `compose()`, `apply()` в `Function<T, R>` принимают другие функции в качестве аргументов.
+ Методы `and()`, `negate()` в `Predicate<T>` принимают другие предикаты в качестве аргументов.
+ Методы `andThen()`, `compose()` в `Consumer<T>` принимают другие действия в качестве аргументов.
+ Методы `andThen()`, `compose()` в `UnaryOperator<T>` и `BinaryOperator<T>` принимают другие операторы в качестве аргументов.
+ Методы `thenComparing()`, `reversed()` в `Comparator<T>` принимают другие компараторы в качестве аргументов.

Возвращая функции в качестве результата:
+ Методы `andThen()`, `compose()` в `Function<T, R>` возвращают новые функции.
+ Методы `and()`, `negate()` в `Predicate<T>` возвращают новые предикаты.
+ Методы `andThen()`, `compose()` в `Consumer<T>` возвращают новые действия.
+ Методы `andThen()`, `compose()` в `UnaryOperator<T>` и `BinaryOperator<T>` возвращают новые операторы.
+ Методы `thenComparing()`, `reversed()` в `Comparator<T>` возвращают новые компараторы.

Примеры:

```java
// Пример использования andThen() в Function
Function<String, Integer> toInteger = Integer::parseInt;
Function<Integer, String> toString = Object::toString;
Function<String, String> convertToString = toInteger.andThen(toString);
String result = convertToString.apply("123"); // result == "123"

// Пример использования and() в Predicate
Predicate<Integer> isEven = i -> i % 2 == 0;
Predicate<Integer> isPositive = i -> i > 0;
Predicate<Integer> isEvenAndPositive = isEven.and(isPositive);
boolean result = isEvenAndPositive.test(4); // result == true
```

[К оглавлению](#Lambda)

## 6. Что такое ссылки на методы?

Ссылки на методы в Java — это одна из возможностей, введенных в Java 8,
которая позволяет ссылаться на существующие методы или конструкторы и использовать их в контексте,
где ожидается функциональный интерфейс.
Это сокращает количество кода, делая его более читаемым и выразительным.
Ссылки на методы (Method References) – это компактные лямбда выражения для методов у которых уже есть имя. Такая ссылка
позволяет обращаться к методу, не вызывая его. Для создания ссылки на метод служит следующая общая форма:
`имя_класса :: имя_метода`

Было:

```java
Consumer<String> consumer = str -> System.out.println(str);
```

Стало:

```java
Consumer<String> consumer = System.out::println;
```

Вызов метода println идет через двойное двоеточие (::), а не через точку (.)

[К оглавлению](#Lambda)

## 7. Что такое ссылки на конструкторы?

Аналогично ссылкам на методы, ссылки также можно объявлять и на конструкторы.

`ИмяКласса::new`

Такую ссылку можно присвоить любой ссылке на функциональный интерфейс, где определяется метод, совместимый с
конструктором. При этом "ИмяКласса" не может быть интерфейсом или абстрактным классом. При использовании конструкторов
методы функционального интерфейса должны принимать тот же список параметров, что и конструкторы класса, и должны
возвращать объект данного класса.

[К оглавлению](#Lambda)

## 8. Расскажите о зоне видимости переменных в lambda выражениях

- переменная, объявленная внутри лямбда-выражения,
  доступна только в самом лямбда-выражении.

- переменная, объявленная вне лямбда-выражения,
  доступна как внутри лямбда-выражения, так и вне его.

- переменную, объявленную вне лямбда-выражения,
  изменять внутри лямбда-выражения нельзя.

Если в лямбда-выражении используется локальная переменная, объявленная
на уровне класса вне этого выражения (-то есть локальная переменная метода),
то это называется захватом переменной. Захваченную переменную, так как
в лямбда-выражении захваченная переменная не может быть
изменена после своей инициализации. Можно использовать
либо переменные с модификатором final, либо effective final переменные.
Effective final - это обычные переменные, только
которые больше не изменяются после своей инициализации.
Если переменной присваивается значение во 2-й раз, то лямбда-выражение вызовет
ошибку компиляции. Можно ссылаться на:

- effective final локальные переменные;
- поля примитивных типов;
- статические переменные.

[К оглавлению](#Lambda)

## 9. Как быть в ситуации, если внутри lambda выражения операторы могут выкинуть исключение?

Лямбда-выражение может генерировать исключение.

- если тело лямбда-выражения может бросить проверяемое checked исключение, то оно должно быть объявлено в абстрактном
  методе целевого функционального интерфейса в выражении throws.
- либо должно быть обработано внутри лямбда-выражения с помощью конструкции try-catch-finally.

Как известно из функциональных интерфейсов в Stream API нельзя выбрасывать контролируемые исключения. Если по каким-то
причинам это необходимо (например, работа с файлами, базами данных или по сети), приходится оборачивать их в
RuntimeException.

[К оглавлению](#Lambda)

## 10. Что такое Stream API?

Начиная с JDK 8 в Java появился новый API - Stream API.
Его задача - упростить работу с наборами данных, в частности,
упростить операции фильтрации, сортировки и другие манипуляции с данными.

Вся основная функциональность данного API сосредоточена в
пакете java.util.stream.

Ключевым понятием в Stream API является поток данных.

Поток представляет канал передачи данных из источника данных.
Причем в качестве источника могут выступать как файлы, так и массивы и коллекции.

Одной из отличительных черт Stream API является применение лямбда-выражений.

[К оглавлению](#Lambda)

## 11. Расскажите, какие шаблоны проектирования используются внутри Stream API? (Builder, Strategy, Decorator, Factory Method, Pipeline).

"Builder" (Строитель),
"Strategy" (Стратегия),
"Decorator" (Декоратор),
"Factory Method" (Фабричный метод),
"Pipeline" (Конвейер),
"Adapter" (Адаптер),
"Iterator" (Итератор)

[К оглавлению](#Lambda)

## 12. Объясните, где они используются в Stream API.

- Шаблон "Builder" позволяет пошагово конструировать сложные объекты.
  В контексте Stream API этот шаблон используется для создания цепочек операций,
  которые будут применяться к потоку данных.

Пример: Вызовы методов на стриме - filter, map, sorted, и т.д.,
возвращают новый стрим, позволяя продолжать наращивать цепочку операций.

- Шаблон "Decorator" позволяет динамически добавлять поведение к объекту.
  В Stream API это проявляется в виде того, что каждый метод обработки,
  такой как filter, map, distinct, и т.д., возвращает новый стрим,
  который оборачивает исходный стрим и добавляет к нему новое поведение.

Пример: Методы фильтрации, маппинга и сортировки "оборачивают" исходный стрим, добавляя к нему дополнительное поведение.

- "Pipeline" — это шаблон, который подразумевает последовательное выполнение операций,
  где выход одного этапа является входом следующего.
  В Stream API данные проходят через конвейер операций, таких как фильтрация, преобразование и агрегация.

Пример: В Stream API данные проходят через последовательность промежуточных операций
(например, filter, map) и завершающей операции (collect, forEach).

- Шаблон "Iterator" (Итератор)
  Описание: Шаблон "Iterator" предоставляет способ последовательного доступа к
  элементам коллекции без раскрытия ее внутреннего представления.
  Stream API использует итераторы для обхода элементов потока.

Пример: Когда вы создаете стрим из коллекции, он использует итератор для последовательного доступа к элементам
коллекции.

- Шаблон "Strategy" определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.
- В Stream API различные операции, такие как map, filter, reduce, представляют собой стратегии обработки данных.

Пример: Операции map, filter, reduce определяют разные стратегии обработки данных в потоке.

- Шаблон "Factory Method" предоставляет интерфейс для создания объектов,
  но позволяет подклассам изменять тип создаваемых объектов.
  В Stream API фабричные методы используются для создания стримов из различных источников
  (например, из коллекций, массивов, файлов и т.д.).

Пример: Методы Stream.of(), Arrays.stream() и Collection.stream()
являются примерами фабричных методов, которые создают стримы.

- Шаблон "Adapter" позволяет интерфейсам, которые несовместимы друг с другом, работать вместе.
  В Stream API адаптеры используются для преобразования разных источников данных в стримы.

Пример: Методы, которые преобразуют коллекции, массивы или другие структуры данных в стримы
(например, Arrays.stream(), Collection.stream()), реализуют шаблон "Adapter".

[К оглавлению](#Lambda)

## 13. Что такое конвейерные и терминальные операции?

- Промежуточные (конвейерные). Преобразовывают элементы потока, возвращая новый преобразованный поток. Методов данного
  типа может быть сколько угодно в цепочке преобразований элементов потока. Данные методы ленивы, то есть отрабатывают
  только когда для потока вызван конечный метод. Промежуточных методов у потока может и не быть. Промежуточные операции
  не выполняются без конечных. Промежуточные методы ленивы - они начинают вычисляться только когда начнется терминальная
  операция, то есть вычисление происходит только тогда, когда оно нужно.


- Конечные (терминальные). Метод данного типа всегда один, располагается в конце цепочки промежуточных методов (если
  они есть). Данный метод возвращает другой тип объекта (например, Optional, коллекцию и т.д.). То есть конечный
  метод собирает результаты обработки элементов потока и возвращает единый результат. Конечный метод для завершения
  потока обязателен.

[К оглавлению](#Lambda)

## 14. Перечислите конвейерные (промежуточные) методы Stream API.

- filter() - фильтрует элементы потока, возвращая только элементы, удовлетворяющие условию.
- map() - преобразует каждый элемент потока.
- mapToInt() - тот же map(), но возвращает поток примитивов int (также есть соответствующие mapToDouble() и
  mapToLong()).
- flatMap() - трансформирует каждый объект потока в поток других объектов, то есть все элементы коллекции коллекций или
  потока потоков трансформирует в единый поток. (также поддерживает возврат потоков примитивов с помощью методов
  flatMapToInt(), flatMapToDouble(), flatMapToLong()). Может преобразовывать элементы, применяя указанную функцию к
  каждому элементу.
- peek() - выполняет действие для каждого элемента потока, возвращая поток, состоящий из измененных элементов.
- sorted() - сортирует элементы потока по возрастанию. Возможна сортировка по убыванию при передаче соответствующего
  компаратора.
- skip() - пропускает указанное число элементов с начала потока.
- limit() - делает выборку первых элементов из родного потока в указанном количестве (отбирает элементы из потока, пока
  не достигнет указанного количества).
- distinct() - убирает дубликаты из потока.
- mapToObj() - трансформирует числовой поток в объектный.

[К оглавлению](#Lambda)

## 15. Перечислите терминальные методы Stream API.

- forEach() - используется для выполнения действия над каждым элементом потока завершая поток. Он применяется,
  когда вам нужно выполнить какую-то операцию над каждым элементом потока, но при этом не требуется возвращать
  результат.
- collect() - собирает все элементы потока в структуру данных.
- findFirst() - получает первый элемент из потока.
- toArray() - собирает элементы потока в массив.
- count() - возвращает количество элементов в потоке.
- min() - возвращает минимальный элемент (условие передается в компараторе).
- max() - возвращает максимальный элемент (условие передается в компараторе).
- sum() - возвращает сумму всех элементов потока (только для числовых потоков).
- average() - возвращает среднее арифметическое всех элементов потока (только для числовых потоков).
- allMatch() - возвращает true, если все элементы удовлетворяют условию.
- noneMatch() - возвращает true, если все элементы не удовлетворяют условию.
- reduce() - используется для выполнения агрегатных операций над элементами потока.

[К оглавлению](#Lambda)

## 16. Что такое отложенное выполнение lambda?

Лямбда обладает свойством отложенного выполнения. Отложенное выполнение начинает вычисление только тогда, когда
пользователь запросил его результат. У отложенного выполнения есть и "брат-близнец" - ленивая загрузка (lazy load).
Ленивая загрузка упоминается чаще в контексте загрузки элементов или объектов.
Например, загрузка классов ссылочных полей загружаемого класса будет выполняться только тогда,
когда к ним произойдёт явное обращение в программе.

Другой способ - это eager aka энергичная загрузка, когда вся последовательность элементов загружается сразу,
а не только когда элемент необходим.

Отложенное выполнение более точно описывает процесс, происходящий в лямбде -
код внутри неё начнет выполняться только тогда, когда произойдёт обращение за его результатом.

[К оглавлению](#Lambda)

## 17. Что делает метод filter()?

Конвейерная операция. Используется для фильтра элементов в коллекции.
Он принимает функцию-предикат в качестве аргумента и возвращает новый поток, содержащий только те элементы,
для которых функция-предикат возвращает истину.

[К оглавлению](#Lambda)

## 18. Что делает метод map()?

Конвейерная операция. Метод map() принимает в качестве аргумента функциональный интерфейс Function, задающий
преобразование, применяемое к каждому элементу. Возвращаемый поток содержит преобразованные элементы.
Метод map() возвращает новый поток. Он не изменяет исходный поток и коллекцию. Обычно он используется для выполнения
операций, таких как преобразование элементов из одного типа в другой.

[К оглавлению](#Lambda)

## 19. Что делает метод flatMap()?

Конвейерная операция. Метод flatMap() используется для создания одного потока из множества потоков.
Он принимает функцию в качестве аргумента, которая применяется к каждому элементу исходного потока.
Эта функция принимает элемент исходного потока и возвращает новый поток.

Разница между map() и flatMap()
Метод map() преобразует элемент исходного потока из одного типа в другой. В отличие от этого, метод flatMap()
позволяет получить новый поток из элементов коллекций, которые были внутри элементов первого потока.
Таким образом, если вам нужно изменить каждый элемент и получить стрим простых объектов, используйте map().
Если ваши элементы сами содержат коллекции или стримы, и вы хотите "сплющить" их в один стрим, используйте flatMap().

[К оглавлению](#Lambda)

## 20. Что делает метод collect?

Терминальная операция. Используется для сбора элементов в коллекции с использованием заданной функции.
Он принимает функцию в качестве аргумента и применяет ее к каждому элементу коллекции,
собирая результаты в новую коллекцию. (toList(); toSet(); toMap())

[К оглавлению](#Lambda)

## 21. Что делает метод findFirst?

Терминальная операция. Метод findFirst в Java предназначен для поиска первого элемента в коллекции,
удовлетворяющий заданному условию. Он принимает предикат в качестве параметра и возвращает первый элемент коллекции,
для которого предикат вернет true, возвращает значение, обернутое в тип Optional.
Если такого элемента не существует, метод бросает исключение NoSuchElementException.

[К оглавлению](#Lambda)

## 22. Что делает метод reduce?

Терминальная операция. Метод reduce() в Java Stream API используется для выполнения агрегатных операций над элементами
потока.
Метод reduce() позволяет свести последовательность элементов к одному значению,
что полезно для задач, связанных с обработкой коллекций данных.
Он берет элементы потока, объединяет их с помощью указанной операции и возвращает одно значение.
В основном, reduce() используется для таких задач, как суммирование, нахождение произведения,
объединение строк и других операций, которые сводятся к одному результату. Он отличается от метода collect() тем,
что использует ассоциативную функцию, принимающую два значения и объединяющую их в одно.

[К оглавлению](#Lambda)

## 23. Что делают методы min и max?

Терминальные операции.

- min() - возвращает минимальный элемент потока. Наименьший элемент определяется с помощью компаратора, который
  передается в параметр метода.
- max() - возвращает максимальный элемент потока. Наибольший элемент определяется с помощью компаратора, который
  передается в параметр метода.

[К оглавлению](#Lambda)

## 24. Что делают методы count, sum, average?

Терминальные операции.

- count() - возвращает число элементов в потоке.
- sum() - суммирует все элементы потока. Применяется только к числовым потокам.
- average() - возвращает среднее арифметическое всех элементов потока. Применяется только к числовым потокам.

[К оглавлению](#Lambda)

## 25. Что делают методы forEach и peek?

- peek() - это конвейерная операция. Выполняет действие для каждого элемента потока, возвращая поток, состоящий из
  измененных элементов.
- forEach() - это терминальная операция. Выполняет действие для каждого элемента потока, завершая поток. Он применяется,
  когда вам нужно выполнить какую-то операцию над каждым элементом потока, но при этом не требуется возвращать
  результат.

Peek() чаще используется в отладочных целях для вывода состояния элемента в потоке, нежели для каких-либо
преобразований.

[К оглавлению](#Lambda)

## 26. Что делают методы skip и limit?

Конвейерные операции.

- skip(n) - пропускает первые n элементов с начала потока. То есть задает начальную границу
  диапазона перебираемых элементов. Параметром нельзя задать отрицательное число, а если заданное значение параметра
  равно или превышает число элементов в исходной структуре данных, то будет возвращен пустой поток.
- limit(n) - возвращает новый поток, содержащий только первые n элементов из исходного потока,
  то есть задает конечную границу диапазона перебираемых элементов. Нельзя задать отрицательное значение параметра. Этот
  метод перебирает элементы, пока не накопит указанное количество элементов, после чего завершает перебор исходной
  структуры данных и возвращает новый поток из собранных элементов.

[К оглавлению](#Lambda)

## 27. Что делают методы allMatch(), noneMatch() и anyMatch()?

Это терминальные методы проверки элементов на соответствие заданному условию. Все эти методы принимают Predicate в
качестве параметра (условия для проверки).

- noneMatch() - возвращает true, если ни один из элементов потока не удовлетворяет условию.
- anyMatch() - возвращает true, если как минимум один из элементов потока удовлетворяет условию.
- allMatch() - возвращает true, если все элементы потока удовлетворяют условию.

[К оглавлению](#Lambda)

## 28. Что делают методы mapToInt(), flatMapToInt(), mapToObj()?

Это конвейерные методы преобразования потока объектов в поток примитивов и преобразования потока примитивов обратно в
поток объектов.

- mapToInt() - преобразовывает поток объектов в поток примитивных чисел типа int. Применяется, если исходящий поток
  состоит из элементов-объектов, а в результате их обработки будет получен примитивный
  тип int. Метод mapToInt возвращает объект интерфейса IntStream (числовой поток), который в дальнейшем обрабатывается
  как поток примитивных чисел. Класс Stream помимо метода mapToInt() также имеет аналогичные ему методы mapToDouble() и
  mapToLong(), работающие с Double и Long типами соответственно.
- flatMapToInt() - трансформирует поток массивов в поток примитивных чисел int. flatMapToInt() последовательно запускает
  поток из каждого массива исходящего потока, в результате чего все элементы этих массивов объединяются в один общий
  поток примитивных чисел int.
- mapToObj() - преобразует поток примитивных чисел в поток объектов.

[К оглавлению](#Lambda)

## 29. Что такое числовой поток?

Это специальный тип потоков, предназначенный для работы с примитивными типами данных: int, long и double.
Использование числовых потоков позволяет избежать авто упаковки и авто распаковки (boxing/unboxing),
что улучшает производительность при работе с большими объемами данных.

Типы числовых потоков:
IntStream — поток целых чисел типа int.
LongStream — поток целых чисел типа long.
DoubleStream — поток чисел с плавающей точкой типа double.
Методы этих интерфейсов предоставляют набор удобных методов для работы с числами, что делает код более лаконичным и
производительным.(sum, average, min, max, count, range, rangeCloset, mapToObj)

[К оглавлению](#Lambda)

## 30. Чем отличается Stream Integer от IntStream int?

- Stream<Integer<Integer>> - это поток объектов типа Integer.
- IntStream <int<int>> - это поток примитивных чисел int.
  Отличаются по типу данных, в производительности и наборе методов. Когда используем Stream - происходит авто упаковка и
  авто распаковка, увеличивая затраты на производительность, особенно при обработке больших объемов данных.
  Stream<Integer>: Предоставляет стандартные методы для работы с потоками, такие как filter(), map(), reduce(), и так
  далее. Но если вы хотите выполнить какие-то специфические операции с числами (например, посчитать сумму или среднее
  значение), нужно будет использовать дополнительные преобразования или методы.
  IntStream: Предоставляет специализированные методы для работы с числами, такие как sum(), average(), min(), max(),
  range(), rangeClosed(), и другие, что упрощает и ускоряет выполнение числовых операций.

  [К оглавлению](#Lambda)

## 31. Что делает метод boxed?

Метод полезен, когда нужно перейти от работы с примитивными типами к объектам. Он оборачивает примитивы и делает их
объектами.

[К оглавлению](#Lambda)

## 32. Возможно ли прервать выполнение потока по аналогии с break?

Прямого аналога оператора break в Stream API нет, но можно использовать такие методы, как limit(), takeWhile(),
findFirst() или findAny(), чтобы достичь аналогичного результата, прерывая выполнение стрима при выполнении определенных
условий. Если требуется более сложное управление, можно создать собственную логику с использованием блока forEach и
исключений, но это менее элегантное и не рекомендуемое решение.

[К оглавлению](#Lambda)

## 33. Возможно ли пропустить элемент потока по аналогии с continue?

Можно использовать filter - фильтрует элементы по условию или return.

```java
    public static void main(String[] args) {
    ArrayList<String> stringList = new ArrayList<>();
    stringList.add("a");
    stringList.add("b");
    stringList.add("c");
    stringList.stream().forEach(str -> {
        if (str.equals("b")) return; // only skips this iteration.
        System.out.println(str); // a c
    });
}
```

[К оглавлению](#Lambda)

## 34. Что такое Optional?

Optional - это класс обертка, основная цель которого предотвратить NullPointerException.

[К оглавлению](#Lambda)

## 35. Перечислите методы Optional.

- Optional.empty() - возвращает Optional с null внутри.
- Optional.of(T value) - возвращает Optional с not null значением внутри.
- Optional.ofNullable(T value) - возвращает Optional который может содержать null значение внутри.

Методы конкретного объекта Optional:

- filter(Predicate<? super T> predicate) - дает возможность отфильтровать значение опционального типа. Мы передаем ему в
  параметр Predicate (это стандартный функциональный интерфейс), он возвращает булево значение. Если значение true, то
  возвращается этот же option, если значение false, то возвращается пустой option Optional.empty().
- flatMap() применяется для изменения значения установленного в option. Функция,
  которая передается в метод flatMap должна возвращать option. Если значение не установлено, вернется Optional.empty().
- get() - возвращает значение из объекта Optional. Нужно аккуратно использовать этот метод, т.к. он может бросить
  исключение NoSuchElementException, если значение в option равно null. Чтобы безопасно использовать этот метод, перед
  его
  вызовом надо вызвать метод isPresent().
- isPresent() - возвращает булево значение true, если в option значение есть и возвращает false, если в option
  значение null.
- orElse(T other) - используется для того, чтобы установить значение по-умолчанию в том случае, если значение в option
  отсутствует.
- orElseGet(Supplier<? extends T> other) - это аналог метода orElse, только принимает в себя функциональный интерфейс,
  который должен вернуть значение.
- orElseThrow(Supplier<? extends X> exceptionSupplier) - используется для того, чтобы бросить исключение, которое
  передается в метод orElseThrow, если значения в option не установлено.
- ifPresent(Consumer<? super T> consumer) - исполняет функциональный интерфейс Consumer, если значение в option
  присутствует. Т.е. в ifPresent передается функция, которая принимает один параметр - значение из Optional.

[К оглавлению](#Lambda)

## 36. В чем разница между методами orElse и orElseGet?

Основное различие между ними заключается в том, когда и как вычисляется значение, которое возвращается в случае, если
объект Optional пуст.

Когда вычисляется other: Значение other передается в метод orElse как параметр и вычисляется независимо от того,
присутствует ли значение в Optional или нет. Это означает, что если other - это результат вычисления какого-то метода
или сложного выражения, оно будет выполнено независимо от того, нужно оно или нет.

Когда вычисляется Supplier: В отличие от orElse, метод orElseGet принимает Supplier, который является функциональным
интерфейсом, предоставляющим значение только при необходимости. Это означает, что функция Supplier будет вызвана и
вычислена только в том случае, если объект Optional пуст.

[К оглавлению](#Lambda)

## 37. Расскажите про фабричные методы List of, Set of, Map of?

Фабричные методы List.of(), Set.of() и Map.of() были введены в Java 9 для удобного создания неизменяемых коллекций. Эти
методы позволяют быстро и легко создавать коллекции без
необходимости использовать стандартные конструкторы и добавлять элементы вручную.

Основные особенности:

Неизменяемость: Коллекции, созданные с помощью этих методов, неизменяемы, то есть их нельзя изменить после создания.
Попытка добавить или удалить элемент приведет к выбросу исключения UnsupportedOperationException.

Отсутствие null: Эти методы не допускают null в качестве элементов коллекции. Если попытаться передать null в любой из
методов, будет выброшено NullPointerException.

Оптимизация: Коллекции, созданные с помощью этих методов, оптимизированы по производительности и занимаемой памяти,
особенно в случае небольших коллекций.

Почему неизменяемые:
- Безопасность и Надёжность: Неизменяемые коллекции защищены от изменений после их создания. 
Это предотвращает случайные изменения данных, что особенно важно в многопоточных приложениях,
где изменения коллекций из разных потоков могут привести к ошибкам.

- Упрощение кода: Неизменяемые объекты проще использовать, потому что их состояние не меняется. 
Это упрощает понимание и отладку кода, так как не нужно беспокоиться о том, 
что состояние коллекции может быть изменено в любой момент.

- Повышение производительности: Неизменяемые коллекции могут быть оптимизированы лучше, 
так как не нужно учитывать возможность изменения их структуры (например, добавления или удаления элементов).
Это может привести к улучшению производительности, особенно в случаях, когда неизменяемые коллекции часто передаются 
между методами.

- Удобство использования в функциональном программировании: Java с каждым обновлением всё больше поддерживает элементы 
функционального программирования, и неизменяемость является важной концепцией в этой парадигме. Неизменяемые коллекции 
хорошо сочетаются с такими функциональными стилями программирования, как лямбда-выражения и стримы.

- Снижение вероятности ошибок: Изменяемые коллекции могут приводить к ошибкам, связанным с изменением состояния 
(например, изменение коллекции во время её обхода). Неизменяемость помогает избежать таких проблем.

[К оглавлению](#Lambda)

## 38. Для чего используется var?

Использование var может сделать код более кратким без ущерба для удобочитаемости, а в некоторых случаях может улучшить
читаемость благодаря устранению избыточности.

Нельзя использовать var без самого значения, потому что JDK нужно знать тип переменной, а тип можно извлечь только из
значения.

[К оглавлению](#Lambda)

## 39. В каких случаях можно использовать var?

Может использоваться при объявлении локальных переменных, включая индексные переменные цикла for и ресурсные переменные
оператора try-with-resources
[К оглавлению](#Lambda)



