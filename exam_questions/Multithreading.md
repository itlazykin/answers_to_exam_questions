## Multithreading

[1. Чем отличается процесс от потока?](#1-чем-отличается-процесс-от-потока)

[2. Каким образом можно создать поток?](#2-каким-образом-можно-создать-поток)

[3. Как работают методы sleep, yield, wait, notify и notifyAll?](#3-как-работают-методы-sleep-yield-wait-notify-и-notifyall)

[4. Объясните следующие термины: монитор, мьютекс, критическая секция.](#4-объясните-следующие-термины-монитор-мьютекс-критическая-секция)

[5. Как работает join()?](#5-как-работает-join)

[6. Что такое DeadLock? Приведите примеры.](#6-что-такое-deadlock-приведите-примеры)

[7. Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.](#7-назовите-различия-между-collectionssynchronizedmapnew-hashmap-и-concurrenthashmap)

[8. Различия в интерфейсах Runnable и Callable.](#8-различия-в-интерфейсах-runnable-и-callable)

[9. Различия между isInterrupted(), interrupted(), interrupt().](#9-различия-между-isinterrupted-interrupted-interrupt)

[10. Что происходит при вызове Thread.interrupt()?](#10-что-происходит-при-вызове-threadinterrupt)

[11. Перечислите ВСЕ причины по которым может быть выброшено InterruptedException.](#11-перечислите-все-причины-по-которым-может-быть-выброшено-interruptedexception)

[12. Назовите отличия synchronized{} и ReentrantLock.](#12-назовите-отличия-synchronized-и-reentrantlock)

[13. Приведите наиболее существенное отличие между CountDownLatch и CyclicBarrier.](#13-приведите-наиболее-существенное-отличие-между-countdownlatch-и-cyclicbarrier)

[14. Приведите наиболее существенное отличие между CyclicBarrier и Phaser.](#14-приведите-наиболее-существенное-отличие-между-cyclicbarrier-и-phaser)

[15. Расскажите про Exchanger.](#15-расскажите-про-exchanger)

[16. Отличие Thread.start() и Thread.run()?](#16-отличие-threadstart-и-threadrun)

[17. Объясните ключевое слово volatile.](#17-объясните-ключевое-слово-volatile)

[18. Расскажите про приоритеты потока](#18-расскажите-про-приоритеты-потока)

[19. Что такое потоки-демоны?](#19-что-такое-потоки-демоны)

[20. Назовите все возможные состояния потока.](#20-назовите-все-возможные-состояния-потока)

[21. Что такое race condition?](#21-что-такое-race-condition)

[22. Что такое Thread Local переменная?](#22-что-такое-thread-local-переменная)

[23. Что такое FutureTask?](#23-что-такое-futuretask)

[24. Что такое Thread Pool?](#24-что-такое-thread-pool)

[25. Что такое Semaphore?](#25-что-такое-semaphore)

[26. Чем отличается submit от execute у ExecutorService?](#26-чем-отличается-submit-от-execute-у-executorservice)

[27. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?](#27-чем-отличается-shutdown-от-shutdownnow-у-threadpoolexecutor)

[28. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.](#28-как-создать-threadpool-у-executorservice-только-на-1-на-5-на-неограниченное-количество-потоков)

[29. Что такое ReadWriteLock?](#29-что-такое-readwritelock)

[30. В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt() и FutureTask.cancel().](#30-в-чём-отличие-thread-от-futuretask-в-чём-отличие-threadinterrupt-и-futuretaskcancel)

[31. Расскажите про шаблон проектирования Producer Consumer.](#31-расскажите-про-шаблон-проектирования-producer-consumer)

[32. Как можно запустить параллельный поток (parallelStream)?](#32-как-можно-запустить-параллельный-поток-parallelstream)

[33. Что делают методы parallel и sequential?](#33-что-делают-методы-parallel-и-sequential)

[34. Расскажите про порядок следования элементов в параллельном потоке и его особенностях.](#34-расскажите-про-порядок-следования-элементов-в-параллельном-потоке-и-его-особенностях)

[35. В чем разница между методами forEach и forEachOrdered?](#35-в-чем-разница-между-методами-foreach-и-foreachordered)

[36. В чем разница между применением метода peek() в последовательном и параллельном потоках?](#36-в-чем-разница-между-применением-метода-peek-в-последовательном-и-параллельном-потоках)

[37. Что делает метод unordered?](#37-что-делает-метод-unordered)

[38. Когда имеет смысл распараллеливать поток и какие при этом должны соблюдаться условия?](#38-когда-имеет-смысл-распараллеливать-поток-и-какие-при-этом-должны-соблюдаться-условия)

[39. Расскажите про Java NIO и её главные составляющие.](#39-расскажите-про-java-nio-и-её-главные-составляющие)

[40. Что такое канал?](#40-что-такое-канал)

[41. Что такое буфер?](#41-что-такое-буфер)

[42. Что такое селектор?](#42-что-такое-селектор)

[43. Когда есть смысл использовать Java NIO?](#43-когда-есть-смысл-использовать-java-nio)

[44. Что такое PipedStreams? Как они устроены?](#44-что-такое-pipedstreams-как-они-устроены)

# 1. Чем отличается процесс от потока?

Процесс и поток — это два ключевых понятия в многозадачности, но они отличаются по своему "масштабу" и организации
работы в операционной системе.

`Процесс` — это изолированная единица выполнения. Каждый процесс имеет свой собственный адрес в памяти, свои ресурсы (
например, файлы, переменные окружения) и свою собственную память. Процессы могут работать параллельно, но они не могут
напрямую взаимодействовать друг с другом без использования специальных механизмов (например, межпроцессного
взаимодействия — IPC). Если процесс завершится, то все ресурсы, связанные с ним, освобождаются.

`Поток` (или тред) — это более легковесная единица исполнения, которая существует внутри процесса. Потоки в рамках
одного процесса разделяют общую память и ресурсы процесса. Это позволяет потокам работать быстрее, поскольку им не нужно
создавать отдельные ресурсы для каждого потока. Однако это также создает некоторые риски, например, проблемы с
синхронизацией при доступе к общей памяти.

#### Важные различия:

+ Процесс имеет свою собственную память и ресурсы, а потоки внутри процесса делят общую память и ресурсы.
+ Процесс может содержать несколько потоков, а поток не существует без процесса.
+ Создание и управление процессами более ресурсоемко, чем создание и управление потоками.

Простой пример: представь себе, что процесс — это целый офис с множеством рабочих мест, а потоки — это сотрудники,
которые работают в этом офисе. Все сотрудники используют общие ресурсы офиса (столы, компьютеры), но каждый сотрудник
выполняет свою задачу.

[К оглавлению](#Multithreading)

# 2. Каким образом можно создать поток?

1. Реализовать интерфейс Runnable

Это более гибкий способ, так как позволяет наследовать другие классы (например, от Thread), если это необходимо.

#### Вот как это работает:

+ Создаешь класс, который реализует интерфейс Runnable.
+ Переопределяешь метод run(), который будет содержать код, выполняемый потоком.
+ Создаешь объект типа Thread, передавая ему экземпляр класса, реализующего Runnable.
+ Запускаешь поток с помощью метода start().
```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
    System.out.println("Поток работает!");
 }
}

public class Main {
public static void main(String[] args) {
    MyRunnable myRunnable = new MyRunnable();
    Thread thread = new Thread(myRunnable); // Создаем поток
    thread.start(); // Запускаем поток
 }
}
```
2. Наследовать от класса Thread

Другой способ — это создать класс, который наследует Thread и переопределить метод run(). Это работает так же, как и с
Runnable, но с некоторыми ограничениями, например, нельзя наследовать от других классов, потому что Java поддерживает
только одно наследование.

```java
class MyThread extends Thread {
    @Override
    public void run() {
    System.out.println("Поток работает!");
 }
}

public class Main {
    public static void main(String[] args) {
    MyThread thread = new MyThread(); // Создаем поток
    thread.start(); // Запускаем поток
 }
}
```

3. С помощью лямбда - выражений, передается в конструктор Thread и реализует интерфейс Runnable. Это более современный и
   компактный способ создания потоков в Java, особенно с появлением лямбда-выражений в Java 8.

```java
public class ConcurrentOutput {
    public static void main(String[] args) {
        Thread another = new Thread(
                () -> System.out.println(Thread.currentThread().getName())
        );
        another.start();
        System.out.println(Thread.currentThread().getName());
    }
}
```

#### Главное отличие:

+ Runnable: позволяет создавать потоки, не ограничивая возможность наследовать другие классы.
+ Thread: удобен, если нужно сразу работать с потоками, но не позволяет наследовать другие классы.

#### Как работает поток?

Когда ты вызываешь start(), система вызывает метод run() в новом потоке. Важно помнить, что если ты вызовешь просто
run(), то код выполнится в текущем потоке, а не в новом.

[К оглавлению](#Multithreading)

# 3. Как работают методы sleep, yield, wait, notify и notifyAll?

1. Thread.sleep()

Этот метод временно приостанавливает выполнение текущего потока на заданное количество времени. После завершения паузы
поток продолжает работу.

+ Где применяется: для создания задержек в выполнении программы.
+ Особенности:
    + Поток, вызвавший sleep, переходит в состояние TIMED_WAITING.
    + Метод бросает InterruptedException, если поток будет прерван во время сна.

```java
try {
Thread.sleep(1000); // Поток "засыпает" на 1 секунду
} catch (InterruptedException e) {
e.printStackTrace();
}
```

2. Thread.yield()

Этот метод сигнализирует планировщику потоков, что текущий поток готов уступить место другим потокам с таким же или
более высоким приоритетом.

+ Где применяется: редко, обычно для оптимизации многопоточных программ.
+ Особенности:
    + Это всего лишь рекомендация, и планировщик потоков может проигнорировать ее.
    + Поток остается в состоянии RUNNABLE.
```java
Thread.yield(); // Текущий поток может уступить место другим потокам
```

3. wait()

Метод используется для временной приостановки потока до тех пор, пока другой поток не вызовет notify() или notifyAll()
на том же объекте.

+ Где применяется: при реализации межпоточного взаимодействия (например, Producer-Consumer паттерн).
+ Особенности:
  + Вызывается только на мониторе объекта, т.е. внутри синхронизированного блока или метода.
    + Поток переходит в состояние WAITING до вызова notify() или notifyAll().

```java
synchronized (lock) {
lock.wait(); // Текущий поток ждет сигнала
}
```
4. notify()

Этот метод пробуждает один поток, который ждет на мониторе данного объекта.

+ Где применяется: для пробуждения потоков, ожидающих на wait().
+ Особенности:
  + Какой именно поток будет пробужден, определяется системой (нет гарантии).
  + Вызывается внутри синхронизированного блока или метода.
```java
synchronized (lock) {
lock.notify(); // Будет пробужден один ожидающий поток
}
```
5. notifyAll()

Этот метод пробуждает все потоки, которые ожидают на мониторе данного объекта.

+ Где применяется: когда нужно пробудить все ожидающие потоки.
+ Особенности:
    + Все пробужденные потоки начинают конкурировать за монитор.
```java
synchronized (lock) {
lock.notifyAll(); // Все ожидающие потоки будут пробуждены
}
```

| Метод     | Контекст использования	             | Поток           | Требует synchronized |
|-----------|-------------------------------------|-----------------|----------------------|
| sleep     | Задержка выполнения                 | Текущий поток   | Нет                  |
| yield     | Уступка другим потокам              | Текущий поток   | Нет                  |
| wait      | Ожидание сигнала                    | Ожидающий поток | Да                   |
| notify    | Пробуждение одного потока           | Ждущие потоки   | Да                   |
| notifyAll | Пробуждение всех ожидающих потоков	 | Ждущие потоки   | Да                   |

```java
Пример взаимодействия wait и notify:

class SharedResource {
    private boolean isReady = false;

    public synchronized void waitForReady() {
        while (!isReady) {
            try {
                wait(); // Ожидание сигнала
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("Готово к работе!");
    }

    public synchronized void setReady() {
        isReady = true;
        notify(); // Сигнал одному ожидающему потоку
    }
}

public class Main {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();

        new Thread(resource::waitForReady).start();

        try {
            Thread.sleep(1000); // Имитация задержки
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        resource.setReady(); // Уведомление о готовности
    }
}

```

[К оглавлению](#Multithreading)

# 4. Объясните следующие термины: монитор, мьютекс, критическая секция.

Эти термины связаны с синхронизацией потоков и управлением доступом к общим ресурсам, чтобы избежать проблем, таких как
состояние гонки. Давай разберем каждый термин.

1. Монитор (Monitor)

Монитор — это абстракция для управления доступом к общим ресурсам. В Java монитор ассоциирован с каждым объектом, и он
используется для обеспечения мутуальной исключительности и координации потоков.

Как работает:
Каждый объект в Java имеет встроенный монитор, который захватывается с помощью ключевого слова synchronized.
Если поток "захватил" монитор объекта, другие потоки, пытающиеся войти в синхронизированный блок/метод, должны ждать,
пока монитор освободится.
```java
synchronized (lock) {
// Захват монитора объекта lock
System.out.println("Монитор активен!");
// Освобождение монитора после выхода из блока
}
```
#### Зачем нужен монитор:
+ Для управления доступом к критическим секциям (о них чуть ниже). 
+ Для координации потоков с помощью методов wait, notify, notifyAll.

2. Мьютекс (Mutex)

Мьютекс (сокращение от "mutual exclusion" — взаимное исключение) — это низкоуровневый механизм, который гарантирует, что
к критической секции или ресурсу одновременно имеет доступ только один поток.

Как работает:
Поток захватывает мьютекс, чтобы получить доступ к ресурсу.
Если мьютекс уже захвачен другим потоком, остальные потоки блокируются до тех пор, пока мьютекс не освободится.

В Java:
synchronized выполняет роль мьютекса.
Также можно использовать класс ReentrantLock из пакета java.util.concurrent.locks.
```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class MutexExample {
private final Lock lock = new ReentrantLock();

    public void criticalSection() {
        lock.lock(); // Захват мьютекса
        try {
            System.out.println("Доступ к ресурсу получен!");
        } finally {
            lock.unlock(); // Освобождение мьютекса
        }
    }
}
```
3. Критическая секция (Critical Section)

Критическая секция — это участок кода, который должен быть выполнен атомарно, то есть без вмешательства других потоков.
Обычно это код, который обращается к общим ресурсам, например, переменным или файлам.

Зачем нужна:
Чтобы предотвратить состояние гонки, когда несколько потоков одновременно читают и изменяют общий ресурс.

Как защищается:
Используя мьютекс или монитор.


```java
public class Counter {
private int count = 0;

    public synchronized void increment() { // Критическая секция
        count++;
    }

    public synchronized int getCount() { // Критическая секция
        return count;
    }
}

synchronized гарантирует, что к переменной count одновременно обращается только один поток.
```

| Метод              | Что это?	                                    | Как реализуется в Java?     | Пример использования           |
|--------------------|----------------------------------------------|-----------------------------|--------------------------------|
| Монитор            | Механизм синхронизации, связанный с объектом | synchronized, wait/notify   | Управление доступом к объекту  |
| Мьютекс            | простейший тип синхронизатора нитей          | synchronized, ReentrantLock | Блокировка ресурсов            |
| Критическая секция | Участок кода, выполняемый атомарно           | synchronized                | Обеспечение целостности данных |

Если представить это метафорой:

+ Критическая секция — это сейф, куда кладут ценные вещи.
+ Мьютекс — это ключ от сейфа, который есть только у одного человека в каждый момент времени.
+ Монитор — это охранник, который следит за тем, чтобы ключ использовался правильно.

[К оглавлению](#Multithreading)

# 5. Как работает join()?

Метод join() в Java используется для синхронизации потоков. Он позволяет одному потоку дождаться завершения другого
потока - перед тем, как продолжить выполнение.

#### Как работает join()?

+ Когда один поток вызывает метод join() на другом потоке, текущий поток блокируется и переходит в состояние WAITING,
  пока вызываемый поток не завершится.
+ После завершения вызываемого потока текущий поток продолжает выполнение.

#### Ключевые моменты:

+ Поток вызывает join() на другом потоке:
Например, поток main вызывает join() на потоке t. Тогда main будет ждать, пока поток t завершится.

+ Может выбросить InterruptedException:
Если поток, вызвавший join(), будет прерван, выбрасывается исключение.

+ Можно указать тайм-аут:
Метод join() имеет перегруженные версии с параметрами времени, позволяя ждать завершения потока только в течение
заданного интервала.

```java
public class JoinExample {
    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            System.out.println("Thread 1 starts working.");
            try {
                Thread.sleep(2000); // Симуляция работы
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Thread 1 finishes working.");
        });

        thread1.start();

        try {
            System.out.println("Main thread is waiting for Thread 1.");
            thread1.join(); // Ожидание завершения потока thread1
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Main thread continues.");
    }
}

Вывод программы:
Thread 1 starts working.
Main thread is waiting for Thread 1.
Thread 1 finishes working.
Main thread continues.
        
Основной поток (main) приостанавливается после строки 
Main thread is waiting for Thread 1. и продолжает 
выполнение только после завершения потока thread1.
```

```java
Пример с тайм-аутом:

public class JoinWithTimeout {
    public static void main(String[] args) {
        Thread thread2 = new Thread(() -> {
            try {
                Thread.sleep(5000); // Поток "работает" 5 секунд
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Thread 2 finishes working.");
        });

        thread2.start();

        try {
            System.out.println("Main thread is waiting for Thread 2 (with timeout).");
            thread2.join(2000); // Ждем поток thread2 максимум 2 секунды
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Main thread continues.");
    }
}

Вывод программы:
Main thread is waiting for Thread 2 (with timeout).
Main thread continues.
Thread 2 finishes working.

основной поток ждет thread2 только 2 секунды. 
После этого он продолжает выполнение, 
даже если thread2 еще не завершился.
```

#### Когда использовать join()?

+ Когда нужно дождаться завершения одного или нескольких потоков перед выполнением следующего кода.
Пример: завершение загрузки данных из файлов или выполнения задач в фоновых потоках перед обработкой результатов.

[К оглавлению](#Multithreading)

# 6. Что такое DeadLock? Приведите примеры.

Deadlock — это ситуация, когда два или более потоков навсегда блокируются, ожидая друг друга, потому что каждый из них
удерживает ресурс, который нужен другому.

#### Условия возникновения Deadlock:
+ Взаимное исключение (Mutual Exclusion): Ресурс может быть занят только одним потоком одновременно.
+ Удержание и ожидание (Hold and Wait): Поток удерживает ресурс и ждет доступ к другому.
+ Нет принудительного освобождения (No Preemption): Ресурс не может быть принудительно изъят у потока.
+ Цикл ожидания (Circular Wait): Есть цепочка потоков, где каждый ждет ресурс, занятый следующим потоком.

```java
Рассмотрим классический пример: 
два потока захватывают два ресурса в разном порядке, 
вызывая взаимную блокировку.

public class DeadlockExample {
    private static final Object LOCK1 = new Object();
    private static final Object LOCK2 = new Object();

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            synchronized (LOCK1) {
                System.out.println("Thread 1: захватил LOCK1");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Thread 1: ожидает LOCK2");
                synchronized (LOCK2) {
                    System.out.println("Thread 1: захватил LOCK2");
                }
            }
        });
        Thread thread2 = new Thread(() -> {
            synchronized (LOCK2) {
                System.out.println("Thread 2: захватил LOCK2");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Thread 2: ожидает LOCK1");
                synchronized (LOCK1) {
                    System.out.println("Thread 2: захватил LOCK1");
                }
            }
        });
        thread1.start();
        thread2.start();
    }
}

Что произойдет:
Поток 1 захватывает LOCK1 и ждет LOCK2.
Поток 2 захватывает LOCK2 и ждет LOCK1.
Возникает Deadlock, так как оба потока ждут друг друга, но никто не освобождает свои ресурсы.

Вывод:
Thread 1: захватил LOCK1
Thread 2: захватил LOCK2
Thread 1: ожидает LOCK2
Thread 2: ожидает LOCK1
// Блокировка. Программа "виснет".

```
#### Как избежать Deadlock?

+ Фиксированный порядок захвата ресурсов: Если все потоки захватывают ресурсы в одном и том же порядке, Deadlock не
  возникнет.
```java
synchronized (LOCK1) {
    synchronized (LOCK2) {
        // Код
    }
}
```

+ Использование tryLock:
  Класс ReentrantLock из пакета java.util.concurrent.locks предоставляет метод tryLock, который пытается захватить
  ресурс, но не блокирует поток, если это невозможно.

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class TryLockExample {
    private static final Lock lock1 = new ReentrantLock();
    private static final Lock lock2 = new ReentrantLock();

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            if (lock1.tryLock()) {
                try {
                    System.out.println("Thread 1: захватил lock1");
                    if (lock2.tryLock()) {
                        try {
                            System.out.println("Thread 1: захватил lock2");
                        } finally {
                            lock2.unlock();
                        }
                    }
                } finally {
                    lock1.unlock();
                }
            }
        });
        Thread thread2 = new Thread(() -> {
            if (lock2.tryLock()) {
                try {
                    System.out.println("Thread 2: захватил lock2");
                    if (lock1.tryLock()) {
                        try {
                            System.out.println("Thread 2: захватил lock1");
                        } finally {
                            lock1.unlock();
                        }
                    }
                } finally {
                    lock2.unlock();
                }
            }
        });
        thread1.start();
        thread2.start();
    }
}
```
+ Использование тайм-аутов:
При захвате ресурсов можно использовать методы с тайм-аутом, чтобы избежать бесконечного ожидания.

#### Пример взаимоблокировки с потоками в метафоре

Представь двух людей, каждый из которых держит вилку и хочет взять нож у другого, чтобы поесть. Они стоят, не отпуская
вилок, ожидая, пока другой отдаст нож. Это и есть Deadlock: никто не может продолжить, потому что никто не уступает.

Чтобы избежать этого:

+ Пусть каждый человек сначала кладет вилку, а потом берет нож.
+ Или пусть один из них подождет определенное время и попробует снова.

[К оглавлению](#Multithreading)

# 7. Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.

Обе эти структуры предназначены для работы с потоками, но их реализация и поведение значительно различаются.

1. Блокировка (Locking)

   `Collections.synchronizedMap(new HashMap())`

+ Синхронизация всей карты:
  + Все методы, работающие с картой, синхронизированы с использованием одного единственного мьютекса. Это значит, что
    весь объект блокируется, даже если только одна операция выполняется.
    Например, чтение или запись будет блокировать доступ ко всей карте для других потоков.

`ConcurrentHashMap`

+ Разделенная блокировка (Segmented Locking):
  + Использует более тонкую гранулярность блокировки: блокируются только определённые части карты (ранее — сегменты, в
    современных версиях — корзины).
    Это позволяет нескольким потокам одновременно работать с разными частями карты без конфликтов.

2. Производительность
   `Collections.synchronizedMap(new HashMap())`

+ Медленнее в многопоточной среде:
  + Из-за глобальной блокировки производительность падает при увеличении числа потоков.
  + Подходит только для случаев, где запись/чтение выполняется редко, а многопоточность минимальна.

`ConcurrentHashMap`

+ Быстрее в многопоточной среде:
  + Благодаря разделению блокировок, больше потоков могут одновременно выполнять операции чтения и записи.
  + Идеально подходит для высоконагруженных приложений.

3. Поддержка конкурентного доступа
   `Collections.synchronizedMap(new HashMap())`

+ Не поддерживает итерацию без ошибок (fail-safe):
При модификации карты во время итерации будет выброшено ConcurrentModificationException.

`ConcurrentHashMap`

+ Поддерживает конкурентную итерацию:
  + Использует механизм "ослабленной консистентности" (weakly consistent):
  + Изменения, сделанные другими потоками, могут быть видны или не видны во время итерации, но исключения не
    выбрасываются.

4. Наличие null ключей и значений
   `Collections.synchronizedMap(new HashMap())`

+ Разрешает null ключи и значения: Один null ключ и множество null значений допустимы.

`ConcurrentHashMap`

+ Не разрешает null:
  + Ключи и значения не могут быть null.
    Это сделано, чтобы избежать неоднозначностей в многопоточной среде (например, если get(null) возвращает null,
    непонятно, отсутствует ли ключ или значение равно null).

5. Пример использования

```java
Collections.synchronizedMap(new HashMap())

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

public class SynchronizedMapExample {
  public static void main(String[] args) {
    Map<String, String> map = Collections.synchronizedMap(new HashMap<>());
    map.put("1", "one");
    map.put("2", "two");
    synchronized (map) {
      for (Map.Entry<String, String> entry : map.entrySet()) {
        System.out.println(entry.getKey() + " -> " + entry.getValue());
      }
    }
  }
}
Замечание: Для итерации нужно вручную синхронизировать блок, 
так как внутренняя синхронизация не гарантирует безопасной итерации.
```

```java
ConcurrentHashMap

import java.util.concurrent.ConcurrentHashMap;

public class ConcurrentHashMapExample {
  public static void main(String[] args) {
    ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();

    map.put("1", "one");
    map.put("2", "two");

    for (Map.Entry<String, String> entry : map.entrySet()) {
      System.out.println(entry.getKey() + " -> " + entry.getValue());
    }
  }
}
Замечание: Дополнительной синхронизации для итерации не требуется.
```

| Критерий            | Collections.synchronizedMap	   | ConcurrentHashMap                      |
|---------------------|--------------------------------|----------------------------------------|
| Количество потоков  | Небольшое                      | Высоконагруженные многопоточные задачи |
| Частота операций    | Низкая (редкие чтения/записи)  | Частое чтение/запись                   |
| Итерация            | Требуется ручная синхронизация | Безопасна для многопоточной итерации   |
| null ключи/значения | Поддерживает                   | Не поддерживает                        |

[К оглавлению](#Multithreading)

# 8. Различия в интерфейсах Runnable и Callable.

Оба интерфейса используются для создания задач, которые могут выполняться в потоках, но они имеют разные возможности и
предназначение.

| Критерий                     | Runnable	                                                  | Callable                                                                                  |
|------------------------------|------------------------------------------------------------|-------------------------------------------------------------------------------------------|
| Пакет                        | Находится в пакете java.lang.                              | Находится в пакете java.util.concurrent.                                                  |
| Метод                        | Содержит метод: void run().                                | Содержит метод: V call() throws Exception.                                                |
| Возвращаемое значение        | Ничего не возвращает (тип void).                           | Возвращает значение (тип V).                                                              |
| Обработка исключений         | Исключения должны обрабатываться внутри метода run.        | Может выбрасывать проверяемые исключения.                                                 |
| Использование                | Подходит для задач, которым не нужно возвращать результат. | Используется для задач, которые возвращают результат или могут выбросить исключение.      |
| Интеграция с ExecutorService | Передается в ExecutorService как задача для выполнения.    | Возвращает объект типа Future<V>, который позволяет получить результат выполнения задачи. |

```java
Пример использования Runnable

public class RunnableExample {
  public static void main(String[] args) {
    Runnable task = () -> {
      System.out.println("Выполняется задача Runnable");
    };
    Thread thread = new Thread(task);
    thread.start();
  }
}

Задача выполняется, но не возвращает результат.
Исключения внутри задачи нужно обрабатывать вручную.
```

```java
Пример использования Callable

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class CallableExample {
  public static void main(String[] args) {
    Callable<String> task = () -> {
      return "Результат выполнения Callable";
    };

    ExecutorService executor = Executors.newSingleThreadExecutor();
    Future<String> future = executor.submit(task);

    try {
      // Получаем результат выполнения задачи
      String result = future.get();
      System.out.println(result);
    } catch (Exception e) {
      e.printStackTrace();
    } finally {
      executor.shutdown();
    }
  }
}

Задача возвращает результат выполнения через объект Future.
Исключения можно обрабатывать через Future.get().
```

#### Когда использовать?

`Runnable`:
+ Для задач, которые выполняются в потоке, но не возвращают результата.
Например: запись данных в файл, логирование.

`Callable`:
+ Для задач, которые возвращают результат или могут выбросить исключение.
Например: выполнение сложных вычислений, запрос данных из базы.

#### Ключевые отличия в метафоре

Представь, что тебе нужно отправить курьера за посылкой:

`Runnable`:
Курьер просто идёт по твоему поручению, но ничего не возвращает. Если что-то пошло не так, тебе нужно было заранее
предусмотреть, как это обработать.
`Callable`:
Курьер возвращается с посылкой, и ты можешь узнать результат его работы. Если произошла ошибка, он сообщает тебе об этом
через исключение.

[К оглавлению](#Multithreading)

# 9. Различия между isInterrupted(), interrupted(), interrupt().

Эти методы относятся к управлению состоянием прерывания потока в Java. Прерывание в Java — это механизм, с помощью
которого один поток может попросить другой поток завершить свою работу.

1. isInterrupted()

+ Проверяет флаг прерывания у текущего объекта потока.
+ Флаг прерывания не сбрасывается.
+ Используется для проверки состояния другого потока.

```java
public class IsInterruptedExample {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                System.out.println("Работаю...");
            }
            System.out.println("Поток прерван.");
        });

        thread.start();
        Thread.sleep(1000); // Даем потоку немного поработать
        thread.interrupt(); // Прерываем поток
    }
}
Поток завершает работу, когда видит, что флаг прерывания установлен.
```

2. interrupted()

+   Статический метод, который проверяет флаг прерывания текущего потока.
+   Сбрасывает флаг прерывания после вызова (ставит его в false).
+   Используется для выполнения действий и одновременного сброса флага.

```java
public class InterruptedExample {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            while (true) {
                if (Thread.interrupted()) {
                    System.out.println("Флаг прерывания сброшен.");
                    break;
                }
            }
        });

        thread.start();
        Thread.sleep(1000); // Даем потоку немного поработать
        thread.interrupt(); // Прерываем поток
    }
}
Поток завершает работу после обнаружения прерывания. 
Флаг прерывания автоматически сбрасывается.
```

3. interrupt()

+   Устанавливает флаг прерывания у целевого потока.
+   Если поток находится в блокирующем состоянии (например, в ожидании sleep, wait), выбрасывается InterruptedException.
```java
public class InterruptExample {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                System.out.println("Поток был прерван во время сна.");
            }
        });

        thread.start();
        Thread.sleep(1000); // Даем потоку немного поспать
        thread.interrupt(); // Прерываем поток
    }
}
Если поток находится в состоянии сна, 
он выходит из него с выбросом InterruptedException.
```

#### Ключевые моменты

+    Используй interrupt() для отправки сигнала потоку.
+    Проверяй состояние флага с помощью isInterrupted(), если не хочешь его сбрасывать.
+    Применяй interrupted(), если необходимо сбросить флаг после проверки.

| Метод           | Класс	               | Описание                                                                                                          |
|-----------------|----------------------|-------------------------------------------------------------------------------------------------------------------|
| isInterrupted() | Thread               | Возвращает true, если текущий поток был прерван. Не сбрасывает флаг прерывания.                                   |
| interrupted()   | Thread (статический) | Проверяет, был ли текущий поток прерван, и сбрасывает флаг прерывания (устанавливает его в false).                |
| interrupt()     | Thread               | Устанавливает флаг прерывания у целевого потока (это просто сигнал, поток решает, как реагировать на прерывание). |

[К оглавлению](#Multithreading)

# 10. Что происходит при вызове Thread.interrupt()?

Метод interrupt() устанавливает флаг прерывания (interruption flag) у указанного потока. Это своего рода сигнал потоку:
«Тебя просят остановиться». Однако, важно понимать, что interrupt() не заставляет поток немедленно завершить работу — он
лишь передает эту просьбу, и поток должен самостоятельно обработать ее.

#### Два сценария при вызове Thread.interrupt()

+ Поток НЕ находится в блокирующем состоянии
  + Флаг прерывания у потока устанавливается в true.
  + Поток может проверить этот флаг с помощью методов isInterrupted() или interrupted() и принять решение о завершении
    работы.

+ Поток находится в блокирующем состоянии
  + Если поток выполняет такие методы, как Thread.sleep(), Object.wait(), join(), или другие методы ожидания, то они
    выбрасывают исключение InterruptedException, и флаг прерывания сбрасывается в false. Поток должен самостоятельно
    обработать это исключение.

```java
Поток НЕ в блокирующем состоянии

public class InterruptExample {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                System.out.println("Работаю...");
            }
            System.out.println("Поток завершает работу.");
        });

        thread.start();
        Thread.sleep(1000); // Даем потоку поработать
        thread.interrupt(); // Прерываем поток
    }
}
Поток продолжает работать, пока флаг прерывания не установлен.
После вызова interrupt(), флаг прерывания становится true, 
и поток завершает свою работу.
```

```java
Поток в блокирующем состоянии

public class InterruptBlockingExample {
  public static void main(String[] args) throws InterruptedException {
    Thread thread = new Thread(() -> {
      try {
        System.out.println("Поток начинает спать...");
        Thread.sleep(5000); // Переход в блокирующее состояние
      } catch (InterruptedException e) {
        System.out.println("Поток прерван во время сна.");
      }
    });

    thread.start();
    Thread.sleep(1000); // Даем потоку начать сон
    thread.interrupt(); // Прерываем поток
  }
}
Поток выходит из состояния сна и выбрасывает InterruptedException.
Обработка исключения позволяет потоку завершить работу.
```

#### Ключевые моменты про interrupt()

+ Не завершает поток немедленно.
  + Поток сам решает, как реагировать на прерывание. Он должен регулярно проверять флаг прерывания или обрабатывать InterruptedException.

+ Необходима обработка InterruptedException.
  + Если поток находится в блокирующем состоянии, такие методы, как sleep(), wait(), или join() выбрасывают исключение, и поток может обработать его для корректного завершения.

+ Используется как сигнал.
  + interrupt() сообщает потоку о необходимости остановиться, но сам по себе ничего не делает, кроме установки флага или генерации исключения в блокирующем состоянии.

[К оглавлению](#Multithreading)

# 11. Перечислите ВСЕ причины по которым может быть выброшено InterruptedException.

#### Причины выброса InterruptedException

В Java исключение InterruptedException выбрасывается, когда поток, находящийся в блокирующем состоянии, получает сигнал
прерывания с помощью метода interrupt(). Блокирующие состояния — это ситуации, когда поток ожидает завершения действия
или освобождения ресурса.
#### Список методов, которые могут выбросить InterruptedException:

+ Методы класса Thread:
  + Thread.sleep(long millis)
  + Thread.sleep(long millis, int nanos)
  +  Thread.join()
  + Thread.join(long millis)
  + Thread.join(long millis, int nanos)

+ Методы синхронизации Object:
  + Object.wait()
  + Object.wait(long timeout)
  + Object.wait(long timeout, int nanos)

+ Методы интерфейса BlockingQueue (и его реализаций, например, ArrayBlockingQueue, LinkedBlockingQueue):
  + put(E e)
  + take()
  + poll(long timeout, TimeUnit unit)
  + offer(E e, long timeout, TimeUnit unit)

+ Методы интерфейса Lock (и его реализаций, например, ReentrantLock):
  + lockInterruptibly()
  + tryLock(long time, TimeUnit unit)

+ Методы интерфейса ExecutorService (и его реализаций, например, ThreadPoolExecutor):
  + invokeAll(Collection<? extends Callable<T>> tasks)
  + invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
  + invokeAny(Collection<? extends Callable<T>> tasks)
  + invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)

+ Методы класса CountDownLatch:
  + await()
  + await(long timeout, TimeUnit unit)

+ Методы класса CyclicBarrier:
  + await()
  + await(long timeout, TimeUnit unit)

+ Методы класса Semaphore:
  + acquire()
  + acquire(int permits)
  + acquireUninterruptibly() (если поток был прерван до вызова метода, но сам метод не выбросит исключение)
  + tryAcquire(long timeout, TimeUnit unit)

+ Методы класса Exchanger:
  + exchange(V x)
  + exchange(V x, long timeout, TimeUnit unit)

+ Методы класса Phaser:
  + awaitAdvanceInterruptibly(int phase)
  + awaitAdvanceInterruptibly(int phase, long timeout, TimeUnit unit)

+ Методы класса Future:
  + get()
  + get(long timeout, TimeUnit unit)

#### Когда выбрасывается InterruptedException?

+ Прерывание сна: Поток вызвал метод sleep() и был прерван.
+ Прерывание ожидания: Поток вызвал методы wait() или await() (на объектах или в синхронизаторах) и был прерван.
+ Прерывание блокировки: Поток пытался захватить блокировку с помощью lockInterruptibly() или аналогичных методов, и в
  это время был прерван.
+ Прерывание работы с синхронизаторами: Поток использовал методы синхронизаторов (таких как CountDownLatch, Semaphore,
  Exchanger, CyclicBarrier) и был прерван.
+ Прерывание выполнения задач: Поток ожидал завершения выполнения задач через методы invokeAll() или invokeAny() и
  получил сигнал прерывания.

#### Ключевые моменты

+ InterruptedException всегда возникает только в блокирующих операциях, когда поток не может немедленно продолжить
  выполнение.
+ Метод, выбрасывающий InterruptedException, сбрасывает флаг прерывания. Поток должен заново установить его, если
  необходимо.
+ Это проверяемое (checked) исключение, которое обязательно нужно обрабатывать или пробрасывать выше.

[К оглавлению](#Multithreading)

# 12. Назовите отличия synchronized{} и ReentrantLock.

1. Синтаксис

`synchronized` — это встроенный механизм, который используется в блоках или методах:
```java
synchronized (object) {
// код с доступом к общим ресурсам
}
```
`ReentrantLock` — это класс из библиотеки java.util.concurrent.locks, который нужно явно создавать и управлять:
```java
ReentrantLock lock = new ReentrantLock();
lock.lock();
try {
    // код с доступом к общим ресурсам
} finally {
    lock.unlock();
}
```
2. Блокировка

`synchronized`:
+ Автоматически блокирует объект.
+ Блокировка освобождается автоматически, когда поток выходит из блока или метода.

`ReentrantLock`:
+ Требует явного вызова lock() для захвата блокировки и unlock() для её освобождения.
+ Если unlock() не вызван (например, из-за исключения), может произойти блокировка ресурса.

3. Попытка захватить блокировку

`synchronized`:
+ Если блокировка занята, поток ждет бесконечно, пока она не будет освобождена.

`ReentrantLock`:
+ Позволяет попытаться захватить блокировку с помощью:
  + tryLock() — не блокирует поток, возвращает false, если блокировка занята.
  + tryLock(long time, TimeUnit unit) — пытается захватить блокировку в течение заданного времени.

4. Ожидание с прерыванием

`synchronized`:
+ Поток, ожидающий захвата блокировки, не может быть прерван. Он будет ждать до тех пор, пока блокировка не освободится.

`ReentrantLock`:
+ Поток может быть прерван с помощью lockInterruptibly(), если его вызвали с сигналом interrupt().

5. Гибкость (Условные переменные)

`synchronized`:
+ Использует встроенные методы wait(), notify(), notifyAll() для управления состоянием потоков.
+ Эти методы работают только с текущим объектом монитора.

`ReentrantLock`:
+ Предоставляет более гибкий механизм через объект Condition, который можно использовать для точного управления
  ожиданием и уведомлением:
```java
Condition condition = lock.newCondition();
condition.await();  // ожидание
condition.signal(); // уведомление одного потока
condition.signalAll(); // уведомление всех потоков
```
6. Производительность

`synchronized`:

+ Начиная с Java 1.6, синхронизация была оптимизирована (например, появился lightweight locking), что делает её
  конкурентоспособной с ReentrantLock в простых случаях.

`ReentrantLock`:
+ Может быть быстрее в сложных сценариях, особенно если требуется управление временем ожидания или использование
  условий.

7. Повторный захват блокировки (Reentrancy)

`synchronized`:
+ Поддерживает повторный захват блокировки одним и тем же потоком.

`ReentrantLock`:
+ Также поддерживает повторный захват блокировки, и предоставляет информацию о количестве захватов через getHoldCount().

8. Отладка

`synchronized`:
+ Труднее получить информацию о состоянии блокировки (например, кто её удерживает).

`ReentrantLock`:
+ Предоставляет методы для получения состояния блокировки:
  + isLocked() — заблокирован ли ресурс.
  + isHeldByCurrentThread() — удерживает ли текущий поток - блокировку.
  + getQueueLength() — количество потоков, ожидающих блокировки.

#### Когда использовать?

`synchronized`:
+ Для простых сценариев синхронизации, где не требуется сложное управление блокировкой или ожиданием.
```java
    synchronized (this) {
        sharedResource++;
    }
```
`ReentrantLock`:

+ Для сложных сценариев, где требуется:
  + Попытка захвата блокировки (tryLock).
  + Управление временем ожидания.
  + Использование условных переменных (Condition).
  + Прерываемое ожидание (lockInterruptibly).

```java
ReentrantLock lock = new ReentrantLock();
try {
    if (lock.tryLock(1, TimeUnit.SECONDS)) {
        sharedResource++;
    }
} finally {
    lock.unlock();
}
```
[К оглавлению](#Multithreading)

# 13. Приведите наиболее существенное отличие между CountDownLatch и CyclicBarrier.

Главное различие между этими двумя синхронизаторами заключается в их назначении и поведении после выполнения задачи:

#### Назначение

`CountDownLatch`:
+ Используется для ожидания завершения определенного числа операций перед продолжением основного потока.
+ Часто применяется, когда основной поток должен дождаться выполнения нескольких потоков.
+ Одноразовый механизм: после того как счетчик (count) доходит до нуля, объект CountDownLatch больше не может быть
   использован.

`CyclicBarrier`:
+ Используется для синхронизации группы потоков: все потоки должны достичь определенной точки (барьера), после чего они
   продолжают выполнение.
+ Повторно используемый механизм: после достижения барьера он сбрасывается и может использоваться снова.

#### Поведение

`CountDownLatch`:
+ Имеет счетчик (count), который уменьшается вызовом метода countDown(). Когда счетчик достигает нуля, потоки,
   вызвавшие метод await(), продолжают выполнение.
+ Потоки, уменьшающие счетчик, не блокируются.

`CyclicBarrier`:
+ Потоки вызывают метод await() и блокируются до тех пор, пока все потоки не достигнут барьера.
+ После достижения барьера все потоки продолжают выполнение.

```java
CountDownLatch: ожидание завершения работы потоков

import java.util.concurrent.CountDownLatch;

public class CountDownLatchExample {
  public static void main(String[] args) throws InterruptedException {
    int threadCount = 3;
    CountDownLatch latch = new CountDownLatch(threadCount);

    for (int i = 0; i < threadCount; i++) {
      new Thread(() -> {
        System.out.println(Thread.currentThread().getName() + " выполняет работу.");
        latch.countDown(); // Уменьшаем счетчик
      }).start();
    }

    latch.await(); // Ждем, пока счетчик станет равным 0
    System.out.println("Все потоки завершили работу.");
  }
}
```

```java
CyclicBarrier: синхронизация потоков

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierExample {
  public static void main(String[] args) {
    int threadCount = 3;
    CyclicBarrier barrier = new CyclicBarrier(threadCount,
            () -> System.out.println("Все потоки достигли барьера. Продолжаем выполнение."));

    for (int i = 0; i < threadCount; i++) {
      new Thread(() -> {
        System.out.println(Thread.currentThread().getName() + " выполняет работу.");
        try {
          barrier.await(); // Ждем, пока все потоки достигнут барьера
        } catch (InterruptedException | BrokenBarrierException e) {
          e.printStackTrace();
        }
      }).start();
    }
  }
}
```

| Характеристика           | CountDownLatch	                          | CyclicBarrier                         |
|--------------------------|------------------------------------------|------------------------------------------|
| Назначение               | Ожидание завершения операций             | Синхронизация группы потоков.            |
| Одноразовый/Многоразовый | Одноразовый                              | Многоразовый                             |
| Методы                   | countDown(), await()                     | await()                                  |
| Поведение потоков        | Уменьшающий счетчик поток не блокируется | Потоки блокируются до достижения барьера |
| Использование            | Координация основного потока с другими   | Синхронизация группы потоков             |

[К оглавлению](#Multithreading)

# 14. Приведите наиболее существенное отличие между CyclicBarrier и Phaser.

Главное различие между этими двумя механизмами синхронизации заключается в их гибкости и управлении числом участников.

#### Назначение

`CyclicBarrier`:
+ Используется для синхронизации фиксированного числа потоков. Все потоки должны достичь барьера, чтобы продолжить
   выполнение.
+ Число участников указывается при создании и остается неизменным на протяжении работы.

`Phaser`:
+ Более гибкий и поддерживает динамическое управление числом участников (регистрация и снятие потоков во время
   выполнения).
+ Используется для синхронизации нескольких этапов (фаз) выполнения группы потоков.

#### Управление участниками

`CyclicBarrier`:
+ Количество участников задается при создании и не может измениться. Все потоки должны достичь барьера.
+ Если поток выбывает (например, прерывается), это может привести к исключению BrokenBarrierException.

`Phaser`:
+ Потоки могут регистрироваться или сниматься динамически с помощью методов register() и arriveAndDeregister().
+ Поддерживает выполнение задач с переменным числом потоков на разных фазах.

#### Поддержка фаз

`CyclicBarrier`:
+ Не поддерживает понятия фаз. Работает с единственной точкой синхронизации.

`Phaser`:
+ Поддерживает многофазные барьеры, где потоки проходят через последовательные этапы.
+ Номер текущей фазы можно получить через getPhase().

```java
CyclicBarrier: синхронизация фиксированного числа потоков

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierExample {
  public static void main(String[] args) {
    int threadCount = 3;
    CyclicBarrier barrier = new CyclicBarrier(threadCount,
            () -> System.out.println("Барьер достигнут. Продолжаем выполнение."));

    for (int i = 0; i < threadCount; i++) {
      new Thread(() -> {
        System.out.println(Thread.currentThread().getName() + " выполняет работу.");
        try {
          barrier.await(); // Ждем, пока все потоки достигнут барьера
        } catch (InterruptedException | BrokenBarrierException e) {
          e.printStackTrace();
        }
      }).start();
    }
  }
}
```

```java
Phaser: синхронизация нескольких фаз

import java.util.concurrent.Phaser;

public class PhaserExample {
  public static void main(String[] args) {
    Phaser phaser = new Phaser(1); // Главный поток регистрируется

    for (int i = 0; i < 3; i++) {
      int phase = i;
      phaser.register(); // Регистрируем новый поток
      new Thread(() -> {
        System.out.println(Thread.currentThread().getName() + " выполняет фазу " + phase);
        phaser.arriveAndAwaitAdvance(); // Завершаем текущую фазу и ждем
      }).start();
    }

    phaser.arriveAndAwaitAdvance(); // Главный поток завершает первую фазу
    System.out.println("Все потоки завершили фазу 0. Продолжаем.");

    phaser.arriveAndDeregister(); // Главный поток снимается с регистрации
  }
}
```

| Характеристика         | CountDownLatch	                            | CyclicBarrier                                          |
|------------------------|--------------------------------------------|--------------------------------------------------------|
| Назначение             | Синхронизация фиксированного числа потоков | Синхронизация потоков с динамическим числом участников |
| Управление участниками | Фиксированное                              | Динамическое (регистрация/снятие участников)           |
| Поддержка фаз          | Нет                                        | Да                                                     |
| Методы                 | await()                                    | arrive(), arriveAndAwaitAdvance(), register()          |
| Гибкость               | Меньше                                     | Больше                                                 |

#### Когда использовать?

+ Используйте CyclicBarrier, если: Число участников известно заранее и не изменяется. Нужна простая точка синхронизации.
+ Используйте Phaser, если: Число участников может изменяться. Нужно синхронизировать выполнение нескольких фаз.

[К оглавлению](#Multithreading)

# 15. Расскажите про Exchanger.

Exchanger — это инструмент из пакета java.util.concurrent, который используется для синхронизации двух потоков, позволяя
им обмениваться данными. Каждый поток предоставляет некоторый объект другому потоку и получает взамен объект от него.

Это удобно в ситуациях, где два потока работают с разделяемыми данными, например, один поток производит данные, а другой
их обрабатывает.

#### Как работает Exchanger?

+ Один поток вызывает метод exchange(), передавая объект для обмена. Этот поток блокируется до тех пор, пока другой
  поток тоже не вызовет exchange().
+ Когда второй поток вызывает exchange(), происходит обмен объектами, и оба потока продолжают выполнение.
+ Если второй поток не вызывает exchange() в течение определенного времени (если указано), первый поток может получить
  исключение TimeoutException.
```java
Сценарий: обмен данными между двумя потоками

import java.util.concurrent.Exchanger;

public class ExchangerExample {
  public static void main(String[] args) {
    Exchanger<String> exchanger = new Exchanger<>();

    // Поток 1: Отправляет сообщение и получает ответ
    new Thread(() -> {
      try {
        String message = "Привет от Потока 1";
        System.out.println("Поток 1 отправляет: " + message);
        String response = exchanger.exchange(message);
        System.out.println("Поток 1 получил: " + response);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }).start();

    // Поток 2: Отправляет ответ и получает сообщение
    new Thread(() -> {
      try {
        String message = "Ответ от Потока 2";
        System.out.println("Поток 2 отправляет: " + message);
        String response = exchanger.exchange(message);
        System.out.println("Поток 2 получил: " + response);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }).start();
  }
}
```

#### Основные методы

+ exchange(T x): передает объект x другому потоку и возвращает объект, переданный этим потоком.
+ exchange(T x, long timeout, TimeUnit unit): делает то же самое, но с указанием времени ожидания. Если другой поток не
  вызовет exchange() за это время, бросается TimeoutException.

#### Когда использовать Exchanger?

+ Обработка данных между потоками: один поток производит данные, другой их обрабатывает (например,
  шифрование/дешифрование).
+ Обмен промежуточными результатами: в больших вычислительных задачах, где потоки обмениваются частичными результатами.
+ Буферизация: один поток наполняет буфер данными, другой поток очищает его.

#### Потенциальные проблемы

+ Блокировка: Если один поток вызвал exchange(), а другой поток не сделал этого, первый поток будет заблокирован.
+ Исключения:
  + InterruptedException: если поток был прерван во время ожидания.
  + TimeoutException: если второй поток не вызвал exchange() за отведенное время.

| Инструмент     | Назначение	                                        |
|----------------|----------------------------------------------------|
| Exchanger      | Обмен данными между двумя потоками                 |
| CountDownLatch | Ожидание завершения работы заданного числа потоков |
| CyclicBarrier  | Синхронизация группы потоков на общей точке        |
| Phaser         | Многофазная синхронизация потоков                  |

[К оглавлению](#Multithreading)

# 16. Отличие Thread.start() и Thread.run()?

Основное различие заключается в том, запускается ли поток параллельно с основным или просто вызывается метод в текущем
потоке.

`Thread.start()`

+ Этот метод запускает новый поток.
+ Создается отдельный поток выполнения, и метод run() выполняется в этом новом потоке.
+ Управление передается планировщику потоков, который решает, когда новый поток начнет выполнение.

```java
public class ThreadStartExample {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> System.out.println("Это выполняется в новом потоке: " + Thread.currentThread().getName()));
        thread.start(); // Запуск нового потока
        System.out.println("Это выполняется в основном потоке: " + Thread.currentThread().getName());
    }
}
```
`Thread.run()`

+ Это обычный вызов метода, который выполняется в текущем потоке.
+ Не запускает новый поток. Метод run() выполняется как обычный метод, вызываемый в текущем потоке.

```java
public class ThreadRunExample {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> System.out.println("Это выполняется в текущем потоке: " + Thread.currentThread().getName()));
        thread.run(); // Выполнение в текущем потоке
        System.out.println("Это выполняется в основном потоке: " + Thread.currentThread().getName());
    }
}
```

| Характеристика           | Thread.start()	                          | Thread.run()                             |
|--------------------------|------------------------------------------|------------------------------------------|
| Создание нового потока   | Да                                       | Нет                                      |
| Параллельное выполнение  | Код в run() выполняется в новом потоке   | Код в run() выполняется в текущем потоке |
| Управление планировщиком | Передает управление планировщику потоков | Не передает управление планировщику      |
| Использование            | Для запуска потоков                      | Для вызова метода как обычного           |

#### Ошибка, которую нужно избегать

Если вместо start() случайно вызвать run(), то новый поток не будет создан, и программа выполнится в одном потоке. Это
может привести к неожиданному поведению, особенно в многопоточных приложениях.

```java
public class ThreadRunMistake {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> System.out.println("Ошибка: выполняется в текущем потоке: " + Thread.currentThread().getName()));
        thread.run(); // Неправильный вызов, поток не создается!
    }
}

```

[К оглавлению](#Multithreading)

# 17. Объясните ключевое слово volatile.

[К оглавлению](#Multithreading)

# 18. Расскажите про приоритеты потока

[К оглавлению](#Multithreading)

# 19. Что такое потоки-демоны?

[К оглавлению](#Multithreading)

# 20. Назовите все возможные состояния потока.

[К оглавлению](#Multithreading)

# 21. Что такое race condition?

[К оглавлению](#Multithreading)

# 22. Что такое Thread Local переменная?

[К оглавлению](#Multithreading)

# 23. Что такое FutureTask?

[К оглавлению](#Multithreading)

# 24. Что такое Thread Pool?

[К оглавлению](#Multithreading)

# 25. Что такое Semaphore?

[К оглавлению](#Multithreading)

# 26. Чем отличается submit от execute у ExecutorService?

[К оглавлению](#Multithreading)

# 27. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?

[К оглавлению](#Multithreading)

# 28. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.

[К оглавлению](#Multithreading)

# 29. Что такое ReadWriteLock?

[К оглавлению](#Multithreading)

# 30. В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt() и FutureTask.cancel().

[К оглавлению](#Multithreading)

# 31. Расскажите про шаблон проектирования Producer Consumer.

```java
public class ParallelSearch {
    public static void main(String[] args) throws InterruptedException {
        SimpleBlockingQueue<Integer> queue = new SimpleBlockingQueue<Integer>(2);
        final Thread consumer = new Thread(
                () -> {
                    while (!Thread.currentThread().isInterrupted()) {
                        try {
                            System.out.println(queue.poll());
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                        }
                    }
                }
        );
       final Thread producer = new Thread(
                () -> {
                    for (int index = 0; index != 3; index++) {
                        try {
                            queue.offer(index);
                            Thread.sleep(500);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
        );
        consumer.start();
        producer.start();
        producer.join();
        consumer.interrupt();
    }
}
```

[К оглавлению](#Multithreading)

# 32. Как можно запустить параллельный поток (parallelStream)?

[К оглавлению](#Multithreading)

# 33. Что делают методы parallel и sequential?

[К оглавлению](#Multithreading)

# 34. Расскажите про порядок следования элементов в параллельном потоке и его особенностях.

[К оглавлению](#Multithreading)

# 35. В чем разница между методами forEach и forEachOrdered?

[К оглавлению](#Multithreading)

# 36. В чем разница между применением метода peek() в последовательном и параллельном потоках?

[К оглавлению](#Multithreading)

# 37. Что делает метод unordered?

[К оглавлению](#Multithreading)

# 38. Когда имеет смысл распараллеливать поток и какие при этом должны соблюдаться условия?

[К оглавлению](#Multithreading)

# 39. Расскажите про Java NIO и её главные составляющие.

[К оглавлению](#Multithreading)

# 40. Что такое канал?

[К оглавлению](#Multithreading)

# 41. Что такое буфер?

[К оглавлению](#Multithreading)

# 42. Что такое селектор?

[К оглавлению](#Multithreading)

# 43. Когда есть смысл использовать Java NIO?

[К оглавлению](#Multithreading)

# 44. Что такое PipedStreams? Как они устроены?

[К оглавлению](#Multithreading)