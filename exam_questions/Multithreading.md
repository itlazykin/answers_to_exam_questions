## Multithreading

[1. Чем отличается процесс от потока?](#1-чем-отличается-процесс-от-потока)

[2. Каким образом можно создать поток?](#2-каким-образом-можно-создать-поток)

[3. Как работают методы sleep, yield, wait, notify и notifyAll?](#3-как-работают-методы-sleep-yield-wait-notify-и-notifyall)

[4. Объясните следующие термины: монитор, мьютекс, критическая секция.](#4-объясните-следующие-термины-монитор-мьютекс-критическая-секция)

[5. Как работает join()?](#5-как-работает-join)

[6. Что такое DeadLock? Приведите примеры.](#6-что-такое-deadlock-приведите-примеры)

[7. Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.](#7-назовите-различия-между-collectionssynchronizedmapnew-hashmap-и-concurrenthashmap)

[8. Различия в интерфейсах Runnable и Callable.](#8-различия-в-интерфейсах-runnable-и-callable)

[9. Различия между isInterrupted(), interrupted(), interrupt().](#9-различия-между-isinterrupted-interrupted-interrupt)

[10. Что происходит при вызове Thread.interrupt()?](#10-что-происходит-при-вызове-threadinterrupt)

[11. Перечислите ВСЕ причины по которым может быть выброшено InterruptedException.](#11-перечислите-все-причины-по-которым-может-быть-выброшено-interruptedexception)

[12. Назовите отличия synchronized{} и ReentrantLock.](#12-назовите-отличия-synchronized-и-reentrantlock)

[13. Приведите наиболее существенное отличие между CountDownLatch и CyclicBarrier.](#13-приведите-наиболее-существенное-отличие-между-countdownlatch-и-cyclicbarrier)

[14. Приведите наиболее существенное отличие между CyclicBarrier и Phaser.](#14-приведите-наиболее-существенное-отличие-между-cyclicbarrier-и-phaser)

[15. Расскажите про Exchanger.](#15-расскажите-про-exchanger)

[16. Отличие Thread.start() и Thread.run()?](#16-отличие-threadstart-и-threadrun)

[17. Объясните ключевое слово volatile.](#17-объясните-ключевое-слово-volatile)

[18. Расскажите про приоритеты потока](#18-расскажите-про-приоритеты-потока)

[19. Что такое потоки-демоны?](#19-что-такое-потоки-демоны)

[20. Назовите все возможные состояния потока.](#20-назовите-все-возможные-состояния-потока)

[21. Что такое race condition?](#21-что-такое-race-condition)

[22. Что такое Thread Local переменная?](#22-что-такое-thread-local-переменная)

[23. Что такое FutureTask?](#23-что-такое-futuretask)

[24. Что такое Thread Pool?](#24-что-такое-thread-pool)

[25. Что такое Semaphore?](#25-что-такое-semaphore)

[26. Чем отличается submit от execute у ExecutorService?](#26-чем-отличается-submit-от-execute-у-executorservice)

[27. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?](#27-чем-отличается-shutdown-от-shutdownnow-у-threadpoolexecutor)

[28. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.](#28-как-создать-threadpool-у-executorservice-только-на-1-на-5-на-неограниченное-количество-потоков)

[29. Что такое ReadWriteLock?](#29-что-такое-readwritelock)

[30. В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt() и FutureTask.cancel().](#30-в-чём-отличие-thread-от-futuretask-в-чём-отличие-threadinterrupt-и-futuretaskcancel)

[31. Расскажите про шаблон проектирования Producer Consumer.](#31-расскажите-про-шаблон-проектирования-producer-consumer)

[32. Как можно запустить параллельный поток (parallelStream)?](#32-как-можно-запустить-параллельный-поток-parallelstream)

[33. Что делают методы parallel и sequential?](#33-что-делают-методы-parallel-и-sequential)

[34. Расскажите про порядок следования элементов в параллельном потоке и его особенностях.](#34-расскажите-про-порядок-следования-элементов-в-параллельном-потоке-и-его-особенностях)

[35. В чем разница между методами forEach и forEachOrdered?](#35-в-чем-разница-между-методами-foreach-и-foreachordered)

[36. В чем разница между применением метода peek() в последовательном и параллельном потоках?](#36-в-чем-разница-между-применением-метода-peek-в-последовательном-и-параллельном-потоках)

[37. Что делает метод unordered?](#37-что-делает-метод-unordered)

[38. Когда имеет смысл распараллеливать поток и какие при этом должны соблюдаться условия?](#38-когда-имеет-смысл-распараллеливать-поток-и-какие-при-этом-должны-соблюдаться-условия)

[39. Расскажите про Java NIO и её главные составляющие.](#39-расскажите-про-java-nio-и-её-главные-составляющие)

[40. Что такое канал?](#40-что-такое-канал)

[41. Что такое буфер?](#41-что-такое-буфер)

[42. Что такое селектор?](#42-что-такое-селектор)

[43. Когда есть смысл использовать Java NIO?](#43-когда-есть-смысл-использовать-java-nio)

[44. Что такое PipedStreams? Как они устроены?](#44-что-такое-pipedstreams-как-они-устроены)

# 1. Чем отличается процесс от потока?

Процесс и поток — это два ключевых понятия в многозадачности, но они отличаются по своему "масштабу" и организации
работы в операционной системе.

`Процесс` — это изолированная единица выполнения. Каждый процесс имеет свой собственный адрес в памяти, свои ресурсы (
например, файлы, переменные окружения) и свою собственную память. Процессы могут работать параллельно, но они не могут
напрямую взаимодействовать друг с другом без использования специальных механизмов (например, межпроцессного
взаимодействия — IPC). Если процесс завершится, то все ресурсы, связанные с ним, освобождаются.

`Поток` (или тред) — это более легковесная единица исполнения, которая существует внутри процесса. Потоки в рамках
одного процесса разделяют общую память и ресурсы процесса. Это позволяет потокам работать быстрее, поскольку им не нужно
создавать отдельные ресурсы для каждого потока. Однако это также создает некоторые риски, например, проблемы с
синхронизацией при доступе к общей памяти.

#### Важные различия:

+ Процесс имеет свою собственную память и ресурсы, а потоки внутри процесса делят общую память и ресурсы.
+ Процесс может содержать несколько потоков, а поток не существует без процесса.
+ Создание и управление процессами более ресурсоемко, чем создание и управление потоками.

Простой пример: представь себе, что процесс — это целый офис с множеством рабочих мест, а потоки — это сотрудники,
которые работают в этом офисе. Все сотрудники используют общие ресурсы офиса (столы, компьютеры), но каждый сотрудник
выполняет свою задачу.

[К оглавлению](#Multithreading)

# 2. Каким образом можно создать поток?

1. Реализовать интерфейс Runnable

Это более гибкий способ, так как позволяет наследовать другие классы (например, от Thread), если это необходимо.

#### Вот как это работает:

+ Создаешь класс, который реализует интерфейс Runnable.
+ Переопределяешь метод run(), который будет содержать код, выполняемый потоком.
+ Создаешь объект типа Thread, передавая ему экземпляр класса, реализующего Runnable.
+ Запускаешь поток с помощью метода start().
```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
    System.out.println("Поток работает!");
 }
}

public class Main {
public static void main(String[] args) {
    MyRunnable myRunnable = new MyRunnable();
    Thread thread = new Thread(myRunnable); // Создаем поток
    thread.start(); // Запускаем поток
 }
}
```
2. Наследовать от класса Thread

Другой способ — это создать класс, который наследует Thread и переопределить метод run(). Это работает так же, как и с
Runnable, но с некоторыми ограничениями, например, нельзя наследовать от других классов, потому что Java поддерживает
только одно наследование.

```java
class MyThread extends Thread {
    @Override
    public void run() {
    System.out.println("Поток работает!");
 }
}

public class Main {
    public static void main(String[] args) {
    MyThread thread = new MyThread(); // Создаем поток
    thread.start(); // Запускаем поток
 }
}
```

3. С помощью лямбда - выражений, передается в конструктор Thread и реализует интерфейс Runnable. Это более современный и
   компактный способ создания потоков в Java, особенно с появлением лямбда-выражений в Java 8.

```java
public class ConcurrentOutput {
    public static void main(String[] args) {
        Thread another = new Thread(
                () -> System.out.println(Thread.currentThread().getName())
        );
        another.start();
        System.out.println(Thread.currentThread().getName());
    }
}
```

#### Главное отличие:

+ Runnable: позволяет создавать потоки, не ограничивая возможность наследовать другие классы.
+ Thread: удобен, если нужно сразу работать с потоками, но не позволяет наследовать другие классы.

#### Как работает поток?

Когда ты вызываешь start(), система вызывает метод run() в новом потоке. Важно помнить, что если ты вызовешь просто
run(), то код выполнится в текущем потоке, а не в новом.

[К оглавлению](#Multithreading)

# 3. Как работают методы sleep, yield, wait, notify и notifyAll?

1. Thread.sleep()

Этот метод временно приостанавливает выполнение текущего потока на заданное количество времени. После завершения паузы
поток продолжает работу.

+ Где применяется: для создания задержек в выполнении программы.
+ Особенности:
    + Поток, вызвавший sleep, переходит в состояние TIMED_WAITING.
    + Метод бросает InterruptedException, если поток будет прерван во время сна.

```java
try {
Thread.sleep(1000); // Поток "засыпает" на 1 секунду
} catch (InterruptedException e) {
e.printStackTrace();
}
```

2. Thread.yield()

Этот метод сигнализирует планировщику потоков, что текущий поток готов уступить место другим потокам с таким же или
более высоким приоритетом.

+ Где применяется: редко, обычно для оптимизации многопоточных программ.
+ Особенности:
    + Это всего лишь рекомендация, и планировщик потоков может проигнорировать ее.
    + Поток остается в состоянии RUNNABLE.
```java
Thread.yield(); // Текущий поток может уступить место другим потокам
```

3. wait()

Метод используется для временной приостановки потока до тех пор, пока другой поток не вызовет notify() или notifyAll()
на том же объекте.

+ Где применяется: при реализации межпоточного взаимодействия (например, Producer-Consumer паттерн).
+ Особенности:
  + Вызывается только на мониторе объекта, т.е. внутри синхронизированного блока или метода.
    + Поток переходит в состояние WAITING до вызова notify() или notifyAll().

```java
synchronized (lock) {
lock.wait(); // Текущий поток ждет сигнала
}
```
4. notify()

Этот метод пробуждает один поток, который ждет на мониторе данного объекта.

+ Где применяется: для пробуждения потоков, ожидающих на wait().
+ Особенности:
  + Какой именно поток будет пробужден, определяется системой (нет гарантии).
  + Вызывается внутри синхронизированного блока или метода.
```java
synchronized (lock) {
lock.notify(); // Будет пробужден один ожидающий поток
}
```
5. notifyAll()

Этот метод пробуждает все потоки, которые ожидают на мониторе данного объекта.

+ Где применяется: когда нужно пробудить все ожидающие потоки.
+ Особенности:
    + Все пробужденные потоки начинают конкурировать за монитор.
```java
synchronized (lock) {
lock.notifyAll(); // Все ожидающие потоки будут пробуждены
}
```

| Метод     | Контекст использования	             | Поток           | Требует synchronized |
|-----------|-------------------------------------|-----------------|----------------------|
| sleep     | Задержка выполнения                 | Текущий поток   | Нет                  |
| yield     | Уступка другим потокам              | Текущий поток   | Нет                  |
| wait      | Ожидание сигнала                    | Ожидающий поток | Да                   |
| notify    | Пробуждение одного потока           | Ждущие потоки   | Да                   |
| notifyAll | Пробуждение всех ожидающих потоков	 | Ждущие потоки   | Да                   |

```java
Пример взаимодействия wait и notify:

class SharedResource {
    private boolean isReady = false;

    public synchronized void waitForReady() {
        while (!isReady) {
            try {
                wait(); // Ожидание сигнала
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("Готово к работе!");
    }

    public synchronized void setReady() {
        isReady = true;
        notify(); // Сигнал одному ожидающему потоку
    }
}

public class Main {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();

        new Thread(resource::waitForReady).start();

        try {
            Thread.sleep(1000); // Имитация задержки
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        resource.setReady(); // Уведомление о готовности
    }
}

```

[К оглавлению](#Multithreading)

# 4. Объясните следующие термины: монитор, мьютекс, критическая секция.

Эти термины связаны с синхронизацией потоков и управлением доступом к общим ресурсам, чтобы избежать проблем, таких как
состояние гонки. Давай разберем каждый термин.

1. Монитор (Monitor)

Монитор — это абстракция для управления доступом к общим ресурсам. В Java монитор ассоциирован с каждым объектом, и он
используется для обеспечения мутуальной исключительности и координации потоков.

Как работает:
Каждый объект в Java имеет встроенный монитор, который захватывается с помощью ключевого слова synchronized.
Если поток "захватил" монитор объекта, другие потоки, пытающиеся войти в синхронизированный блок/метод, должны ждать,
пока монитор освободится.
```java
synchronized (lock) {
// Захват монитора объекта lock
System.out.println("Монитор активен!");
// Освобождение монитора после выхода из блока
}
```
#### Зачем нужен монитор:
+ Для управления доступом к критическим секциям (о них чуть ниже). 
+ Для координации потоков с помощью методов wait, notify, notifyAll.

2. Мьютекс (Mutex)

Мьютекс (сокращение от "mutual exclusion" — взаимное исключение) — это низкоуровневый механизм, который гарантирует, что
к критической секции или ресурсу одновременно имеет доступ только один поток.

Как работает:
Поток захватывает мьютекс, чтобы получить доступ к ресурсу.
Если мьютекс уже захвачен другим потоком, остальные потоки блокируются до тех пор, пока мьютекс не освободится.

В Java:
synchronized выполняет роль мьютекса.
Также можно использовать класс ReentrantLock из пакета java.util.concurrent.locks.
```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class MutexExample {
private final Lock lock = new ReentrantLock();

    public void criticalSection() {
        lock.lock(); // Захват мьютекса
        try {
            System.out.println("Доступ к ресурсу получен!");
        } finally {
            lock.unlock(); // Освобождение мьютекса
        }
    }
}
```
3. Критическая секция (Critical Section)

Критическая секция — это участок кода, который должен быть выполнен атомарно, то есть без вмешательства других потоков.
Обычно это код, который обращается к общим ресурсам, например, переменным или файлам.

Зачем нужна:
Чтобы предотвратить состояние гонки, когда несколько потоков одновременно читают и изменяют общий ресурс.

Как защищается:
Используя мьютекс или монитор.


```java
public class Counter {
private int count = 0;

    public synchronized void increment() { // Критическая секция
        count++;
    }

    public synchronized int getCount() { // Критическая секция
        return count;
    }
}

synchronized гарантирует, что к переменной count одновременно обращается только один поток.
```

| Метод              | Что это?	                                    | Как реализуется в Java?     | Пример использования           |
|--------------------|----------------------------------------------|-----------------------------|--------------------------------|
| Монитор            | Механизм синхронизации, связанный с объектом | synchronized, wait/notify   | Управление доступом к объекту  |
| Мьютекс            | простейший тип синхронизатора нитей          | synchronized, ReentrantLock | Блокировка ресурсов            |
| Критическая секция | Участок кода, выполняемый атомарно           | synchronized                | Обеспечение целостности данных |

Если представить это метафорой:

+ Критическая секция — это сейф, куда кладут ценные вещи.
+ Мьютекс — это ключ от сейфа, который есть только у одного человека в каждый момент времени.
+ Монитор — это охранник, который следит за тем, чтобы ключ использовался правильно.

[К оглавлению](#Multithreading)

# 5. Как работает join()?

Метод join() в Java используется для синхронизации потоков. Он позволяет одному потоку дождаться завершения другого
потока - перед тем, как продолжить выполнение.

#### Как работает join()?

+ Когда один поток вызывает метод join() на другом потоке, текущий поток блокируется и переходит в состояние WAITING,
  пока вызываемый поток не завершится.
+ После завершения вызываемого потока текущий поток продолжает выполнение.

#### Ключевые моменты:

+ Поток вызывает join() на другом потоке:
Например, поток main вызывает join() на потоке t. Тогда main будет ждать, пока поток t завершится.

+ Может выбросить InterruptedException:
Если поток, вызвавший join(), будет прерван, выбрасывается исключение.

+ Можно указать тайм-аут:
Метод join() имеет перегруженные версии с параметрами времени, позволяя ждать завершения потока только в течение
заданного интервала.

```java
public class JoinExample {
    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            System.out.println("Thread 1 starts working.");
            try {
                Thread.sleep(2000); // Симуляция работы
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Thread 1 finishes working.");
        });

        thread1.start();

        try {
            System.out.println("Main thread is waiting for Thread 1.");
            thread1.join(); // Ожидание завершения потока thread1
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Main thread continues.");
    }
}

Вывод программы:
Thread 1 starts working.
Main thread is waiting for Thread 1.
Thread 1 finishes working.
Main thread continues.
        
Основной поток (main) приостанавливается после строки 
Main thread is waiting for Thread 1. и продолжает 
выполнение только после завершения потока thread1.
```

```java
Пример с тайм-аутом:

public class JoinWithTimeout {
    public static void main(String[] args) {
        Thread thread2 = new Thread(() -> {
            try {
                Thread.sleep(5000); // Поток "работает" 5 секунд
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Thread 2 finishes working.");
        });

        thread2.start();

        try {
            System.out.println("Main thread is waiting for Thread 2 (with timeout).");
            thread2.join(2000); // Ждем поток thread2 максимум 2 секунды
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Main thread continues.");
    }
}

Вывод программы:
Main thread is waiting for Thread 2 (with timeout).
Main thread continues.
Thread 2 finishes working.

основной поток ждет thread2 только 2 секунды. 
После этого он продолжает выполнение, 
даже если thread2 еще не завершился.
```

#### Когда использовать join()?

+ Когда нужно дождаться завершения одного или нескольких потоков перед выполнением следующего кода.
Пример: завершение загрузки данных из файлов или выполнения задач в фоновых потоках перед обработкой результатов.

[К оглавлению](#Multithreading)

# 6. Что такое DeadLock? Приведите примеры.

Deadlock — это ситуация, когда два или более потоков навсегда блокируются, ожидая друг друга, потому что каждый из них
удерживает ресурс, который нужен другому.

#### Условия возникновения Deadlock:
+ Взаимное исключение (Mutual Exclusion): Ресурс может быть занят только одним потоком одновременно.
+ Удержание и ожидание (Hold and Wait): Поток удерживает ресурс и ждет доступ к другому.
+ Нет принудительного освобождения (No Preemption): Ресурс не может быть принудительно изъят у потока.
+ Цикл ожидания (Circular Wait): Есть цепочка потоков, где каждый ждет ресурс, занятый следующим потоком.

```java
Рассмотрим классический пример: 
два потока захватывают два ресурса в разном порядке, 
вызывая взаимную блокировку.

public class DeadlockExample {
    private static final Object LOCK1 = new Object();
    private static final Object LOCK2 = new Object();

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            synchronized (LOCK1) {
                System.out.println("Thread 1: захватил LOCK1");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Thread 1: ожидает LOCK2");
                synchronized (LOCK2) {
                    System.out.println("Thread 1: захватил LOCK2");
                }
            }
        });
        Thread thread2 = new Thread(() -> {
            synchronized (LOCK2) {
                System.out.println("Thread 2: захватил LOCK2");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Thread 2: ожидает LOCK1");
                synchronized (LOCK1) {
                    System.out.println("Thread 2: захватил LOCK1");
                }
            }
        });
        thread1.start();
        thread2.start();
    }
}

Что произойдет:
Поток 1 захватывает LOCK1 и ждет LOCK2.
Поток 2 захватывает LOCK2 и ждет LOCK1.
Возникает Deadlock, так как оба потока ждут друг друга, но никто не освобождает свои ресурсы.

Вывод:
Thread 1: захватил LOCK1
Thread 2: захватил LOCK2
Thread 1: ожидает LOCK2
Thread 2: ожидает LOCK1
// Блокировка. Программа "виснет".

```
#### Как избежать Deadlock?

+ Фиксированный порядок захвата ресурсов: Если все потоки захватывают ресурсы в одном и том же порядке, Deadlock не
  возникнет.
```java
synchronized (LOCK1) {
    synchronized (LOCK2) {
        // Код
    }
}
```

+ Использование tryLock:
  Класс ReentrantLock из пакета java.util.concurrent.locks предоставляет метод tryLock, который пытается захватить
  ресурс, но не блокирует поток, если это невозможно.

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class TryLockExample {
    private static final Lock lock1 = new ReentrantLock();
    private static final Lock lock2 = new ReentrantLock();

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            if (lock1.tryLock()) {
                try {
                    System.out.println("Thread 1: захватил lock1");
                    if (lock2.tryLock()) {
                        try {
                            System.out.println("Thread 1: захватил lock2");
                        } finally {
                            lock2.unlock();
                        }
                    }
                } finally {
                    lock1.unlock();
                }
            }
        });
        Thread thread2 = new Thread(() -> {
            if (lock2.tryLock()) {
                try {
                    System.out.println("Thread 2: захватил lock2");
                    if (lock1.tryLock()) {
                        try {
                            System.out.println("Thread 2: захватил lock1");
                        } finally {
                            lock1.unlock();
                        }
                    }
                } finally {
                    lock2.unlock();
                }
            }
        });
        thread1.start();
        thread2.start();
    }
}
```
+ Использование тайм-аутов:
При захвате ресурсов можно использовать методы с тайм-аутом, чтобы избежать бесконечного ожидания.

#### Пример взаимоблокировки с потоками в метафоре

Представь двух людей, каждый из которых держит вилку и хочет взять нож у другого, чтобы поесть. Они стоят, не отпуская
вилок, ожидая, пока другой отдаст нож. Это и есть Deadlock: никто не может продолжить, потому что никто не уступает.

Чтобы избежать этого:

+ Пусть каждый человек сначала кладет вилку, а потом берет нож.
+ Или пусть один из них подождет определенное время и попробует снова.

[К оглавлению](#Multithreading)

# 7. Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.

Обе эти структуры предназначены для работы с потоками, но их реализация и поведение значительно различаются.

1. Блокировка (Locking)

   `Collections.synchronizedMap(new HashMap())`

+ Синхронизация всей карты:
  + Все методы, работающие с картой, синхронизированы с использованием одного единственного мьютекса. Это значит, что
    весь объект блокируется, даже если только одна операция выполняется.
    Например, чтение или запись будет блокировать доступ ко всей карте для других потоков.

`ConcurrentHashMap`

+ Разделенная блокировка (Segmented Locking):
  + Использует более тонкую гранулярность блокировки: блокируются только определённые части карты (ранее — сегменты, в
    современных версиях — корзины).
    Это позволяет нескольким потокам одновременно работать с разными частями карты без конфликтов.

2. Производительность
   `Collections.synchronizedMap(new HashMap())`

+ Медленнее в многопоточной среде:
  + Из-за глобальной блокировки производительность падает при увеличении числа потоков.
  + Подходит только для случаев, где запись/чтение выполняется редко, а многопоточность минимальна.

`ConcurrentHashMap`

+ Быстрее в многопоточной среде:
  + Благодаря разделению блокировок, больше потоков могут одновременно выполнять операции чтения и записи.
  + Идеально подходит для высоконагруженных приложений.

3. Поддержка конкурентного доступа
   `Collections.synchronizedMap(new HashMap())`

+ Не поддерживает итерацию без ошибок (fail-safe):
При модификации карты во время итерации будет выброшено ConcurrentModificationException.

`ConcurrentHashMap`

+ Поддерживает конкурентную итерацию:
  + Использует механизм "ослабленной консистентности" (weakly consistent):
  + Изменения, сделанные другими потоками, могут быть видны или не видны во время итерации, но исключения не
    выбрасываются.

4. Наличие null ключей и значений
   `Collections.synchronizedMap(new HashMap())`

+ Разрешает null ключи и значения: Один null ключ и множество null значений допустимы.

`ConcurrentHashMap`

+ Не разрешает null:
  + Ключи и значения не могут быть null.
    Это сделано, чтобы избежать неоднозначностей в многопоточной среде (например, если get(null) возвращает null,
    непонятно, отсутствует ли ключ или значение равно null).

5. Пример использования

```java
Collections.synchronizedMap(new HashMap())

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

public class SynchronizedMapExample {
  public static void main(String[] args) {
    Map<String, String> map = Collections.synchronizedMap(new HashMap<>());
    map.put("1", "one");
    map.put("2", "two");
    synchronized (map) {
      for (Map.Entry<String, String> entry : map.entrySet()) {
        System.out.println(entry.getKey() + " -> " + entry.getValue());
      }
    }
  }
}
Замечание: Для итерации нужно вручную синхронизировать блок, 
так как внутренняя синхронизация не гарантирует безопасной итерации.
```

```java
ConcurrentHashMap

import java.util.concurrent.ConcurrentHashMap;

public class ConcurrentHashMapExample {
  public static void main(String[] args) {
    ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();

    map.put("1", "one");
    map.put("2", "two");

    for (Map.Entry<String, String> entry : map.entrySet()) {
      System.out.println(entry.getKey() + " -> " + entry.getValue());
    }
  }
}
Замечание: Дополнительной синхронизации для итерации не требуется.
```

| Критерий            | Collections.synchronizedMap	   | ConcurrentHashMap                      |
|---------------------|--------------------------------|----------------------------------------|
| Количество потоков  | Небольшое                      | Высоконагруженные многопоточные задачи |
| Частота операций    | Низкая (редкие чтения/записи)  | Частое чтение/запись                   |
| Итерация            | Требуется ручная синхронизация | Безопасна для многопоточной итерации   |
| null ключи/значения | Поддерживает                   | Не поддерживает                        |

[К оглавлению](#Multithreading)

# 8. Различия в интерфейсах Runnable и Callable.

Оба интерфейса используются для создания задач, которые могут выполняться в потоках, но они имеют разные возможности и
предназначение.

| Критерий                     | Runnable	                                                  | Callable                                                                                  |
|------------------------------|------------------------------------------------------------|-------------------------------------------------------------------------------------------|
| Пакет                        | Находится в пакете java.lang.                              | Находится в пакете java.util.concurrent.                                                  |
| Метод                        | Содержит метод: void run().                                | Содержит метод: V call() throws Exception.                                                |
| Возвращаемое значение        | Ничего не возвращает (тип void).                           | Возвращает значение (тип V).                                                              |
| Обработка исключений         | Исключения должны обрабатываться внутри метода run.        | Может выбрасывать проверяемые исключения.                                                 |
| Использование                | Подходит для задач, которым не нужно возвращать результат. | Используется для задач, которые возвращают результат или могут выбросить исключение.      |
| Интеграция с ExecutorService | Передается в ExecutorService как задача для выполнения.    | Возвращает объект типа Future<V>, который позволяет получить результат выполнения задачи. |

```java
Пример использования Runnable

public class RunnableExample {
  public static void main(String[] args) {
    Runnable task = () -> {
      System.out.println("Выполняется задача Runnable");
    };
    Thread thread = new Thread(task);
    thread.start();
  }
}

Задача выполняется, но не возвращает результат.
Исключения внутри задачи нужно обрабатывать вручную.
```

```java
Пример использования Callable

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class CallableExample {
  public static void main(String[] args) {
    Callable<String> task = () -> {
      return "Результат выполнения Callable";
    };

    ExecutorService executor = Executors.newSingleThreadExecutor();
    Future<String> future = executor.submit(task);

    try {
      // Получаем результат выполнения задачи
      String result = future.get();
      System.out.println(result);
    } catch (Exception e) {
      e.printStackTrace();
    } finally {
      executor.shutdown();
    }
  }
}

Задача возвращает результат выполнения через объект Future.
Исключения можно обрабатывать через Future.get().
```

#### Когда использовать?

`Runnable`:
+ Для задач, которые выполняются в потоке, но не возвращают результата.
Например: запись данных в файл, логирование.

`Callable`:
+ Для задач, которые возвращают результат или могут выбросить исключение.
Например: выполнение сложных вычислений, запрос данных из базы.

#### Ключевые отличия в метафоре

Представь, что тебе нужно отправить курьера за посылкой:

`Runnable`:
Курьер просто идёт по твоему поручению, но ничего не возвращает. Если что-то пошло не так, тебе нужно было заранее
предусмотреть, как это обработать.
`Callable`:
Курьер возвращается с посылкой, и ты можешь узнать результат его работы. Если произошла ошибка, он сообщает тебе об этом
через исключение.

[К оглавлению](#Multithreading)

# 9. Различия между isInterrupted(), interrupted(), interrupt().

[К оглавлению](#Multithreading)

# 10. Что происходит при вызове Thread.interrupt()?

[К оглавлению](#Multithreading)

# 11. Перечислите ВСЕ причины по которым может быть выброшено InterruptedException.

[К оглавлению](#Multithreading)

# 12. Назовите отличия synchronized{} и ReentrantLock.

[К оглавлению](#Multithreading)

# 13. Приведите наиболее существенное отличие между CountDownLatch и CyclicBarrier.

[К оглавлению](#Multithreading)

# 14. Приведите наиболее существенное отличие между CyclicBarrier и Phaser.

[К оглавлению](#Multithreading)

# 15. Расскажите про Exchanger.

[К оглавлению](#Multithreading)

# 16. Отличие Thread.start() и Thread.run()?

[К оглавлению](#Multithreading)

# 17. Объясните ключевое слово volatile.

[К оглавлению](#Multithreading)

# 18. Расскажите про приоритеты потока

[К оглавлению](#Multithreading)

# 19. Что такое потоки-демоны?

[К оглавлению](#Multithreading)

# 20. Назовите все возможные состояния потока.

[К оглавлению](#Multithreading)

# 21. Что такое race condition?

[К оглавлению](#Multithreading)

# 22. Что такое Thread Local переменная?

[К оглавлению](#Multithreading)

# 23. Что такое FutureTask?

[К оглавлению](#Multithreading)

# 24. Что такое Thread Pool?

[К оглавлению](#Multithreading)

# 25. Что такое Semaphore?

[К оглавлению](#Multithreading)

# 26. Чем отличается submit от execute у ExecutorService?

[К оглавлению](#Multithreading)

# 27. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?

[К оглавлению](#Multithreading)

# 28. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.

[К оглавлению](#Multithreading)

# 29. Что такое ReadWriteLock?

[К оглавлению](#Multithreading)

# 30. В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt() и FutureTask.cancel().

[К оглавлению](#Multithreading)

# 31. Расскажите про шаблон проектирования Producer Consumer.

[К оглавлению](#Multithreading)

# 32. Как можно запустить параллельный поток (parallelStream)?

[К оглавлению](#Multithreading)

# 33. Что делают методы parallel и sequential?

[К оглавлению](#Multithreading)

# 34. Расскажите про порядок следования элементов в параллельном потоке и его особенностях.

[К оглавлению](#Multithreading)

# 35. В чем разница между методами forEach и forEachOrdered?

[К оглавлению](#Multithreading)

# 36. В чем разница между применением метода peek() в последовательном и параллельном потоках?

[К оглавлению](#Multithreading)

# 37. Что делает метод unordered?

[К оглавлению](#Multithreading)

# 38. Когда имеет смысл распараллеливать поток и какие при этом должны соблюдаться условия?

[К оглавлению](#Multithreading)

# 39. Расскажите про Java NIO и её главные составляющие.

[К оглавлению](#Multithreading)

# 40. Что такое канал?

[К оглавлению](#Multithreading)

# 41. Что такое буфер?

[К оглавлению](#Multithreading)

# 42. Что такое селектор?

[К оглавлению](#Multithreading)

# 43. Когда есть смысл использовать Java NIO?

[К оглавлению](#Multithreading)

# 44. Что такое PipedStreams? Как они устроены?

[К оглавлению](#Multithreading)