## Multithreading

[1. Чем отличается процесс от потока?](#1-чем-отличается-процесс-от-потока)

[2. Каким образом можно создать поток?](#2-каким-образом-можно-создать-поток)

[3. Как работают методы sleep, yield, wait, notify и notifyAll?](#3-как-работают-методы-sleep-yield-wait-notify-и-notifyall)

[4. Объясните следующие термины: монитор, мьютекс, критическая секция.](#4-объясните-следующие-термины-монитор-мьютекс-критическая-секция)

[5. Как работает join()?](#5-как-работает-join)

[6. Что такое DeadLock? Приведите примеры.](#6-что-такое-deadlock-приведите-примеры)

[7. Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.](#7-назовите-различия-между-collectionssynchronizedmapnew-hashmap-и-concurrenthashmap)

[8. Различия в интерфейсах Runnable и Callable.](#8-различия-в-интерфейсах-runnable-и-callable)

[9. Различия между isInterrupted(), interrupted(), interrupt().](#9-различия-между-isinterrupted-interrupted-interrupt)

[10. Что происходит при вызове Thread.interrupt()?](#10-что-происходит-при-вызове-threadinterrupt)

[11. Перечислите ВСЕ причины по которым может быть выброшено InterruptedException.](#11-перечислите-все-причины-по-которым-может-быть-выброшено-interruptedexception)

[12. Назовите отличия synchronized{} и ReentrantLock.](#12-назовите-отличия-synchronized-и-reentrantlock)

[13. Приведите наиболее существенное отличие между CountDownLatch и CyclicBarrier.](#13-приведите-наиболее-существенное-отличие-между-countdownlatch-и-cyclicbarrier)

[14. Приведите наиболее существенное отличие между CyclicBarrier и Phaser.](#14-приведите-наиболее-существенное-отличие-между-cyclicbarrier-и-phaser)

[15. Расскажите про Exchanger.](#15-расскажите-про-exchanger)

[16. Отличие Thread.start() и Thread.run()?](#16-отличие-threadstart-и-threadrun)

[17. Объясните ключевое слово volatile.](#17-объясните-ключевое-слово-volatile)

[18. Расскажите про приоритеты потока](#18-расскажите-про-приоритеты-потока)

[19. Что такое потоки-демоны?](#19-что-такое-потоки-демоны)

[20. Назовите все возможные состояния потока.](#20-назовите-все-возможные-состояния-потока)

[21. Что такое race condition?](#21-что-такое-race-condition)

[22. Что такое Thread Local переменная?](#22-что-такое-thread-local-переменная)

[23. Что такое FutureTask?](#23-что-такое-futuretask)

[24. Что такое Thread Pool?](#24-что-такое-thread-pool)

[25. Что такое Semaphore?](#25-что-такое-semaphore)

[26. Чем отличается submit от execute у ExecutorService?](#26-чем-отличается-submit-от-execute-у-executorservice)

[27. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?](#27-чем-отличается-shutdown-от-shutdownnow-у-threadpoolexecutor)

[28. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.](#28-как-создать-threadpool-у-executorservice-только-на-1-на-5-на-неограниченное-количество-потоков)

[29. Что такое ReadWriteLock?](#29-что-такое-readwritelock)

[30. В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt() и FutureTask.cancel().](#30-в-чём-отличие-thread-от-futuretask-в-чём-отличие-threadinterrupt-и-futuretaskcancel)

[31. Расскажите про шаблон проектирования Producer Consumer.](#31-расскажите-про-шаблон-проектирования-producer-consumer)

[32. Как можно запустить параллельный поток (parallelStream)?](#32-как-можно-запустить-параллельный-поток-parallelstream)

[33. Что делают методы parallel и sequential?](#33-что-делают-методы-parallel-и-sequential)

[34. Расскажите про порядок следования элементов в параллельном потоке и его особенностях.](#34-расскажите-про-порядок-следования-элементов-в-параллельном-потоке-и-его-особенностях)

[35. В чем разница между методами forEach и forEachOrdered?](#35-в-чем-разница-между-методами-foreach-и-foreachordered)

[36. В чем разница между применением метода peek() в последовательном и параллельном потоках?](#36-в-чем-разница-между-применением-метода-peek-в-последовательном-и-параллельном-потоках)

[37. Что делает метод unordered?](#37-что-делает-метод-unordered)

[38. Когда имеет смысл распараллеливать поток и какие при этом должны соблюдаться условия?](#38-когда-имеет-смысл-распараллеливать-поток-и-какие-при-этом-должны-соблюдаться-условия)

[39. Расскажите про Java NIO и её главные составляющие.](#39-расскажите-про-java-nio-и-её-главные-составляющие)

[40. Что такое канал?](#40-что-такое-канал)

[41. Что такое буфер?](#41-что-такое-буфер)

[42. Что такое селектор?](#42-что-такое-селектор)

[43. Когда есть смысл использовать Java NIO?](#43-когда-есть-смысл-использовать-java-nio)

[44. Что такое PipedStreams? Как они устроены?](#44-что-такое-pipedstreams-как-они-устроены)

# 1. Чем отличается процесс от потока?

Процесс и поток — это два ключевых понятия в многозадачности, но они отличаются по своему "масштабу" и организации
работы в операционной системе.

`Процесс` — это изолированная единица выполнения. Каждый процесс имеет свой собственный адрес в памяти, свои ресурсы (
например, файлы, переменные окружения) и свою собственную память. Процессы могут работать параллельно, но они не могут
напрямую взаимодействовать друг с другом без использования специальных механизмов (например, межпроцессного
взаимодействия — IPC). Если процесс завершится, то все ресурсы, связанные с ним, освобождаются.

`Поток` (или тред) — это более легковесная единица исполнения, которая существует внутри процесса. Потоки в рамках
одного процесса разделяют общую память и ресурсы процесса. Это позволяет потокам работать быстрее, поскольку им не нужно
создавать отдельные ресурсы для каждого потока. Однако это также создает некоторые риски, например, проблемы с
синхронизацией при доступе к общей памяти.

#### Важные различия:

+ Процесс имеет свою собственную память и ресурсы, а потоки внутри процесса делят общую память и ресурсы.
+ Процесс может содержать несколько потоков, а поток не существует без процесса.
+ Создание и управление процессами более ресурсоемко, чем создание и управление потоками.

Простой пример: представь себе, что процесс — это целый офис с множеством рабочих мест, а потоки — это сотрудники,
которые работают в этом офисе. Все сотрудники используют общие ресурсы офиса (столы, компьютеры), но каждый сотрудник
выполняет свою задачу.

[К оглавлению](#Multithreading)

# 2. Каким образом можно создать поток?

1. Реализовать интерфейс Runnable

Это более гибкий способ, так как позволяет наследовать другие классы (например, от Thread), если это необходимо.

#### Вот как это работает:

+ Создаешь класс, который реализует интерфейс Runnable.
+ Переопределяешь метод run(), который будет содержать код, выполняемый потоком.
+ Создаешь объект типа Thread, передавая ему экземпляр класса, реализующего Runnable.
+ Запускаешь поток с помощью метода start().
```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
    System.out.println("Поток работает!");
 }
}

public class Main {
public static void main(String[] args) {
    MyRunnable myRunnable = new MyRunnable();
    Thread thread = new Thread(myRunnable); // Создаем поток
    thread.start(); // Запускаем поток
 }
}
```
2. Наследовать от класса Thread

Другой способ — это создать класс, который наследует Thread и переопределить метод run(). Это работает так же, как и с
Runnable, но с некоторыми ограничениями, например, нельзя наследовать от других классов, потому что Java поддерживает
только одно наследование.

```java
class MyThread extends Thread {
    @Override
    public void run() {
    System.out.println("Поток работает!");
 }
}

public class Main {
    public static void main(String[] args) {
    MyThread thread = new MyThread(); // Создаем поток
    thread.start(); // Запускаем поток
 }
}
```

3. С помощью лямбда - выражений, передается в конструктор Thread и реализует интерфейс Runnable. Это более современный и
   компактный способ создания потоков в Java, особенно с появлением лямбда-выражений в Java 8.

```java
public class ConcurrentOutput {
    public static void main(String[] args) {
        Thread another = new Thread(
                () -> System.out.println(Thread.currentThread().getName())
        );
        another.start();
        System.out.println(Thread.currentThread().getName());
    }
}
```

#### Главное отличие:

+ Runnable: позволяет создавать потоки, не ограничивая возможность наследовать другие классы.
+ Thread: удобен, если нужно сразу работать с потоками, но не позволяет наследовать другие классы.

#### Как работает поток?

Когда ты вызываешь start(), система вызывает метод run() в новом потоке. Важно помнить, что если ты вызовешь просто
run(), то код выполнится в текущем потоке, а не в новом.

[К оглавлению](#Multithreading)

# 3. Как работают методы sleep, yield, wait, notify и notifyAll?

1. Thread.sleep()

Этот метод временно приостанавливает выполнение текущего потока на заданное количество времени. После завершения паузы
поток продолжает работу.

+ Где применяется: для создания задержек в выполнении программы.
+ Особенности:
    + Поток, вызвавший sleep, переходит в состояние TIMED_WAITING.
    + Метод бросает InterruptedException, если поток будет прерван во время сна.

```java
try {
Thread.sleep(1000); // Поток "засыпает" на 1 секунду
} catch (InterruptedException e) {
e.printStackTrace();
}
```

2. Thread.yield()

Этот метод сигнализирует планировщику потоков, что текущий поток готов уступить место другим потокам с таким же или
более высоким приоритетом.

+ Где применяется: редко, обычно для оптимизации многопоточных программ.
+ Особенности:
    + Это всего лишь рекомендация, и планировщик потоков может проигнорировать ее.
    + Поток остается в состоянии RUNNABLE.
```java
Thread.yield(); // Текущий поток может уступить место другим потокам
```

3. wait()

Метод используется для временной приостановки потока до тех пор, пока другой поток не вызовет notify() или notifyAll()
на том же объекте.

+ Где применяется: при реализации межпоточного взаимодействия (например, Producer-Consumer паттерн).
+ Особенности:
  + Вызывается только на мониторе объекта, т.е. внутри синхронизированного блока или метода.
    + Поток переходит в состояние WAITING до вызова notify() или notifyAll().

```java
synchronized (lock) {
lock.wait(); // Текущий поток ждет сигнала
}
```
4. notify()

Этот метод пробуждает один поток, который ждет на мониторе данного объекта.

+ Где применяется: для пробуждения потоков, ожидающих на wait().
+ Особенности:
  + Какой именно поток будет пробужден, определяется системой (нет гарантии).
  + Вызывается внутри синхронизированного блока или метода.
```java
synchronized (lock) {
lock.notify(); // Будет пробужден один ожидающий поток
}
```
5. notifyAll()

Этот метод пробуждает все потоки, которые ожидают на мониторе данного объекта.

+ Где применяется: когда нужно пробудить все ожидающие потоки.
+ Особенности:
    + Все пробужденные потоки начинают конкурировать за монитор.
```java
synchronized (lock) {
lock.notifyAll(); // Все ожидающие потоки будут пробуждены
}
```

| Метод     | Контекст использования	             | Поток           | Требует synchronized |
|-----------|-------------------------------------|-----------------|----------------------|
| sleep     | Задержка выполнения                 | Текущий поток   | Нет                  |
| yield     | Уступка другим потокам              | Текущий поток   | Нет                  |
| wait      | Ожидание сигнала                    | Ожидающий поток | Да                   |
| notify    | Пробуждение одного потока           | Ждущие потоки   | Да                   |
| notifyAll | Пробуждение всех ожидающих потоков	 | Ждущие потоки   | Да                   |

```java
Пример взаимодействия wait и notify:

class SharedResource {
    private boolean isReady = false;

    public synchronized void waitForReady() {
        while (!isReady) {
            try {
                wait(); // Ожидание сигнала
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("Готово к работе!");
    }

    public synchronized void setReady() {
        isReady = true;
        notify(); // Сигнал одному ожидающему потоку
    }
}

public class Main {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();

        new Thread(resource::waitForReady).start();

        try {
            Thread.sleep(1000); // Имитация задержки
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        resource.setReady(); // Уведомление о готовности
    }
}

```

[К оглавлению](#Multithreading)

# 4. Объясните следующие термины: монитор, мьютекс, критическая секция.

Эти термины связаны с синхронизацией потоков и управлением доступом к общим ресурсам, чтобы избежать проблем, таких как
состояние гонки. Давай разберем каждый термин.

1. Монитор (Monitor)

Монитор — это абстракция для управления доступом к общим ресурсам. В Java монитор ассоциирован с каждым объектом, и он
используется для обеспечения мутуальной исключительности и координации потоков.

Как работает:
Каждый объект в Java имеет встроенный монитор, который захватывается с помощью ключевого слова synchronized.
Если поток "захватил" монитор объекта, другие потоки, пытающиеся войти в синхронизированный блок/метод, должны ждать,
пока монитор освободится.
```java
synchronized (lock) {
// Захват монитора объекта lock
System.out.println("Монитор активен!");
// Освобождение монитора после выхода из блока
}
```
#### Зачем нужен монитор:
+ Для управления доступом к критическим секциям (о них чуть ниже). 
+ Для координации потоков с помощью методов wait, notify, notifyAll.

2. Мьютекс (Mutex)

Мьютекс (сокращение от "mutual exclusion" — взаимное исключение) — это низкоуровневый механизм, который гарантирует, что
к критической секции или ресурсу одновременно имеет доступ только один поток.

Как работает:
Поток захватывает мьютекс, чтобы получить доступ к ресурсу.
Если мьютекс уже захвачен другим потоком, остальные потоки блокируются до тех пор, пока мьютекс не освободится.

В Java:
synchronized выполняет роль мьютекса.
Также можно использовать класс ReentrantLock из пакета java.util.concurrent.locks.
```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class MutexExample {
private final Lock lock = new ReentrantLock();

    public void criticalSection() {
        lock.lock(); // Захват мьютекса
        try {
            System.out.println("Доступ к ресурсу получен!");
        } finally {
            lock.unlock(); // Освобождение мьютекса
        }
    }
}
```
3. Критическая секция (Critical Section)

Критическая секция — это участок кода, который должен быть выполнен атомарно, то есть без вмешательства других потоков.
Обычно это код, который обращается к общим ресурсам, например, переменным или файлам.

Зачем нужна:
Чтобы предотвратить состояние гонки, когда несколько потоков одновременно читают и изменяют общий ресурс.

Как защищается:
Используя мьютекс или монитор.


```java
public class Counter {
private int count = 0;

    public synchronized void increment() { // Критическая секция
        count++;
    }

    public synchronized int getCount() { // Критическая секция
        return count;
    }
}

synchronized гарантирует, что к переменной count одновременно обращается только один поток.
```

| Метод              | Что это?	                                    | Как реализуется в Java?     | Пример использования           |
|--------------------|----------------------------------------------|-----------------------------|--------------------------------|
| Монитор            | Механизм синхронизации, связанный с объектом | synchronized, wait/notify   | Управление доступом к объекту  |
| Мьютекс            | простейший тип синхронизатора нитей          | synchronized, ReentrantLock | Блокировка ресурсов            |
| Критическая секция | Участок кода, выполняемый атомарно           | synchronized                | Обеспечение целостности данных |

Если представить это метафорой:

+ Критическая секция — это сейф, куда кладут ценные вещи.
+ Мьютекс — это ключ от сейфа, который есть только у одного человека в каждый момент времени.
+ Монитор — это охранник, который следит за тем, чтобы ключ использовался правильно.

[К оглавлению](#Multithreading)

# 5. Как работает join()?

Метод join() в Java используется для синхронизации потоков. Он позволяет одному потоку дождаться завершения другого
потока - перед тем, как продолжить выполнение.

#### Как работает join()?

+ Когда один поток вызывает метод join() на другом потоке, текущий поток блокируется и переходит в состояние WAITING,
  пока вызываемый поток не завершится.
+ После завершения вызываемого потока текущий поток продолжает выполнение.

#### Ключевые моменты:

+ Поток вызывает join() на другом потоке:
Например, поток main вызывает join() на потоке t. Тогда main будет ждать, пока поток t завершится.

+ Может выбросить InterruptedException:
Если поток, вызвавший join(), будет прерван, выбрасывается исключение.

+ Можно указать тайм-аут:
Метод join() имеет перегруженные версии с параметрами времени, позволяя ждать завершения потока только в течение
заданного интервала.

```java
public class JoinExample {
    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            System.out.println("Thread 1 starts working.");
            try {
                Thread.sleep(2000); // Симуляция работы
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Thread 1 finishes working.");
        });

        thread1.start();

        try {
            System.out.println("Main thread is waiting for Thread 1.");
            thread1.join(); // Ожидание завершения потока thread1
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Main thread continues.");
    }
}

Вывод программы:
Thread 1 starts working.
Main thread is waiting for Thread 1.
Thread 1 finishes working.
Main thread continues.
        
Основной поток (main) приостанавливается после строки 
Main thread is waiting for Thread 1. и продолжает 
выполнение только после завершения потока thread1.
```

```java
Пример с тайм-аутом:

public class JoinWithTimeout {
    public static void main(String[] args) {
        Thread thread2 = new Thread(() -> {
            try {
                Thread.sleep(5000); // Поток "работает" 5 секунд
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Thread 2 finishes working.");
        });

        thread2.start();

        try {
            System.out.println("Main thread is waiting for Thread 2 (with timeout).");
            thread2.join(2000); // Ждем поток thread2 максимум 2 секунды
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Main thread continues.");
    }
}

Вывод программы:
Main thread is waiting for Thread 2 (with timeout).
Main thread continues.
Thread 2 finishes working.

основной поток ждет thread2 только 2 секунды. 
После этого он продолжает выполнение, 
даже если thread2 еще не завершился.
```

#### Когда использовать join()?

+ Когда нужно дождаться завершения одного или нескольких потоков перед выполнением следующего кода.
Пример: завершение загрузки данных из файлов или выполнения задач в фоновых потоках перед обработкой результатов.

[К оглавлению](#Multithreading)

# 6. Что такое DeadLock? Приведите примеры.

Deadlock — это ситуация, когда два или более потоков навсегда блокируются, ожидая друг друга, потому что каждый из них
удерживает ресурс, который нужен другому.

#### Условия возникновения Deadlock:
+ Взаимное исключение (Mutual Exclusion): Ресурс может быть занят только одним потоком одновременно.
+ Удержание и ожидание (Hold and Wait): Поток удерживает ресурс и ждет доступ к другому.
+ Нет принудительного освобождения (No Preemption): Ресурс не может быть принудительно изъят у потока.
+ Цикл ожидания (Circular Wait): Есть цепочка потоков, где каждый ждет ресурс, занятый следующим потоком.

```java
Рассмотрим классический пример: 
два потока захватывают два ресурса в разном порядке, 
вызывая взаимную блокировку.

public class DeadlockExample {
    private static final Object LOCK1 = new Object();
    private static final Object LOCK2 = new Object();

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            synchronized (LOCK1) {
                System.out.println("Thread 1: захватил LOCK1");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Thread 1: ожидает LOCK2");
                synchronized (LOCK2) {
                    System.out.println("Thread 1: захватил LOCK2");
                }
            }
        });
        Thread thread2 = new Thread(() -> {
            synchronized (LOCK2) {
                System.out.println("Thread 2: захватил LOCK2");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Thread 2: ожидает LOCK1");
                synchronized (LOCK1) {
                    System.out.println("Thread 2: захватил LOCK1");
                }
            }
        });
        thread1.start();
        thread2.start();
    }
}

Что произойдет:
Поток 1 захватывает LOCK1 и ждет LOCK2.
Поток 2 захватывает LOCK2 и ждет LOCK1.
Возникает Deadlock, так как оба потока ждут друг друга, но никто не освобождает свои ресурсы.

Вывод:
Thread 1: захватил LOCK1
Thread 2: захватил LOCK2
Thread 1: ожидает LOCK2
Thread 2: ожидает LOCK1
// Блокировка. Программа "виснет".

```
#### Как избежать Deadlock?

+ Фиксированный порядок захвата ресурсов: Если все потоки захватывают ресурсы в одном и том же порядке, Deadlock не
  возникнет.
```java
synchronized (LOCK1) {
    synchronized (LOCK2) {
        // Код
    }
}
```

+ Использование tryLock:
  Класс ReentrantLock из пакета java.util.concurrent.locks предоставляет метод tryLock, который пытается захватить
  ресурс, но не блокирует поток, если это невозможно.

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class TryLockExample {
    private static final Lock lock1 = new ReentrantLock();
    private static final Lock lock2 = new ReentrantLock();

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            if (lock1.tryLock()) {
                try {
                    System.out.println("Thread 1: захватил lock1");
                    if (lock2.tryLock()) {
                        try {
                            System.out.println("Thread 1: захватил lock2");
                        } finally {
                            lock2.unlock();
                        }
                    }
                } finally {
                    lock1.unlock();
                }
            }
        });
        Thread thread2 = new Thread(() -> {
            if (lock2.tryLock()) {
                try {
                    System.out.println("Thread 2: захватил lock2");
                    if (lock1.tryLock()) {
                        try {
                            System.out.println("Thread 2: захватил lock1");
                        } finally {
                            lock1.unlock();
                        }
                    }
                } finally {
                    lock2.unlock();
                }
            }
        });
        thread1.start();
        thread2.start();
    }
}
```
+ Использование тайм-аутов:
При захвате ресурсов можно использовать методы с тайм-аутом, чтобы избежать бесконечного ожидания.

#### Пример взаимоблокировки с потоками в метафоре

Представь двух людей, каждый из которых держит вилку и хочет взять нож у другого, чтобы поесть. Они стоят, не отпуская
вилок, ожидая, пока другой отдаст нож. Это и есть Deadlock: никто не может продолжить, потому что никто не уступает.

Чтобы избежать этого:

+ Пусть каждый человек сначала кладет вилку, а потом берет нож.
+ Или пусть один из них подождет определенное время и попробует снова.

[К оглавлению](#Multithreading)

# 7. Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.

- HashTable - это HashMap с синхронизированными методами.
- SynchronizedMap оборачивает HashMap с помощью одного блокирующего монитора, то есть делает коллекцию
  синхронизированной.
- ConcurrentHashMap несет в себе идею сегментированной блокировки. Допускает неблокирующее чтение.

#### HashTable.

"Предок" HashMap, который унаследовал интерфейс Map с появлением Java 2. Отличается от HashMap тем, что имеет некоторые
свои функции, например, счетчики - Enumerators. Не поддерживает null в виде ключа. Во всем остальном это та же HashMap,
только с синхронизированными методами.

#### Collections.synchronizedMap(new HashMap()).

Создает синхронизированную версию HashMap с блокирующим доступом. Все её методы синхронизированы, тем самым при работе с
этой коллекцией блокируется сам объект. Если одна нить обратилась к этой коллекции, все остальные нити будут вставать в
очередь и ждать, пока первая нить её освободит, чтобы получить к ней доступ так же по очереди.

HashTable и Collections.synchronizedMap(new HashMap()) работают одинаково, разница только в том, что HashTable - это
отдельный класс с некоторыми своими функциями. Минус этих коллекций в том, что они сильно снижают производительность
работы из-за полной блокировки объекта, поэтому при большом количестве обращений к коллекции, производительность сильно
снижается. Плюсом же является согласованность, то есть в один момент времени в коллекцией может работать только одна
нить.

#### ConcurrentHashMap.

Потокобезопасная и эффективная Map. До JDK 1.8 представляла собой HashMap, хеш-массив которого был поделен на сегменты -
небольшие массивы, хранящие данные в LinkedList в каждой ячейке. Начиная с Java 1.8 произошли изменения: теперь
коллекция состоит из массива узлов, в которых хранятся LinkedList. Когда количество элементов в LinkedList становится
больше 8 элементов, этот LinkedList преобразуется в красно-черное сбалансированное дерево. В версии до 1.8 блокировался
весь сегмент, коллекция работала быстрее, чем HashTable и Collections.synchronizedMap(new HashMap()), а с версии 1.8
производительность еще больше возросла благодаря трансформации в красно-черное дерево. При обращении к коллекции
блокируется только корень дерева или первый узел связного списка, то есть используются CAS + synchronized операции.

ConcurrentHashMap позволяет одновременное изменение карты из нескольких нитей. Операции считывания (get) не блокируются.
Операции обновления (put / remove) происходят при помощи блокировки отдельного элемента карты, то есть несколько потоков
одновременно могут и получать значения из карты, и класть данные в разные части карты. То есть с картой одновременно
могут работать и читатели, и писатели, в отличие от синхронизированных коллекций HashTable и
Collections.synchronizedMap(new HashMap()).

ConcurrentHashMap предоставляет fail-safe итератор для перебора элементов карты, который содержит копию реальных данных,
что позволяет другим нитям изменять карту во время итерации. При этом без гарантии, что данные, вставленные в карту во
время этой итерации, будут в ней присутствовать. Таким образом, исключение ConcurrentModificationException при попытке
изменения карты другой нитью во время итерации выброшено не будет.

ConcurrentHashMap не поддерживает null в качестве ключа.

#### Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap предназначены для работы с потоками, но их реализация иповедение значительно различаются.

1. Блокировка (Locking)

`Collections.synchronizedMap(new HashMap())`

+ Синхронизация всей карты:
  + Все методы, работающие с картой, синхронизированы с использованием одного единственного мьютекса. Это значит, что
    весь объект блокируется, даже если только одна операция выполняется.
    Например, чтение или запись будет блокировать доступ ко всей карте для других потоков.

`ConcurrentHashMap`

+ Разделенная блокировка (Segmented Locking):
  + Использует более тонкую гранулярность блокировки: блокируются только определённые части карты (ранее — сегменты, в
    современных версиях — корзины).
    Это позволяет нескольким потокам одновременно работать с разными частями карты без конфликтов.

2. Производительность

`Collections.synchronizedMap(new HashMap())`

+ Медленнее в многопоточной среде:
  + Из-за глобальной блокировки производительность падает при увеличении числа потоков.
  + Подходит только для случаев, где запись/чтение выполняется редко, а многопоточность минимальна.

`ConcurrentHashMap`

+ Быстрее в многопоточной среде:
  + Благодаря разделению блокировок, больше потоков могут одновременно выполнять операции чтения и записи.
  + Идеально подходит для высоконагруженных приложений.

3. Поддержка конкурентного доступа

`Collections.synchronizedMap(new HashMap())`

+ Не поддерживает итерацию без ошибок (fail-safe):
При модификации карты во время итерации будет выброшено ConcurrentModificationException.

`ConcurrentHashMap`

+ Поддерживает конкурентную итерацию:
  + Использует механизм "ослабленной консистентности" (weakly consistent):
  + Изменения, сделанные другими потоками, могут быть видны или не видны во время итерации, но исключения не
    выбрасываются.

4. Наличие null ключей и значений

`Collections.synchronizedMap(new HashMap())`

+ Разрешает null ключи и значения: Один null ключ и множество null значений допустимы.

`ConcurrentHashMap`

+ Не разрешает null:
  + Ключи и значения не могут быть null.
    Это сделано, чтобы избежать неоднозначностей в многопоточной среде (например, если get(null) возвращает null,
    непонятно, отсутствует ли ключ или значение равно null).

5. Пример использования

```java
Collections.synchronizedMap(new HashMap())

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

public class SynchronizedMapExample {
  public static void main(String[] args) {
    Map<String, String> map = Collections.synchronizedMap(new HashMap<>());
    map.put("1", "one");
    map.put("2", "two");
    synchronized (map) {
      for (Map.Entry<String, String> entry : map.entrySet()) {
        System.out.println(entry.getKey() + " -> " + entry.getValue());
      }
    }
  }
}
Замечание: Для итерации нужно вручную синхронизировать блок, 
так как внутренняя синхронизация не гарантирует безопасной итерации.
```

```java
ConcurrentHashMap

import java.util.concurrent.ConcurrentHashMap;

public class ConcurrentHashMapExample {
  public static void main(String[] args) {
    ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();

    map.put("1", "one");
    map.put("2", "two");

    for (Map.Entry<String, String> entry : map.entrySet()) {
      System.out.println(entry.getKey() + " -> " + entry.getValue());
    }
  }
}
Замечание: Дополнительной синхронизации для итерации не требуется.
```

| Критерий            | Collections.synchronizedMap	   | ConcurrentHashMap                      |
|---------------------|--------------------------------|----------------------------------------|
| Количество потоков  | Небольшое                      | Высоконагруженные многопоточные задачи |
| Частота операций    | Низкая (редкие чтения/записи)  | Частое чтение/запись                   |
| Итерация            | Требуется ручная синхронизация | Безопасна для многопоточной итерации   |
| null ключи/значения | Поддерживает                   | Не поддерживает                        |

[К оглавлению](#Multithreading)

# 8. Различия в интерфейсах Runnable и Callable.

Оба интерфейса используются для создания задач, которые могут выполняться в потоках, но они имеют разные возможности и
предназначение.

| Критерий                     | Runnable	                                                  | Callable                                                                                  |
|------------------------------|------------------------------------------------------------|-------------------------------------------------------------------------------------------|
| Пакет                        | Находится в пакете java.lang.                              | Находится в пакете java.util.concurrent.                                                  |
| Метод                        | Содержит метод: void run().                                | Содержит метод: V call() throws Exception.                                                |
| Возвращаемое значение        | Ничего не возвращает (тип void).                           | Возвращает значение (тип V).                                                              |
| Обработка исключений         | Исключения должны обрабатываться внутри метода run.        | Может выбрасывать проверяемые исключения.                                                 |
| Использование                | Подходит для задач, которым не нужно возвращать результат. | Используется для задач, которые возвращают результат или могут выбросить исключение.      |
| Интеграция с ExecutorService | Передается в ExecutorService как задача для выполнения.    | Возвращает объект типа Future<V>, который позволяет получить результат выполнения задачи. |

```java
Пример использования Runnable

public class RunnableExample {
  public static void main(String[] args) {
    Runnable task = () -> {
      System.out.println("Выполняется задача Runnable");
    };
    Thread thread = new Thread(task);
    thread.start();
  }
}

Задача выполняется, но не возвращает результат.
Исключения внутри задачи нужно обрабатывать вручную.
```

```java
Пример использования Callable

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class CallableExample {
  public static void main(String[] args) {
    Callable<String> task = () -> {
      return "Результат выполнения Callable";
    };

    ExecutorService executor = Executors.newSingleThreadExecutor();
    Future<String> future = executor.submit(task);

    try {
      // Получаем результат выполнения задачи
      String result = future.get();
      System.out.println(result);
    } catch (Exception e) {
      e.printStackTrace();
    } finally {
      executor.shutdown();
    }
  }
}

Задача возвращает результат выполнения через объект Future.
Исключения можно обрабатывать через Future.get().
```

#### Когда использовать?

`Runnable`:
+ Для задач, которые выполняются в потоке, но не возвращают результата.
Например: запись данных в файл, логирование.

`Callable`:
+ Для задач, которые возвращают результат или могут выбросить исключение.
Например: выполнение сложных вычислений, запрос данных из базы.

#### Ключевые отличия в метафоре

Представь, что тебе нужно отправить курьера за посылкой:

`Runnable`:
Курьер просто идёт по твоему поручению, но ничего не возвращает. Если что-то пошло не так, тебе нужно было заранее
предусмотреть, как это обработать.
`Callable`:
Курьер возвращается с посылкой, и ты можешь узнать результат его работы. Если произошла ошибка, он сообщает тебе об этом
через исключение.

[К оглавлению](#Multithreading)

# 9. Различия между isInterrupted(), interrupted(), interrupt().

Эти методы относятся к управлению состоянием прерывания потока в Java. Прерывание в Java — это механизм, с помощью
которого один поток может попросить другой поток завершить свою работу.

1. isInterrupted()

+ Проверяет флаг прерывания у текущего объекта потока.
+ Флаг прерывания не сбрасывается.
+ Используется для проверки состояния другого потока.

```java
public class IsInterruptedExample {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                System.out.println("Работаю...");
            }
            System.out.println("Поток прерван.");
        });

        thread.start();
        Thread.sleep(1000); // Даем потоку немного поработать
        thread.interrupt(); // Прерываем поток
    }
}
Поток завершает работу, когда видит, что флаг прерывания установлен.
```

2. interrupted()

+   Статический метод, который проверяет флаг прерывания текущего потока.
+   Сбрасывает флаг прерывания после вызова (ставит его в false).
+   Используется для выполнения действий и одновременного сброса флага.

```java
public class InterruptedExample {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            while (true) {
                if (Thread.interrupted()) {
                    System.out.println("Флаг прерывания сброшен.");
                    break;
                }
            }
        });

        thread.start();
        Thread.sleep(1000); // Даем потоку немного поработать
        thread.interrupt(); // Прерываем поток
    }
}
Поток завершает работу после обнаружения прерывания. 
Флаг прерывания автоматически сбрасывается.
```

3. interrupt()

+   Устанавливает флаг прерывания у целевого потока.
+   Если поток находится в блокирующем состоянии (например, в ожидании sleep, wait), выбрасывается InterruptedException.
```java
public class InterruptExample {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                System.out.println("Поток был прерван во время сна.");
            }
        });

        thread.start();
        Thread.sleep(1000); // Даем потоку немного поспать
        thread.interrupt(); // Прерываем поток
    }
}
Если поток находится в состоянии сна, 
он выходит из него с выбросом InterruptedException.
```

#### Ключевые моменты

+    Используй interrupt() для отправки сигнала потоку.
+    Проверяй состояние флага с помощью isInterrupted(), если не хочешь его сбрасывать.
+    Применяй interrupted(), если необходимо сбросить флаг после проверки.

| Метод           | Класс	               | Описание                                                                                                          |
|-----------------|----------------------|-------------------------------------------------------------------------------------------------------------------|
| isInterrupted() | Thread               | Возвращает true, если текущий поток был прерван. Не сбрасывает флаг прерывания.                                   |
| interrupted()   | Thread (статический) | Проверяет, был ли текущий поток прерван, и сбрасывает флаг прерывания (устанавливает его в false).                |
| interrupt()     | Thread               | Устанавливает флаг прерывания у целевого потока (это просто сигнал, поток решает, как реагировать на прерывание). |

[К оглавлению](#Multithreading)

# 10. Что происходит при вызове Thread.interrupt()?

Метод interrupt() устанавливает флаг прерывания (interruption flag) у указанного потока. Это своего рода сигнал потоку:
«Тебя просят остановиться». Однако, важно понимать, что interrupt() не заставляет поток немедленно завершить работу — он
лишь передает эту просьбу, и поток должен самостоятельно обработать ее.

#### Два сценария при вызове Thread.interrupt()

+ Поток НЕ находится в блокирующем состоянии
  + Флаг прерывания у потока устанавливается в true.
  + Поток может проверить этот флаг с помощью методов isInterrupted() или interrupted() и принять решение о завершении
    работы.

+ Поток находится в блокирующем состоянии
  + Если поток выполняет такие методы, как Thread.sleep(), Object.wait(), join(), или другие методы ожидания, то они
    выбрасывают исключение InterruptedException, и флаг прерывания сбрасывается в false. Поток должен самостоятельно
    обработать это исключение.

```java
Поток НЕ в блокирующем состоянии

public class InterruptExample {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                System.out.println("Работаю...");
            }
            System.out.println("Поток завершает работу.");
        });

        thread.start();
        Thread.sleep(1000); // Даем потоку поработать
        thread.interrupt(); // Прерываем поток
    }
}
Поток продолжает работать, пока флаг прерывания не установлен.
После вызова interrupt(), флаг прерывания становится true, 
и поток завершает свою работу.
```

```java
Поток в блокирующем состоянии

public class InterruptBlockingExample {
  public static void main(String[] args) throws InterruptedException {
    Thread thread = new Thread(() -> {
      try {
        System.out.println("Поток начинает спать...");
        Thread.sleep(5000); // Переход в блокирующее состояние
      } catch (InterruptedException e) {
        System.out.println("Поток прерван во время сна.");
      }
    });

    thread.start();
    Thread.sleep(1000); // Даем потоку начать сон
    thread.interrupt(); // Прерываем поток
  }
}
Поток выходит из состояния сна и выбрасывает InterruptedException.
Обработка исключения позволяет потоку завершить работу.
```

#### Ключевые моменты про interrupt()

+ Не завершает поток немедленно.
  + Поток сам решает, как реагировать на прерывание. Он должен регулярно проверять флаг прерывания или обрабатывать InterruptedException.

+ Необходима обработка InterruptedException.
  + Если поток находится в блокирующем состоянии, такие методы, как sleep(), wait(), или join() выбрасывают исключение, и поток может обработать его для корректного завершения.

+ Используется как сигнал.
  + interrupt() сообщает потоку о необходимости остановиться, но сам по себе ничего не делает, кроме установки флага или генерации исключения в блокирующем состоянии.

[К оглавлению](#Multithreading)

# 11. Перечислите ВСЕ причины по которым может быть выброшено InterruptedException.

#### Причины выброса InterruptedException

В Java исключение InterruptedException выбрасывается, когда поток, находящийся в блокирующем состоянии, получает сигнал
прерывания с помощью метода interrupt(). Блокирующие состояния — это ситуации, когда поток ожидает завершения действия
или освобождения ресурса.
#### Список методов, которые могут выбросить InterruptedException:

+ Методы класса Thread:
  + Thread.sleep(long millis)
  + Thread.sleep(long millis, int nanos)
  +  Thread.join()
  + Thread.join(long millis)
  + Thread.join(long millis, int nanos)

+ Методы синхронизации Object:
  + Object.wait()
  + Object.wait(long timeout)
  + Object.wait(long timeout, int nanos)

+ Методы интерфейса BlockingQueue (и его реализаций, например, ArrayBlockingQueue, LinkedBlockingQueue):
  + put(E e)
  + take()
  + poll(long timeout, TimeUnit unit)
  + offer(E e, long timeout, TimeUnit unit)

+ Методы интерфейса Lock (и его реализаций, например, ReentrantLock):
  + lockInterruptibly()
  + tryLock(long time, TimeUnit unit)

+ Методы интерфейса ExecutorService (и его реализаций, например, ThreadPoolExecutor):
  + invokeAll(Collection<? extends Callable<T>> tasks)
  + invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
  + invokeAny(Collection<? extends Callable<T>> tasks)
  + invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)

+ Методы класса CountDownLatch:
  + await()
  + await(long timeout, TimeUnit unit)

+ Методы класса CyclicBarrier:
  + await()
  + await(long timeout, TimeUnit unit)

+ Методы класса Semaphore:
  + acquire()
  + acquire(int permits)
  + acquireUninterruptibly() (если поток был прерван до вызова метода, но сам метод не выбросит исключение)
  + tryAcquire(long timeout, TimeUnit unit)

+ Методы класса Exchanger:
  + exchange(V x)
  + exchange(V x, long timeout, TimeUnit unit)

+ Методы класса Phaser:
  + awaitAdvanceInterruptibly(int phase)
  + awaitAdvanceInterruptibly(int phase, long timeout, TimeUnit unit)

+ Методы класса Future:
  + get()
  + get(long timeout, TimeUnit unit)

#### Когда выбрасывается InterruptedException?

+ Прерывание сна: Поток вызвал метод sleep() и был прерван.
+ Прерывание ожидания: Поток вызвал методы wait() или await() (на объектах или в синхронизаторах) и был прерван.
+ Прерывание блокировки: Поток пытался захватить блокировку с помощью lockInterruptibly() или аналогичных методов, и в
  это время был прерван.
+ Прерывание работы с синхронизаторами: Поток использовал методы синхронизаторов (таких как CountDownLatch, Semaphore,
  Exchanger, CyclicBarrier) и был прерван.
+ Прерывание выполнения задач: Поток ожидал завершения выполнения задач через методы invokeAll() или invokeAny() и
  получил сигнал прерывания.

#### Ключевые моменты

+ InterruptedException всегда возникает только в блокирующих операциях, когда поток не может немедленно продолжить
  выполнение.
+ Метод, выбрасывающий InterruptedException, сбрасывает флаг прерывания. Поток должен заново установить его, если
  необходимо.
+ Это проверяемое (checked) исключение, которое обязательно нужно обрабатывать или пробрасывать выше.

[К оглавлению](#Multithreading)

# 12. Назовите отличия synchronized{} и ReentrantLock.

1. Синтаксис

`synchronized` — это встроенный механизм, который используется в блоках или методах:
```java
synchronized (object) {
// код с доступом к общим ресурсам
}
```
`ReentrantLock` — это класс из библиотеки java.util.concurrent.locks, который нужно явно создавать и управлять:
```java
ReentrantLock lock = new ReentrantLock();
lock.lock();
try {
    // код с доступом к общим ресурсам
} finally {
    lock.unlock();
}
```
2. Блокировка

`synchronized`:
+ Автоматически блокирует объект.
+ Блокировка освобождается автоматически, когда поток выходит из блока или метода.

`ReentrantLock`:
+ Требует явного вызова lock() для захвата блокировки и unlock() для её освобождения.
+ Если unlock() не вызван (например, из-за исключения), может произойти блокировка ресурса.

3. Попытка захватить блокировку

`synchronized`:
+ Если блокировка занята, поток ждет бесконечно, пока она не будет освобождена.

`ReentrantLock`:
+ Позволяет попытаться захватить блокировку с помощью:
  + tryLock() — не блокирует поток, возвращает false, если блокировка занята.
  + tryLock(long time, TimeUnit unit) — пытается захватить блокировку в течение заданного времени.

4. Ожидание с прерыванием

`synchronized`:
+ Поток, ожидающий захвата блокировки, не может быть прерван. Он будет ждать до тех пор, пока блокировка не освободится.

`ReentrantLock`:
+ Поток может быть прерван с помощью lockInterruptibly(), если его вызвали с сигналом interrupt().

5. Гибкость (Условные переменные)

`synchronized`:
+ Использует встроенные методы wait(), notify(), notifyAll() для управления состоянием потоков.
+ Эти методы работают только с текущим объектом монитора.

`ReentrantLock`:
+ Предоставляет более гибкий механизм через объект Condition, который можно использовать для точного управления
  ожиданием и уведомлением:
```java
Condition condition = lock.newCondition();
condition.await();  // ожидание
condition.signal(); // уведомление одного потока
condition.signalAll(); // уведомление всех потоков
```
6. Производительность

`synchronized`:

+ Начиная с Java 1.6, синхронизация была оптимизирована (например, появился lightweight locking), что делает её
  конкурентоспособной с ReentrantLock в простых случаях.

`ReentrantLock`:
+ Может быть быстрее в сложных сценариях, особенно если требуется управление временем ожидания или использование
  условий.

7. Повторный захват блокировки (Reentrancy)

`synchronized`:
+ Поддерживает повторный захват блокировки одним и тем же потоком.

`ReentrantLock`:
+ Также поддерживает повторный захват блокировки, и предоставляет информацию о количестве захватов через getHoldCount().

8. Отладка

`synchronized`:
+ Труднее получить информацию о состоянии блокировки (например, кто её удерживает).

`ReentrantLock`:
+ Предоставляет методы для получения состояния блокировки:
  + isLocked() — заблокирован ли ресурс.
  + isHeldByCurrentThread() — удерживает ли текущий поток - блокировку.
  + getQueueLength() — количество потоков, ожидающих блокировки.

#### Когда использовать?

`synchronized`:
+ Для простых сценариев синхронизации, где не требуется сложное управление блокировкой или ожиданием.
```java
    synchronized (this) {
        sharedResource++;
    }
```
`ReentrantLock`:

+ Для сложных сценариев, где требуется:
  + Попытка захвата блокировки (tryLock).
  + Управление временем ожидания.
  + Использование условных переменных (Condition).
  + Прерываемое ожидание (lockInterruptibly).

```java
ReentrantLock lock = new ReentrantLock();
try {
    if (lock.tryLock(1, TimeUnit.SECONDS)) {
        sharedResource++;
    }
} finally {
    lock.unlock();
}
```
[К оглавлению](#Multithreading)

# 13. Приведите наиболее существенное отличие между CountDownLatch и CyclicBarrier.

Главное различие между этими двумя синхронизаторами заключается в их назначении и поведении после выполнения задачи:

#### Назначение

`CountDownLatch`:
+ Используется для ожидания завершения определенного числа операций перед продолжением основного потока.
+ Часто применяется, когда основной поток должен дождаться выполнения нескольких потоков.
+ Одноразовый механизм: после того как счетчик (count) доходит до нуля, объект CountDownLatch больше не может быть
   использован.

`CyclicBarrier`:
+ Используется для синхронизации группы потоков: все потоки должны достичь определенной точки (барьера), после чего они
   продолжают выполнение.
+ Повторно используемый механизм: после достижения барьера он сбрасывается и может использоваться снова.

#### Поведение

`CountDownLatch`:
+ Имеет счетчик (count), который уменьшается вызовом метода countDown(). Когда счетчик достигает нуля, потоки,
   вызвавшие метод await(), продолжают выполнение.
+ Потоки, уменьшающие счетчик, не блокируются.

`CyclicBarrier`:
+ Потоки вызывают метод await() и блокируются до тех пор, пока все потоки не достигнут барьера.
+ После достижения барьера все потоки продолжают выполнение.

```java
CountDownLatch: ожидание завершения работы потоков

import java.util.concurrent.CountDownLatch;

public class CountDownLatchExample {
  public static void main(String[] args) throws InterruptedException {
    int threadCount = 3;
    CountDownLatch latch = new CountDownLatch(threadCount);

    for (int i = 0; i < threadCount; i++) {
      new Thread(() -> {
        System.out.println(Thread.currentThread().getName() + " выполняет работу.");
        latch.countDown(); // Уменьшаем счетчик
      }).start();
    }

    latch.await(); // Ждем, пока счетчик станет равным 0
    System.out.println("Все потоки завершили работу.");
  }
}
```

```java
CyclicBarrier: синхронизация потоков

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierExample {
  public static void main(String[] args) {
    int threadCount = 3;
    CyclicBarrier barrier = new CyclicBarrier(threadCount,
            () -> System.out.println("Все потоки достигли барьера. Продолжаем выполнение."));

    for (int i = 0; i < threadCount; i++) {
      new Thread(() -> {
        System.out.println(Thread.currentThread().getName() + " выполняет работу.");
        try {
          barrier.await(); // Ждем, пока все потоки достигнут барьера
        } catch (InterruptedException | BrokenBarrierException e) {
          e.printStackTrace();
        }
      }).start();
    }
  }
}
```

| Характеристика           | CountDownLatch	                          | CyclicBarrier                         |
|--------------------------|------------------------------------------|------------------------------------------|
| Назначение               | Ожидание завершения операций             | Синхронизация группы потоков.            |
| Одноразовый/Многоразовый | Одноразовый                              | Многоразовый                             |
| Методы                   | countDown(), await()                     | await()                                  |
| Поведение потоков        | Уменьшающий счетчик поток не блокируется | Потоки блокируются до достижения барьера |
| Использование            | Координация основного потока с другими   | Синхронизация группы потоков             |

[К оглавлению](#Multithreading)

# 14. Приведите наиболее существенное отличие между CyclicBarrier и Phaser.

Главное различие между этими двумя механизмами синхронизации заключается в их гибкости и управлении числом участников.

#### Назначение

`CyclicBarrier`:
+ Используется для синхронизации фиксированного числа потоков. Все потоки должны достичь барьера, чтобы продолжить
   выполнение.
+ Число участников указывается при создании и остается неизменным на протяжении работы.

`Phaser`:
+ Более гибкий и поддерживает динамическое управление числом участников (регистрация и снятие потоков во время
   выполнения).
+ Используется для синхронизации нескольких этапов (фаз) выполнения группы потоков.

#### Управление участниками

`CyclicBarrier`:
+ Количество участников задается при создании и не может измениться. Все потоки должны достичь барьера.
+ Если поток выбывает (например, прерывается), это может привести к исключению BrokenBarrierException.

`Phaser`:
+ Потоки могут регистрироваться или сниматься динамически с помощью методов register() и arriveAndDeregister().
+ Поддерживает выполнение задач с переменным числом потоков на разных фазах.

#### Поддержка фаз

`CyclicBarrier`:
+ Не поддерживает понятия фаз. Работает с единственной точкой синхронизации.

`Phaser`:
+ Поддерживает многофазные барьеры, где потоки проходят через последовательные этапы.
+ Номер текущей фазы можно получить через getPhase().

```java
CyclicBarrier: синхронизация фиксированного числа потоков

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierExample {
  public static void main(String[] args) {
    int threadCount = 3;
    CyclicBarrier barrier = new CyclicBarrier(threadCount,
            () -> System.out.println("Барьер достигнут. Продолжаем выполнение."));

    for (int i = 0; i < threadCount; i++) {
      new Thread(() -> {
        System.out.println(Thread.currentThread().getName() + " выполняет работу.");
        try {
          barrier.await(); // Ждем, пока все потоки достигнут барьера
        } catch (InterruptedException | BrokenBarrierException e) {
          e.printStackTrace();
        }
      }).start();
    }
  }
}
```

```java
Phaser: синхронизация нескольких фаз

import java.util.concurrent.Phaser;

public class PhaserExample {
  public static void main(String[] args) {
    Phaser phaser = new Phaser(1); // Главный поток регистрируется

    for (int i = 0; i < 3; i++) {
      int phase = i;
      phaser.register(); // Регистрируем новый поток
      new Thread(() -> {
        System.out.println(Thread.currentThread().getName() + " выполняет фазу " + phase);
        phaser.arriveAndAwaitAdvance(); // Завершаем текущую фазу и ждем
      }).start();
    }

    phaser.arriveAndAwaitAdvance(); // Главный поток завершает первую фазу
    System.out.println("Все потоки завершили фазу 0. Продолжаем.");

    phaser.arriveAndDeregister(); // Главный поток снимается с регистрации
  }
}
```

| Характеристика         | CountDownLatch	                            | CyclicBarrier                                          |
|------------------------|--------------------------------------------|--------------------------------------------------------|
| Назначение             | Синхронизация фиксированного числа потоков | Синхронизация потоков с динамическим числом участников |
| Управление участниками | Фиксированное                              | Динамическое (регистрация/снятие участников)           |
| Поддержка фаз          | Нет                                        | Да                                                     |
| Методы                 | await()                                    | arrive(), arriveAndAwaitAdvance(), register()          |
| Гибкость               | Меньше                                     | Больше                                                 |

#### Когда использовать?

+ Используйте CyclicBarrier, если: Число участников известно заранее и не изменяется. Нужна простая точка синхронизации.
+ Используйте Phaser, если: Число участников может изменяться. Нужно синхронизировать выполнение нескольких фаз.

[К оглавлению](#Multithreading)

# 15. Расскажите про Exchanger.

Exchanger — это инструмент из пакета java.util.concurrent, который используется для синхронизации двух потоков, позволяя
им обмениваться данными. Каждый поток предоставляет некоторый объект другому потоку и получает взамен объект от него.

Это удобно в ситуациях, где два потока работают с разделяемыми данными, например, один поток производит данные, а другой
их обрабатывает.

#### Как работает Exchanger?

+ Один поток вызывает метод exchange(), передавая объект для обмена. Этот поток блокируется до тех пор, пока другой
  поток тоже не вызовет exchange().
+ Когда второй поток вызывает exchange(), происходит обмен объектами, и оба потока продолжают выполнение.
+ Если второй поток не вызывает exchange() в течение определенного времени (если указано), первый поток может получить
  исключение TimeoutException.
```java
Сценарий: обмен данными между двумя потоками

import java.util.concurrent.Exchanger;

public class ExchangerExample {
  public static void main(String[] args) {
    Exchanger<String> exchanger = new Exchanger<>();

    // Поток 1: Отправляет сообщение и получает ответ
    new Thread(() -> {
      try {
        String message = "Привет от Потока 1";
        System.out.println("Поток 1 отправляет: " + message);
        String response = exchanger.exchange(message);
        System.out.println("Поток 1 получил: " + response);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }).start();

    // Поток 2: Отправляет ответ и получает сообщение
    new Thread(() -> {
      try {
        String message = "Ответ от Потока 2";
        System.out.println("Поток 2 отправляет: " + message);
        String response = exchanger.exchange(message);
        System.out.println("Поток 2 получил: " + response);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }).start();
  }
}
```

#### Основные методы

+ exchange(T x): передает объект x другому потоку и возвращает объект, переданный этим потоком.
+ exchange(T x, long timeout, TimeUnit unit): делает то же самое, но с указанием времени ожидания. Если другой поток не
  вызовет exchange() за это время, бросается TimeoutException.

#### Когда использовать Exchanger?

+ Обработка данных между потоками: один поток производит данные, другой их обрабатывает (например,
  шифрование/дешифрование).
+ Обмен промежуточными результатами: в больших вычислительных задачах, где потоки обмениваются частичными результатами.
+ Буферизация: один поток наполняет буфер данными, другой поток очищает его.

#### Потенциальные проблемы

+ Блокировка: Если один поток вызвал exchange(), а другой поток не сделал этого, первый поток будет заблокирован.
+ Исключения:
  + InterruptedException: если поток был прерван во время ожидания.
  + TimeoutException: если второй поток не вызвал exchange() за отведенное время.

| Инструмент     | Назначение	                                        |
|----------------|----------------------------------------------------|
| Exchanger      | Обмен данными между двумя потоками                 |
| CountDownLatch | Ожидание завершения работы заданного числа потоков |
| CyclicBarrier  | Синхронизация группы потоков на общей точке        |
| Phaser         | Многофазная синхронизация потоков                  |

[К оглавлению](#Multithreading)

# 16. Отличие Thread.start() и Thread.run()?

Основное различие заключается в том, запускается ли поток параллельно с основным или просто вызывается метод в текущем
потоке.

`Thread.start()`

+ Этот метод запускает новый поток.
+ Создается отдельный поток выполнения, и метод run() выполняется в этом новом потоке.
+ Управление передается планировщику потоков, который решает, когда новый поток начнет выполнение.

```java
public class ThreadStartExample {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> System.out.println("Это выполняется в новом потоке: " + Thread.currentThread().getName()));
        thread.start(); // Запуск нового потока
        System.out.println("Это выполняется в основном потоке: " + Thread.currentThread().getName());
    }
}
```
`Thread.run()`

+ Это обычный вызов метода, который выполняется в текущем потоке.
+ Не запускает новый поток. Метод run() выполняется как обычный метод, вызываемый в текущем потоке.

```java
public class ThreadRunExample {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> System.out.println("Это выполняется в текущем потоке: " + Thread.currentThread().getName()));
        thread.run(); // Выполнение в текущем потоке
        System.out.println("Это выполняется в основном потоке: " + Thread.currentThread().getName());
    }
}
```

| Характеристика           | Thread.start()	                          | Thread.run()                             |
|--------------------------|------------------------------------------|------------------------------------------|
| Создание нового потока   | Да                                       | Нет                                      |
| Параллельное выполнение  | Код в run() выполняется в новом потоке   | Код в run() выполняется в текущем потоке |
| Управление планировщиком | Передает управление планировщику потоков | Не передает управление планировщику      |
| Использование            | Для запуска потоков                      | Для вызова метода как обычного           |

#### Ошибка, которую нужно избегать

Если вместо start() случайно вызвать run(), то новый поток не будет создан, и программа выполнится в одном потоке. Это
может привести к неожиданному поведению, особенно в многопоточных приложениях.

```java
public class ThreadRunMistake {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> System.out.println("Ошибка: выполняется в текущем потоке: " + Thread.currentThread().getName()));
        thread.run(); // Неправильный вызов, поток не создается!
    }
}

```

[К оглавлению](#Multithreading)

# 17. Объясните ключевое слово volatile.

Ключевое слово volatile в Java используется для указания переменной, доступ к которой осуществляется несколькими
потоками. Оно гарантирует, что:

+ Все потоки видят одно и то же актуальное значение переменной.
+ Операции записи и чтения переменной являются атомарными.

#### Как работает volatile?

Когда переменная объявляется как volatile, она не кэшируется потоками. Вместо этого:

+ Поток всегда читает значение переменной из главной памяти (heap memory).
+ Изменения, сделанные одним потоком, сразу становятся видимыми для других потоков.

```java
Пример без volatile

class SharedData {
  private boolean running = true;

  public void stop() {
    running = false; // Изменение переменной
  }

  public void start() {
    while (running) {
      // Бесконечный цикл
    }
    System.out.println("Поток остановлен");
  }
}

Если running не объявлено как volatile, поток, работающий в методе start(), 
может кэшировать переменную, и изменения, сделанные в методе stop(), 
могут не быть видны другому потоку.
```

```java
Решение с использованием volatile

class SharedData {
  private volatile boolean running = true;

  public void stop() {
    running = false; // Изменение переменной
  }

  public void start() {
    while (running) {
      // Бесконечный цикл
    }
    System.out.println("Поток остановлен");
  }
}

С volatile изменения переменной running, сделанные в методе stop(),
немедленно станут видны для потока, выполняющего метод start().
```

#### Особенности volatile

+ Гарантия видимости:
  + Переменная volatile всегда читается и записывается из/в главную память.
  + Это предотвращает использование устаревшего значения из локального кэша потока.

+ Атомарность записи и чтения:
  + Операции чтения и записи volatile переменной являются атомарными.
  + Однако сложные операции (например, i++) не являются атомарными, даже если i объявлен как volatile.

#### Когда использовать volatile?

+ Переменная используется для сигналов между потоками (например, для остановки потока).
+ Переменная читается и изменяется только одним потоком, но читается несколькими потоками.
+ Не нужно сложной синхронизации, как в случае с synchronized.

#### Когда volatile не подходит?

+ Если требуется блокировка или сложная синхронизация (например, операции i++ или коллекции).
+ Для составных операций, таких как:
  + counter++ (это операция из трёх шагов: чтение, изменение, запись).
  + Сложные структуры данных.

Для таких случаев лучше использовать:
+ synchronized
+ Atomic классы из java.util.concurrent.atomic (например, AtomicInteger).

```java
Пример: ограничение volatile

class Counter {
  private volatile int count = 0;

  public void increment() {
    count++; // НЕ атомарная операция
  }

  public int getCount() {
    return count;
  }
}

Здесь count++ не атомарно. Потоки могут столкнуться с условием гонки (race condition). 
Лучше использовать AtomicInteger:

        import java.util.concurrent.atomic.AtomicInteger;

class Counter {
  private AtomicInteger count = new AtomicInteger(0);

  public void increment() {
    count.incrementAndGet(); // Атомарная операция
  }

  public int getCount() {
    return count.get();
  }
}
```

| Критерий           | volatile	                    | synchronized                                  |
|--------------------|------------------------------|-----------------------------------------------|
| Гарантия видимости | Да                           | Да                                            |
| Атомарность        | Только для чтения и записи   | Да                                            |
| Блокировка         | Нет                          | Да (с блокировкой монитора)                   |
| Производительность | Выше, так как нет блокировок | Меньше из-за накладных расходов на блокировки |

[К оглавлению](#Multithreading)

# 18. Расскажите про приоритеты потока

Приоритеты потоков в Java — это механизм, который позволяет управлять порядком выполнения потоков с помощью приоритетных
значений. Однако стоит отметить, что реализация приоритетов зависит от планировщика операционной системы и JVM, и не
гарантирует строгую последовательность выполнения потоков.

#### Как работают приоритеты потоков?

В Java каждый поток имеет приоритет — целочисленное значение в диапазоне от Thread.MIN_PRIORITY до Thread.MAX_PRIORITY.
По умолчанию все потоки получают нормальный приоритет, равный Thread.NORM_PRIORITY.

+ MIN_PRIORITY: минимальный приоритет, значение 1.
+ NORM_PRIORITY: нормальный приоритет, значение 5.
+ MAX_PRIORITY: максимальный приоритет, значение 10.

```java
Приоритет потока можно установить с помощью метода setPriority(int priority) класса Thread. Например:

public class ThreadPriorityExample {
  public static void main(String[] args) {
    Thread highPriorityThread = new Thread(() -> System.out.println("Этот поток имеет высокий приоритет"));
    Thread lowPriorityThread = new Thread(() -> System.out.println("Этот поток имеет низкий приоритет"));

    highPriorityThread.setPriority(Thread.MAX_PRIORITY); // Устанавливаем высокий приоритет
    lowPriorityThread.setPriority(Thread.MIN_PRIORITY);  // Устанавливаем низкий приоритет

    highPriorityThread.start();
    lowPriorityThread.start();
  }
}
```

#### Планировщик потоков и приоритеты

Java не гарантирует, что потоки с высоким приоритетом будут всегда выполняться раньше потоков с низким приоритетом. Всё
зависит от планировщика потоков операционной системы. Однако на большинстве операционных систем с представлением
приоритетов потоки с высоким приоритетом, как правило, получают больше процессорного времени.

Примечание: В некоторых операционных системах и JVM, например, в Windows, приоритеты потоков могут иметь более явное
влияние, в то время как на других, таких как Linux, они могут быть проигнорированы или им может быть уделено меньше
внимания.

#### Диапазон приоритетов

+ Thread.MIN_PRIORITY — 1: наименьший приоритет.
+ Thread.NORM_PRIORITY — 5: стандартный приоритет.
+ Thread.MAX_PRIORITY — 10: максимальный приоритет.

```java
Пример приоритетов

public class PriorityExample {
  public static void main(String[] args) {
    Thread thread1 = new Thread(() -> {
      for (int i = 0; i < 10; i++) {
        System.out.println("Поток 1: " + i);
      }
    });

    Thread thread2 = new Thread(() -> {
      for (int i = 0; i < 10; i++) {
        System.out.println("Поток 2: " + i);
      }
    });

    thread1.setPriority(Thread.MIN_PRIORITY); // Низкий приоритет
    thread2.setPriority(Thread.MAX_PRIORITY); // Высокий приоритет

    thread1.start();
    thread2.start();
  }
}

В идеале потоки с более высоким приоритетом должны выполняться чаще, но это не всегда так.
```

#### Когда использовать приоритеты потоков?

+ Задачи с разным уровнем важности: Если в вашем приложении есть потоки, выполнение которых более критично (например,
  потоки для обработки пользовательского ввода или работы с важными данными), вы можете задать им более высокий
  приоритет.
+ Реализация квантования времени: Иногда потоки с низким приоритетом могут использоваться для задач, которые могут
  подождать (например, фоновая обработка).
+ Реализация системы реального времени: В реальных приложениях с ограничениями по времени, например, в системах,
  работающих с оборудованием или в играх, могут быть важны приоритеты для своевременного выполнения потоков.

#### Проблемы с приоритетами

+ Старение (Starvation): Потоки с низким приоритетом могут никогда не получить процессорное время, если постоянно будут
  запускаться потоки с более высоким приоритетом.
+ Недостаточное влияние: На некоторых системах приоритеты могут иметь слабое влияние на порядок выполнения потоков.

#### Заключение

+ Приоритеты потоков могут быть полезными для управления выполнением задач с разной важностью.
+ Однако приоритеты потоков не гарантируют строгую последовательность выполнения, и их влияние зависит от операционной
  системы и JVM.
+ Использовать приоритеты потоков нужно осторожно, чтобы избежать проблем с блокировками или старением потоков.

[К оглавлению](#Multithreading)

# 19. Что такое потоки-демоны?

Потоки-демоны (daemon threads) в Java — это специальные фоновые потоки, предназначенные для выполнения вспомогательных
задач, таких как обслуживание или мониторинг, которые не должны препятствовать завершению работы программы.

Основное отличие потоков-демонов от обычных (пользовательских) потоков заключается в следующем: программа завершится,
как только все пользовательские потоки завершат свою работу, даже если в приложении продолжают работать потоки-демоны.

#### Ключевые особенности потоков-демонов

+ Фоновая работа: Потоки-демоны используются для выполнения задач, которые поддерживают основное приложение, например,
  сборка мусора (Garbage Collector) или мониторинг.
+ Не блокируют завершение JVM: Если единственные оставшиеся активные потоки в приложении — это потоки-демоны, JVM
  автоматически завершит их выполнение и остановит программу.
+ Настройка потока: Поток можно сделать демоном с помощью метода setDaemon(true) до вызова start().
+ Примеры потоков-демонов в Java:
  + Garbage Collector — отвечает за управление памятью.
  + JVM Watchdog Threads — следят за состоянием JVM.

```java
Как создать поток-демон?

public class DaemonExample {
    public static void main(String[] args) {
        Thread daemonThread = new Thread(() -> {
            while (true) {
                System.out.println("Демон работает...");
                try {
                    Thread.sleep(1000); // Демон засыпает на 1 секунду
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });

        daemonThread.setDaemon(true); // Устанавливаем поток как демон
        daemonThread.start(); // Запускаем поток

        System.out.println("Главный поток завершен.");
    }
}

Основной поток завершится, а JVM автоматически завершит поток-демон, даже если он ещё выполняется.
```

```java
Вы можете проверить, является ли поток демоном, с помощью метода isDaemon():

Thread thread = new Thread(() -> System.out.println("Работа потока"));
System.out.println("Демон: " + thread.isDaemon()); // По умолчанию false
```

#### Что нужно помнить при работе с потоками-демонами

+ Настройка до запуска: Метод setDaemon(true) нужно вызывать до вызова start(). В противном случае будет выброшено
  исключение IllegalThreadStateException.
+ Демон не завершает задачи: Потоки-демоны могут быть внезапно завершены JVM, поэтому они не подходят для выполнения
  важных операций, например, записи данных на диск или завершения транзакций.
+ Использование с осторожностью: Потоки-демоны — это удобный инструмент, но их внезапное завершение может повлиять на
  целостность данных.

#### Когда использовать потоки-демоны?

+ Мониторинг: Отслеживание состояния системы или приложения.
+ Обслуживание: Фоновые операции, которые не критичны для завершения программы (например, сборка статистики или
  журналирование).
+ Очистка: Удаление временных файлов или ресурсов в фоновом режиме.

[К оглавлению](#Multithreading)

# 20. Назовите все возможные состояния потока.

Класс Thread в Java определяет набор возможных состояний потока. Они описаны в перечислении `java.lang.Thread.State` и
представляют жизненный цикл потока. Состояний всего шесть:

+ `NEW` (новый)
Поток находится в состоянии NEW, если он был создан, но ещё не был запущен с помощью метода start().

```java
Thread thread = new Thread(() -> System.out.println("Работа потока"));
System.out.println(thread.getState()); // NEW
```
+ `RUNNABLE` (готов к выполнению)

Поток находится в состоянии RUNNABLE, если он запущен с помощью метода start(), но фактически может или ожидает
выполнения.
На этом этапе поток может находиться в очереди на выполнение из-за планировщика операционной системы.

```java
Thread thread = new Thread(() -> {
    while (true) {} // Бесконечный цикл
});
thread.start();
System.out.println(thread.getState()); // RUNNABLE
```
+ `BLOCKED` (заблокирован)

Поток находится в состоянии BLOCKED, если он пытается получить монитор объекта, но этот монитор уже занят другим потоком.
Например, поток ожидает входа в synchronized-блок, но монитор объекта заблокирован.

```java
public class BlockedExample {
    public static void main(String[] args) {
        Object lock = new Object();

        Thread thread1 = new Thread(() -> {
            synchronized (lock) {
                try {
                    Thread.sleep(5000); // Удерживаем монитор 5 секунд
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });

        Thread thread2 = new Thread(() -> {
            synchronized (lock) {
                System.out.println("Этот код никогда не выполнится");
            }
        });

        thread1.start();
        thread2.start();

        try {
            Thread.sleep(1000);
            System.out.println(thread2.getState()); // BLOCKED
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

+ `WAITING` (ожидание)

Поток находится в состоянии WAITING, если он ждёт сигнала или уведомления от другого потока. Это состояние возникает при вызове методов:

+ Object.wait()
+ Thread.join() без тайм-аута
+ LockSupport.park()

```java
public class WaitingExample {
    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            try {
                Thread.currentThread().join(); // Бесконечное ожидание
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        thread1.start();

        try {
            Thread.sleep(1000);
            System.out.println(thread1.getState()); // WAITING
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

+ `TIMED_WAITING` (ожидание с тайм-аутом)

Поток находится в состоянии TIMED_WAITING, если он ждёт уведомления или выполнения события в течение определённого
времени. Это состояние возникает при вызове методов:

+ Thread.sleep(time)
+ Object.wait(time)
+ Thread.join(time)
+ LockSupport.parkNanos(time)
+ LockSupport.parkUntil(time)

```java
public class TimedWaitingExample {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            try {
                Thread.sleep(5000); // Ожидание 5 секунд
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        thread.start();

        try {
            Thread.sleep(1000);
            System.out.println(thread.getState()); // TIMED_WAITING
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```
+ `TERMINATED` (завершён)

Поток находится в состоянии TERMINATED, если он завершил своё выполнение. Это может произойти:

+ Когда поток завершил выполнение своего метода run().
+ Когда поток завершился с исключением.

```java
public class TerminatedExample {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> System.out.println("Работа потока завершена"));
        thread.start();

        try {
            thread.join(); // Дождёмся завершения потока
            System.out.println(thread.getState()); // TERMINATED
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

| Состояние     | Когда возникает	                                        |
|---------------|---------------------------------------------------------|
| NEW           | Поток создан, но не запущен.                            |
| RUNNABLE      | Поток готов к выполнению или выполняется                |
| BLOCKED       | Поток ожидает освобождения монитора                     |
| WAITING       | Поток ждёт уведомления от другого потока без тайм-аута. |
| TIMED_WAITING | Поток ждёт уведомления или события с тайм-аутом         |
| TERMINATED    | Поток завершил выполнение                               |

[К оглавлению](#Multithreading)

# 21. Что такое race condition?

Race Condition (состояние гонки) — это ошибка в многопоточной программе, которая возникает, когда два или более потока
одновременно пытаются получить доступ и изменить общий ресурс, и результат выполнения программы становится
непредсказуемым.

#### Ключевые признаки Race Condition

+ Совместный доступ: Несколько потоков работают с одним и тем же ресурсом (например, переменной, файлом, коллекцией).
+ Отсутствие синхронизации: Нет механизмов, которые регулируют порядок или безопасность доступа к общему ресурсу.
+ Зависимость от порядка выполнения: Результат работы программы зависит от того, какой поток первым выполнил свою
  операцию.

```java
Допустим, несколько потоков увеличивают значение одной переменной

public class RaceConditionExample {
    private static int counter = 0;

    public static void main(String[] args) {
        Runnable incrementTask = () -> {
            for (int i = 0; i < 1000; i++) {
                counter++;
            }
        };

        Thread thread1 = new Thread(incrementTask);
        Thread thread2 = new Thread(incrementTask);

        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        System.out.println("Counter: " + counter); // Результат может быть неверным!
    }
}

Что происходит:
Переменная counter изменяется двумя потоками одновременно.
Инструкция counter++ не атомарна (включает чтение, изменение, запись).
Итоговое значение counter становится непредсказуемым, 
так как потоки могут перезаписывать результаты друг друга.
```
#### Как предотвратить Race Condition
```java
Синхронизация: Использовать блоки synchronized или методы для защиты общих ресурсов.

public class SynchronizedExample {
  private static int counter = 0;

  public synchronized static void increment() {
    counter++;
  }

  public static void main(String[] args) {
    Runnable incrementTask = () -> {
      for (int i = 0; i < 1000; i++) {
        increment();
      }
    };

    Thread thread1 = new Thread(incrementTask);
    Thread thread2 = new Thread(incrementTask);

    thread1.start();
    thread2.start();

    try {
      thread1.join();
      thread2.join();
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
    }

    System.out.println("Counter: " + counter); // Результат корректен
  }
}
```

```java
ReentrantLock: Более гибкая альтернатива synchronized, с 
поддержкой дополнительных возможностей, например, таймаутов.

import java.util.concurrent.locks.ReentrantLock;

public class LockExample {
  private static int counter = 0;
  private static final ReentrantLock lock = new ReentrantLock();

  public static void main(String[] args) {
    Runnable incrementTask = () -> {
      for (int i = 0; i < 1000; i++) {
        lock.lock();
        try {
          counter++;
        } finally {
          lock.unlock();
        }
      }
    };

    Thread thread1 = new Thread(incrementTask);
    Thread thread2 = new Thread(incrementTask);

    thread1.start();
    thread2.start();

    try {
      thread1.join();
      thread2.join();
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
    }

    System.out.println("Counter: " + counter); // Результат корректен
  }
}
```

```java
Atomic-переменные: Использовать классы из пакета java.util.concurrent.atomic, 
например, AtomicInteger, которые обеспечивают атомарные операции.

import java.util.concurrent.atomic.AtomicInteger;

public class AtomicExample {
  private static AtomicInteger counter = new AtomicInteger(0);

  public static void main(String[] args) {
    Runnable incrementTask = () -> {
      for (int i = 0; i < 1000; i++) {
        counter.incrementAndGet();
      }
    };

    Thread thread1 = new Thread(incrementTask);
    Thread thread2 = new Thread(incrementTask);

    thread1.start();
    thread2.start();

    try {
      thread1.join();
      thread2.join();
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
    }

    System.out.println("Counter: " + counter.get()); // Результат корректен
  }
}
```

#### Последствия Race Condition

+ Некорректное поведение программы: Неправильные вычисления, ошибки логики. 
+ Трудности в отладке: Проблемы возникают не всегда, а только при определённых условиях, зависящих от скорости
  выполнения потоков.
+ Проблемы с безопасностью: Например, при неправильной обработке транзакций в банковских приложениях.

[К оглавлению](#Multithreading)

# 22. Что такое Thread Local переменная?

Thread Local переменная — это специальный механизм в Java, который позволяет каждому потоку иметь свою собственную копию переменной. Переменная создаётся с помощью класса ThreadLocal.

Каждый поток работает со своей копией переменной, изолированной от других потоков. Это особенно полезно, если требуется хранить состояние, уникальное для каждого потока, без необходимости синхронизации.
#### Как работает ThreadLocal?

При использовании ThreadLocal, переменная привязывается к конкретному потоку. Внутри класса Thread есть карта, которая связывает поток с его значениями ThreadLocal. Когда поток запрашивает значение через get(), возвращается его уникальная копия.
#### Основные методы ThreadLocal

+ `set(T value)`
Устанавливает значение для текущего потока.

+ `get()`
Возвращает значение, связанное с текущим потоком. Если значение ещё не установлено, вызывается метод initialValue().

+ `remove()`
Удаляет значение для текущего потока, освобождая память.

+ `withInitial(Supplier<? extends T>)`
Создаёт ThreadLocal с заданным начальным значением.

```java
Представьте, что нужно отслеживать идентификатор запроса для каждого потока, обрабатывающего запросы:

public class ThreadLocalExample {
    // Создаём ThreadLocal переменную
    private static final ThreadLocal<String> threadLocal = ThreadLocal.withInitial(() -> "Default Request ID");

    public static void main(String[] args) {
        Runnable task = () -> {
            String threadName = Thread.currentThread().getName();
            threadLocal.set("RequestID-" + threadName);
            System.out.println(threadName + " -> " + threadLocal.get());
        };

        Thread thread1 = new Thread(task, "Thread-1");
        Thread thread2 = new Thread(task, "Thread-2");

        thread1.start();
        thread2.start();
    }
}
```

#### Где используется ThreadLocal?

+ Контексты для логирования:
  Например, сохранять идентификатор запроса или сессию для каждого потока.
+ Объекты, которые нельзя шарить:
  Например, форматеры (SimpleDateFormat), которые не потокобезопасны.
+ Пулл соединений с базой данных:
  Связывание конкретного соединения с потоком.

#### Проблемы ThreadLocal

+ Утечки памяти:
  Если потоки из пула не освобождают значение ThreadLocal через remove(), это может привести к утечкам памяти.
+ Сложность тестирования:
  Использование ThreadLocal усложняет тестирование, так как значения привязаны к потокам.

#### Когда использовать ThreadLocal?

+ Когда нужно обеспечить потоковую изоляцию данных.
+ Когда нет необходимости в глобальной доступности переменной для всех потоков.
+ Если синхронизация ресурсов слишком дорогостоящая или сложная.

[К оглавлению](#Multithreading)

# 23. Что такое FutureTask?

FutureTask — это класс из пакета java.util.concurrent, который представляет собой объединение задачи и её результата. Он
используется для выполнения задач в другом потоке и получения результата (или обработки исключений) после завершения
выполнения.

FutureTask реализует интерфейсы Runnable и Future, что делает его универсальным:

+ Его можно выполнять в отдельном потоке (через Thread или Executor).
+ Его можно использовать для получения результата асинхронной задачи.

#### Как работает FutureTask?

+ Создание задачи: Вы определяете задачу, которую нужно выполнить, через объект Callable или Runnable.
+ Запуск задачи: FutureTask передаётся в Thread или ExecutorService для выполнения.
+ Получение результата: Используется метод get() для получения результата задачи после её завершения.

#### Основные методы FutureTask

+ `run()`
Выполняет задачу. Обычно вызывается из потока.

+ `get()`
Блокирует выполнение до завершения задачи и возвращает её результат.

+ `cancel(boolean mayInterruptIfRunning)`
    Отменяет задачу, если это возможно.

+ `isDone()`
    Проверяет, завершена ли задача.

+ `isCancelled()`
    Проверяет, была ли задача отменена.

```java
Асинхронное выполнение задачи

import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

public class FutureTaskExample {
  public static void main(String[] args) throws Exception {
    // Определяем задачу через Callable
    Callable<String> task = () -> {
      Thread.sleep(2000); // Симуляция долгой задачи
      return "Result from FutureTask";
    };

    // Создаём FutureTask
    FutureTask<String> futureTask = new FutureTask<>(task);

    // Запускаем FutureTask в отдельном потоке
    Thread thread = new Thread(futureTask);
    thread.start();

    // Выполняем другую работу
    System.out.println("Doing other work while task is running...");

    // Получаем результат задачи
    String result = futureTask.get(); // Блокируется до завершения задачи
    System.out.println("Task result: " + result);
  }
}
```

```java
Использование с ExecutorService

import java.util.concurrent.*;

public class ExecutorFutureTaskExample {
  public static void main(String[] args) throws Exception {
    ExecutorService executor = Executors.newFixedThreadPool(2);

    Callable<Integer> task = () -> {
      Thread.sleep(1000);
      return 42;
    };

    FutureTask<Integer> futureTask = new FutureTask<>(task);

    // Запускаем FutureTask через Executor
    executor.submit(futureTask);

    System.out.println("Doing other work...");
    Integer result = futureTask.get(); // Блокируется до завершения
    System.out.println("Task result: " + result);

    executor.shutdown();
  }
}

```

#### Где используется FutureTask?

+ Асинхронное выполнение задач: Например, загрузка данных из базы данных или выполнения долгих вычислений.

+ В рамках ExecutorService: Используется для передачи задач в пул потоков.

+ Прерываемые задачи: Можно проверить, завершена ли задача (isDone()), или отменить её (cancel()).

#### Преимущества FutureTask

+ Универсальность: Совмещает свойства Runnable и Future.
+ Гибкость: Подходит как для одиночного запуска через Thread, так и для работы с ExecutorService.
+ Контроль выполнения: Методы isDone(), cancel() дают возможность управлять задачей.

#### Недостатки FutureTask

+ Блокирующий вызов get(): Если задача ещё не завершена, выполнение будет заблокировано.
+ Сложность использования: В некоторых случаях (например, для большого числа задач) может быть проще использовать CompletableFuture.

[К оглавлению](#Multithreading)

# 24. Что такое Thread Pool?

Thread Pool (пул потоков) — это механизм многопоточности, при котором заранее создаётся фиксированное количество
потоков, которые переиспользуются для выполнения задач. Потоки создаются один раз и не уничтожаются после выполнения
задач, что помогает уменьшить затраты на создание и уничтожение потоков.

#### Как работает Thread Pool?

+ Создание пула потоков: Вы задаёте количество потоков (или оставляете управление на усмотрение системы).

+ Передача задач: Задачи передаются в пул с помощью метода submit() или execute().
+ Выполнение задач: Каждый поток из пула берёт задачу из очереди и выполняет её. После выполнения поток становится
  доступным для следующей задачи.

+ Завершение пула:
  Пул потоков может быть завершён, чтобы прекратить обработку новых задач.

#### Преимущества Thread Pool

+ Экономия ресурсов:
  Потоки переиспользуются, что снижает накладные расходы на их создание и уничтожение.

+ Управление количеством потоков:
  Вы можете ограничить число одновременно работающих потоков, чтобы не перегружать систему.

+ Повышение производительности:
  Сокращение времени на управление потоками.

+ Упрощённая работа с многопоточностью:
  Потоки управляются пулом, разработчику нужно лишь передавать задачи.

```java
Пул потоков реализован в библиотеке java.util.concurrent 
через интерфейс Executor и его подклассы, такие как ThreadPoolExecutor.

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolExample {
  public static void main(String[] args) {
    // Создаём пул из 3 потоков
    ExecutorService executor = Executors.newFixedThreadPool(3);

    // Передаём задачи в пул
    for (int i = 1; i <= 5; i++) {
      final int taskNumber = i;
      executor.execute(() -> {
        System.out.println("Executing task " + taskNumber + " by " + Thread.currentThread().getName());
        try {
          Thread.sleep(1000); // Симуляция выполнения задачи
        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
        }
      });
    }

    // Завершаем пул после выполнения всех задач
    executor.shutdown();
  }
}
```

#### Типы пулов потоков в Java
 
+ `newFixedThreadPool(int nThreads)`
Создаёт пул фиксированного размера. Если все потоки заняты, задачи ожидают в очереди.

+ `newCachedThreadPool()`
Создаёт пул с динамическим числом потоков. Потоки создаются при необходимости и переиспользуются.

+ `newSingleThreadExecutor()`
Создаёт пул с одним потоком. Задачи выполняются последовательно.

+ `newScheduledThreadPool(int corePoolSize)`
Позволяет запускать задачи с задержкой или по расписанию.

#### Когда использовать Thread Pool?

+ Много задач и ограниченные ресурсы:
Например, обработка запросов сервера или выполнение параллельных вычислений.

+ Избегание избыточного создания потоков:
Слишком большое количество потоков может привести к перегрузке процессора и памяти.

+ Контроль над многопоточностью: Лёгкое управление количеством одновременно выполняющихся задач.

#### Недостатки Thread Pool

+ Потенциальные блокировки:
Если потоков недостаточно, задачи могут ждать слишком долго.

+ Утечки ресурсов:
Если пул не завершается корректно (shutdown()), он может продолжать удерживать потоки.

+ Неправильная настройка:
Слишком большой или слишком маленький пул может снизить производительность.

[К оглавлению](#Multithreading)

# 25. Что такое Semaphore?

Semaphore (семафор) — это механизм синхронизации потоков, который используется для управления доступом к ограниченному количеству ресурсов. Семафор обеспечивает контроль над количеством потоков, которые могут одновременно использовать определённый ресурс.

В Java Semaphore реализован в пакете java.util.concurrent.
Как работает Semaphore?

Семафор содержит счётчик разрешений (permits), который изначально задаётся при создании семафора. Этот счётчик определяет, сколько потоков могут одновременно получить доступ к ресурсу.

+ При вызове acquire() поток запрашивает разрешение у семафора:
  + Если разрешение доступно (счётчик > 0), поток получает его, и счётчик уменьшается.
  + Если разрешений нет (счётчик = 0), поток блокируется до тех пор, пока разрешение не освободится.
+ При вызове release() поток освобождает разрешение:
  + Счётчик увеличивается, и один из ожидающих потоков может получить разрешение.

#### Основные методы Semaphore

+ `acquire()`
    Запрашивает разрешение. Поток блокируется, если разрешений нет.

+ `release()`
    Возвращает разрешение, увеличивая счётчик.

+ `tryAcquire()`
    Пытается получить разрешение без блокировки. Возвращает true, если разрешение доступно, иначе false.

+ `availablePermits()`
    Возвращает количество доступных разрешений.

+ `drainPermits()`
    Снимает все доступные разрешения (счётчик становится равным 0).

```java
Задача: Ограничить доступ к ресурсу, чтобы одновременно 
его могли использовать только 2 потока.

import java.util.concurrent.Semaphore;

public class SemaphoreExample {
  public static void main(String[] args) {
    // Создаём семафор с двумя разрешениями
    Semaphore semaphore = new Semaphore(2);

    // Создаём и запускаем 5 потоков
    for (int i = 1; i <= 5; i++) {
      final int threadNumber = i;
      new Thread(() -> {
        try {
          System.out.println("Thread " + threadNumber + " is waiting for a permit.");
          semaphore.acquire(); // Запрашиваем разрешение
          System.out.println("Thread " + threadNumber + " acquired a permit.");

          // Симулируем работу
          Thread.sleep(2000);

          System.out.println("Thread " + threadNumber + " released a permit.");
        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
        } finally {
          semaphore.release(); // Освобождаем разрешение
        }
      }).start();
    }
  }
}
```

### Типы Semaphore

+ `Fair Semaphore` (справедливый семафор)
Потоки получают разрешения в порядке очереди (FIFO). Для этого нужно использовать конструктор Semaphore(int permits, boolean fair) с параметром true.

+ `Unfair Semaphore` (несправедливый семафор)
Разрешения могут быть выданы любому потоку без строгого порядка. Это поведение по умолчанию (fair = false).

#### Применение Semaphore

+ Ограничение доступа к ресурсам:
    Например, ограничение количества соединений с базой данных или доступов к файлу.

+ Реализация очередей:
    Контроль за количеством потоков, которые могут одновременно выполнять задачи.

+ Синхронизация потоков:
    Упрощение взаимодействия между потоками в многопоточной среде.

#### Преимущества Semaphore

+ Простота реализации ограничения доступа к ресурсам.
+ Гибкость настройки (можно динамически менять количество разрешений).
+ Возможность справедливого распределения разрешений.

#### Недостатки Semaphore

+ Сложность в управлении при большом количестве потоков.
+ Возможность утечек разрешений, если забыть вызвать release().
+ Неправильное использование может привести к блокировкам или неоптимальному использованию ресурсов.

[К оглавлению](#Multithreading)

# 26. Чем отличается submit от execute у ExecutorService?

Оба метода используются для передачи задач в пул потоков (ExecutorService), но их функциональность и способы обработки различаются.

1. execute(Runnable task)

+ Назначение:
   Используется для передачи задачи в виде объекта Runnable в пул потоков для выполнения.

+ Возвращаемое значение:
   Метод ничего не возвращает — его тип void. Это означает, что вы не можете получить результат выполнения задачи или обработать возможное исключение напрямую.

+ Исключения:
   Если во время выполнения задачи возникает непроверяемое исключение (RuntimeException), оно будет передано обработчику непойманных исключений (Thread.UncaughtExceptionHandler) или выведено в стандартный поток ошибок.

```java
ExecutorService executor = Executors.newFixedThreadPool(2);

executor.execute(() -> {
    System.out.println("Task executed");
});
```

2. submit(Callable<V> task) или submit(Runnable task)

+ Назначение:
   Используется для передачи задачи, которую можно выполнять, в пул потоков. Этот метод более гибкий, так как поддерживает как Runnable, так и Callable.

+ Возвращаемое значение:
   Метод возвращает объект Future<V>, который можно использовать для:
  + Получения результата выполнения задачи с помощью get().
  + Обработки возможных исключений.
  + Отмены задачи с помощью cancel().

+ Исключения:
   Если задача выбрасывает исключение, оно будет обёрнуто в ExecutionException, и вы сможете получить его через Future.get().

```java
ExecutorService executor = Executors.newFixedThreadPool(2);

Future<String> future = executor.submit(() -> {
    return "Task completed";
});

try {
    String result = future.get(); // Блокирующий вызов
    System.out.println(result);
} catch (Exception e) {
    e.printStackTrace();
}
```

| Характеристика       | execute	                                  | submit                                    |
|----------------------|-------------------------------------------|-------------------------------------------|
| Возвращаемый тип     | void                                      | Future<V>                                 |
| Поддержка Callable   | Нет                                       | Да                                        |
| Обработка результата | Невозможно                                | Можно получить результат через Future     |
| Обработка исключений | Прямо передаёт в UncaughtExceptionHandler | Оборачивает в ExecutionException          |
| Гибкость             | Ограничен только задачами Runnable        | Поддерживает как Runnable, так и Callable |

#### Когда использовать?

+ execute:
    Используйте, если вам нужно просто выполнить задачу, не заботясь о результате или исключениях.

    Пример: Отправка сообщений в лог, обновление интерфейса.

+ submit:
    Используйте, если требуется получить результат выполнения задачи, обработать исключение или управлять выполнением (например, отменить задачу).

    Пример: Запуск вычислений, получение данных из удалённого API.

[К оглавлению](#Multithreading)

# 27. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?

Оба метода используются для завершения работы пула потоков, но их поведение существенно отличается.

1. shutdown()

+ Что делает:
  + Инициирует плавное завершение работы пула потоков.
  + Новые задачи в пул не принимаются, но уже переданные задачи продолжают выполняться.
  + Пул потоков завершится только после выполнения всех оставшихся задач.

+ Как это работает:
Поток, вызвавший shutdown(), сам продолжает работать, но останавливает возможность добавления новых задач в очередь.

+ Возвращаемое значение:
   Метод не возвращает результата (void).

```java
ExecutorService executor = Executors.newFixedThreadPool(2);

executor.submit(() -> {
    System.out.println("Task 1 is running");
});
executor.submit(() -> {
    System.out.println("Task 2 is running");
});

executor.shutdown();
System.out.println("Executor is shutting down");
```

2. shutdownNow()

+ Что делает:
  + Инициирует немедленное завершение работы пула потоков.
  + Попытка остановить все выполняющиеся задачи и прекратить обработку оставшихся задач из очереди.
  + Возвращает список задач, которые находились в очереди и не начали выполняться.

+ Как это работает:
  + Пул потоков пытается прервать текущие задачи, отправляя им сигнал прерывания (Thread.interrupt()).
  + Задачи, которые реагируют на сигнал прерывания (например, в методах sleep, wait), могут завершиться.
  + Если задачи игнорируют сигнал прерывания, они продолжат выполняться.

+ Возвращаемое значение:
   Возвращает List<Runnable> — список задач, которые находились в очереди, но не начали выполняться.

```java
ExecutorService executor = Executors.newFixedThreadPool(2);

executor.submit(() -> {
    try {
        Thread.sleep(5000);
        System.out.println("Task 1 is completed");
    } catch (InterruptedException e) {
        System.out.println("Task 1 was interrupted");
    }
});
executor.submit(() -> System.out.println("Task 2 is running"));

List<Runnable> notExecutedTasks = executor.shutdownNow();
System.out.println("Executor is shutting down now");
System.out.println("Not executed tasks: " + notExecutedTasks.size());
```

| Характеристика                  | shutdown()	                            | shutdownNow()                            |
|---------------------------------|----------------------------------------|------------------------------------------|
| Прекращение новых задач         | Да                                     | Да                                       |
| Выполнение уже переданных задач | Все задачи завершаются                 | Выполняющиеся задачи пытаются прерваться |
| Возврат задач из очереди        | Нет                                    | Да, возвращает список задач из очереди   |
| Прерывание текущих задач        | Нет                                    | Отправляется сигнал interrupt()          |
| Идея использования              | Плавное завершение работы пула потоков | Немедленное завершение работы пула       |

#### Когда использовать?

+ shutdown:
Когда нужно дать пулу потоков возможность корректно завершить уже запущенные задачи.
        Пример: Завершение сервера, который должен обработать текущие запросы перед остановкой.

+ shutdownNow:
        Когда необходимо экстренно завершить выполнение всех задач, даже если они не успели завершиться.
        Пример: Ситуации с ошибками, где дальнейшее выполнение задач небезопасно.

[К оглавлению](#Multithreading)

# 28. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.

Для создания пулов потоков (ThreadPool) можно использовать фабричные методы класса Executors.

1. Пул на 1 поток (SingleThreadExecutor)

   Особенности:
   Все задачи выполняются строго по очереди, в одном потоке.
   Подходит для задач, требующих последовательного выполнения.

```java
ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
singleThreadExecutor.submit(() -> {
    System.out.println(Thread.currentThread().getName() + ": Task 1");
});
singleThreadExecutor.submit(() -> {
    System.out.println(Thread.currentThread().getName() + ": Task 2");
});
singleThreadExecutor.shutdown();
```

2. Пул на 5 потоков (FixedThreadPool)

   Особенности:
   Позволяет одновременно выполнять до 5 задач.
   Если задач больше, чем потоков, они помещаются в очередь.
   Подходит для управления фиксированным количеством параллельных задач.

```java
ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);

for (int i = 1; i <= 10; i++) {
    int taskNumber = i;
    fixedThreadPool.submit(() -> {
        System.out.println(Thread.currentThread().getName() + ": Task " + taskNumber);
    });
}
fixedThreadPool.shutdown();
```

3. Пул с неограниченным количеством потоков (CachedThreadPool)

   Особенности:
   Создаёт новые потоки по мере необходимости.
   Использует ранее созданные потоки для повторного использования, если они доступны.
   Подходит для кратковременных задач, которые запускаются и завершаются быстро.

```java
ExecutorService cachedThreadPool = Executors.newCachedThreadPool();

for (int i = 1; i <= 10; i++) {
    int taskNumber = i;
    cachedThreadPool.submit(() -> {
        System.out.println(Thread.currentThread().getName() + ": Task " + taskNumber);
    });
}
cachedThreadPool.shutdown();
```

| Тип пула       | Метод создания	                     | Особенности                                   |
|----------------|-------------------------------------|-----------------------------------------------|
| На 1 поток     | Executors.newSingleThreadExecutor() | Последовательное выполнение задач.            |
| На 5 потоков   | Executors.newFixedThreadPool(5)     | Ограниченное количество параллельных потоков. |
| Неограниченный | Executors.newCachedThreadPool()     | Создаёт потоки по мере необходимости.         |

[К оглавлению](#Multithreading)

# 29. Что такое ReadWriteLock?

ReadWriteLock — это интерфейс в пакете java.util.concurrent.locks, предназначенный для управления доступом к ресурсу в многопоточной среде. Его основное предназначение — позволять нескольким потокам одновременно читать ресурс, но гарантировать, что запись выполняется только одним потоком и никакой другой поток не может читать или писать в это время.
#### Зачем нужен ReadWriteLock?

В типичном synchronized блоке или ReentrantLock доступ к ресурсу полностью эксклюзивен — только один поток может читать или писать одновременно. Это может быть излишним в ситуациях, когда нужно лишь безопасное чтение данных. ReadWriteLock решает эту проблему, улучшая производительность:

+ Одновременное чтение: Несколько потоков могут одновременно получать доступ к ресурсу в режиме чтения.
+ Эксклюзивная запись: Только один поток может записывать данные в ресурс, и при этом ни один поток не может читать.

Основные методы ReadWriteLock

#### Интерфейс предоставляет два метода:

+ Lock readLock() — возвращает блокировку для операций чтения.
+ Lock writeLock() — возвращает блокировку для операций записи.

```java
ReentrantReadWriteLock — это стандартная реализация интерфейса ReadWriteLock. 
Она поддерживает:
Рекурсивные блокировки.
Опциональный порядок справедливости (fairness).

import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteLockExample {
    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
    private int sharedResource = 0;

    // Метод для чтения
    public int read() {
        lock.readLock().lock(); // Блокировка для чтения
        try {
            System.out.println(Thread.currentThread().getName() + " reading: " + sharedResource);
            return sharedResource;
        } finally {
            lock.readLock().unlock(); // Освобождение блокировки
        }
    }

    // Метод для записи
    public void write(int value) {
        lock.writeLock().lock(); // Блокировка для записи
        try {
            System.out.println(Thread.currentThread().getName() + " writing: " + value);
            sharedResource = value;
        } finally {
            lock.writeLock().unlock(); // Освобождение блокировки
        }
    }

    public static void main(String[] args) {
        ReadWriteLockExample example = new ReadWriteLockExample();

        // Чтение в нескольких потоках
        Thread reader1 = new Thread(() -> example.read(), "Reader-1");
        Thread reader2 = new Thread(() -> example.read(), "Reader-2");

        // Запись в отдельном потоке
        Thread writer = new Thread(() -> example.write(42), "Writer");

        reader1.start();
        reader2.start();
        writer.start();
    }
}
```

#### Особенности ReadWriteLock

+ Повышение производительности:
        Для задач, где чтение ресурса происходит чаще, чем запись, ReadWriteLock снижает количество блокировок.

+ Порядок блокировки:
        Если поток пытается получить writeLock, то все новые запросы на readLock блокируются, пока не будет выполнена запись.

+ Гибкость:
        Возможность использования справедливого порядка (приоритет первого в очереди), если указать это в конструкторе ReentrantReadWriteLock(boolean fair).

+ Рекурсивность:
        Поток, уже владеющий readLock или writeLock, может повторно захватить эту же блокировку.

#### Когда использовать ReadWriteLock?

Когда ожидается большое количество операций чтения и относительно мало операций записи.
Для структур данных, к которым нужно обеспечить безопасный доступ, например, кэш или словарь.

#### Недостатки ReadWriteLock

+ Усложнение кода: Придётся явно управлять блокировками, что может привести к ошибкам, если забыть их освободить.
+ Накладные расходы: Если запись выполняется часто, производительность может незначительно снижаться из-за блокировки потоков.
+ Потенциальное "голодание": При неправильно настроенной справедливости поток, выполняющий запись, может долго ждать доступа, если чтения происходят часто.

[К оглавлению](#Multithreading)

# 30. В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt() и FutureTask.cancel().

1. Отличие Thread от FutureTask

`Thread`:

   Представляет поток выполнения, который управляет задачей.
   Используется для непосредственного управления жизненным циклом потока.
   Прямая работа с Thread может быть сложной в больших проектах.

#### Основные особенности:

Не предоставляет возможности получить результат выполнения задачи.
Поток запускается вызовом метода start(), а задача выполняется в run().

```java
Thread thread = new Thread(() -> {
    System.out.println("Task is running in thread");
});
thread.start();
```

`FutureTask`:

Представляет собой задачу, которая может быть запущена в любом Executor или в отдельном Thread.
Реализует интерфейсы Runnable и Future, что позволяет запускать задачу и одновременно управлять её состоянием.
Подходит для случаев, когда нужно получить результат выполнения задачи или обработать исключения.

#### Основные особенности:

Позволяет запустить задачу асинхронно.
Поддерживает получение результата через метод get().
Предоставляет возможность отмены задачи (cancel()).

```java
FutureTask<String> futureTask = new FutureTask<>(() -> {
    Thread.sleep(1000);
    return "Task result";
});

Thread thread = new Thread(futureTask);
thread.start();

try {
    System.out.println("Result: " + futureTask.get()); // Получение результата
} catch (Exception e) {
    e.printStackTrace();
}
```

2. Отличие Thread.interrupt() и FutureTask.cancel()

`Thread.interrupt()`:

Прерывает поток, на который ссылается объект Thread.
Устанавливает флаг прерывания потока, который можно проверить через Thread.isInterrupted().
Не завершает поток немедленно! Поток должен сам проверять флаг прерывания и корректно завершаться.

```java
Thread thread = new Thread(() -> {
    try {
        while (!Thread.currentThread().isInterrupted()) {
            System.out.println("Thread is running...");
            Thread.sleep(500);
        }
    } catch (InterruptedException e) {
        System.out.println("Thread was interrupted!");
    }
});
thread.start();

Thread.sleep(2000);
thread.interrupt(); // Устанавливает флаг прерывания

```

`FutureTask.cancel()`:

Позволяет отменить задачу, которая была передана в FutureTask.
Метод может завершить задачу, если она ещё не была запущена, или установить флаг отмены.
Если задача уже выполняется, при вызове cancel(true) будет вызван interrupt() для потока, выполняющего задачу.

```java
FutureTask<String> futureTask = new FutureTask<>(() -> {
    while (true) {
        System.out.println("Task is running...");
        Thread.sleep(500);
    }
});

Thread thread = new Thread(futureTask);
thread.start();

Thread.sleep(2000);
futureTask.cancel(true); // Отменяет задачу и прерывает поток

Методы:
cancel(false): просто помечает задачу как отменённую.
cancel(true): пытается прервать поток, вызывающий задачу.
```

| Характеристика                      | Thread.interrupt()	                        | FutureTask.cancel()                      |
|-------------------------------------|--------------------------------------------|------------------------------------------|
| Функция                             | Устанавливает флаг прерывания потока.      | Отменяет выполнение задачи.              |
| Когда срабатывает?                  | Только если поток обрабатывает прерывания. | Если задача не выполнена или не начата.. |
| Может вызвать InterruptedException? | Да.                                        | Да (если вызван с true)                  |
| Отмена выполнения задачи?           | Нет (зависит от кода потока).              | Да, если задача обрабатывает прерывание  |
| Использование с задачами?           | Прямое управление потоком.                 | Управление через Future/Executor.        |

[К оглавлению](#Multithreading)

# 31. Расскажите про шаблон проектирования Producer Consumer.

Producer-Consumer — это классический шаблон проектирования, который описывает взаимодействие между двумя типами сущностей:

+ Producer (Производитель) — производит данные или задачи и помещает их в буфер.
+ Consumer (Потребитель) — забирает данные или задачи из буфера и обрабатывает их.

Этот шаблон помогает организовать асинхронное взаимодействие между производителями и потребителями, обеспечивая:
Синхронизацию доступа к буферу.
Избежание переполнения буфера (если производители работают быстрее).
Избежание излишнего ожидания потребителей (если производители работают медленнее).

#### Основные компоненты

+ Буфер:
        Используется для хранения данных, передаваемых от производителя к потребителю.
        Обычно реализуется как потокобезопасная очередь (BlockingQueue в Java).

+ Синхронизация:
        Производитель должен дождаться, пока в буфере появится место.
        Потребитель должен дождаться, пока в буфере появятся данные.

+ Многопоточность:
        Производители и потребители работают в отдельных потоках.

```java
public class ParallelSearch {
    public static void main(String[] args) throws InterruptedException {
        SimpleBlockingQueue<Integer> queue = new SimpleBlockingQueue<Integer>(2);
        final Thread consumer = new Thread(
                () -> {
                    while (!Thread.currentThread().isInterrupted()) {
                        try {
                            System.out.println(queue.poll());
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                        }
                    }
                }
        );
       final Thread producer = new Thread(
                () -> {
                    for (int index = 0; index != 3; index++) {
                        try {
                            queue.offer(index);
                            Thread.sleep(500);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
        );
        consumer.start();
        producer.start();
        producer.join();
        consumer.interrupt();
    }
}
```


[К оглавлению](#Multithreading)

# 32. Как можно запустить параллельный поток (parallelStream)?

[К оглавлению](#Multithreading)

# 33. Что делают методы parallel и sequential?

[К оглавлению](#Multithreading)

# 34. Расскажите про порядок следования элементов в параллельном потоке и его особенностях.

[К оглавлению](#Multithreading)

# 35. В чем разница между методами forEach и forEachOrdered?

[К оглавлению](#Multithreading)

# 36. В чем разница между применением метода peek() в последовательном и параллельном потоках?

[К оглавлению](#Multithreading)

# 37. Что делает метод unordered?

[К оглавлению](#Multithreading)

# 38. Когда имеет смысл распараллеливать поток и какие при этом должны соблюдаться условия?

[К оглавлению](#Multithreading)

# 39. Расскажите про Java NIO и её главные составляющие.

[К оглавлению](#Multithreading)

# 40. Что такое канал?

[К оглавлению](#Multithreading)

# 41. Что такое буфер?

[К оглавлению](#Multithreading)

# 42. Что такое селектор?

[К оглавлению](#Multithreading)

# 43. Когда есть смысл использовать Java NIO?

[К оглавлению](#Multithreading)

# 44. Что такое PipedStreams? Как они устроены?

[К оглавлению](#Multithreading)