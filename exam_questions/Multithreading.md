## Multithreading

[1. Чем отличается процесс от потока?](#1-чем-отличается-процесс-от-потока)

[2. Каким образом можно создать поток?](#2-каким-образом-можно-создать-поток)

[3. Как работают методы sleep, yield, wait, notify и notifyAll?](#3-как-работают-методы-sleep-yield-wait-notify-и-notifyall)

[4. Объясните следующие термины: монитор, мьютекс, критическая секция.](#4-объясните-следующие-термины-монитор-мьютекс-критическая-секция)

[5. Как работает join()?](#5-как-работает-join)

[6. Что такое DeadLock? Приведите примеры.](#6-что-такое-deadlock-приведите-примеры)

[7. Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.](#7-назовите-различия-между-collectionssynchronizedmapnew-hashmap-и-concurrenthashmap)

[8. Различия в интерфейсах Runnable и Callable.](#8-различия-в-интерфейсах-runnable-и-callable)

[9. Различия между isInterrupted(), interrupted(), interrupt().](#9-различия-между-isinterrupted-interrupted-interrupt)

[10. Что происходит при вызове Thread.interrupt()?](#10-что-происходит-при-вызове-threadinterrupt)

[11. Перечислите ВСЕ причины по которым может быть выброшено InterruptedException.](#11-перечислите-все-причины-по-которым-может-быть-выброшено-interruptedexception)

[12. Назовите отличия synchronized{} и ReentrantLock.](#12-назовите-отличия-synchronized-и-reentrantlock)

[13. Приведите наиболее существенное отличие между CountDownLatch и CyclicBarrier.](#13-приведите-наиболее-существенное-отличие-между-countdownlatch-и-cyclicbarrier)

[14. Приведите наиболее существенное отличие между CyclicBarrier и Phaser.](#14-приведите-наиболее-существенное-отличие-между-cyclicbarrier-и-phaser)

[15. Расскажите про Exchanger.](#15-расскажите-про-exchanger)

[16. Отличие Thread.start() и Thread.run()?](#16-отличие-threadstart-и-threadrun)

[17. Объясните ключевое слово volatile.](#17-объясните-ключевое-слово-volatile)

[18. Расскажите про приоритеты потока](#18-расскажите-про-приоритеты-потока)

[19. Что такое потоки-демоны?](#19-что-такое-потоки-демоны)

[20. Назовите все возможные состояния потока.](#20-назовите-все-возможные-состояния-потока)

[21. Что такое race condition?](#21-что-такое-race-condition)

[22. Что такое Thread Local переменная?](#22-что-такое-thread-local-переменная)

[23. Что такое FutureTask?](#23-что-такое-futuretask)

[24. Что такое Thread Pool?](#24-что-такое-thread-pool)

[25. Что такое Semaphore?](#25-что-такое-semaphore)

[26. Чем отличается submit от execute у ExecutorService?](#26-чем-отличается-submit-от-execute-у-executorservice)

[27. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?](#27-чем-отличается-shutdown-от-shutdownnow-у-threadpoolexecutor)

[28. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.](#28-как-создать-threadpool-у-executorservice-только-на-1-на-5-на-неограниченное-количество-потоков)

[29. Что такое ReadWriteLock?](#29-что-такое-readwritelock)

[30. В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt() и FutureTask.cancel().](#30-в-чём-отличие-thread-от-futuretask-в-чём-отличие-threadinterrupt-и-futuretaskcancel)

[31. Расскажите про шаблон проектирования Producer Consumer.](#31-расскажите-про-шаблон-проектирования-producer-consumer)

[32. Как можно запустить параллельный поток (parallelStream)?](#32-как-можно-запустить-параллельный-поток-parallelstream)

[33. Что делают методы parallel и sequential?](#33-что-делают-методы-parallel-и-sequential)

[34. Расскажите про порядок следования элементов в параллельном потоке и его особенностях.](#34-расскажите-про-порядок-следования-элементов-в-параллельном-потоке-и-его-особенностях)

[35. В чем разница между методами forEach и forEachOrdered?](#35-в-чем-разница-между-методами-foreach-и-foreachordered)

[36. В чем разница между применением метода peek() в последовательном и параллельном потоках?](#36-в-чем-разница-между-применением-метода-peek-в-последовательном-и-параллельном-потоках)

[37. Что делает метод unordered?](#37-что-делает-метод-unordered)

[38. Когда имеет смысл распараллеливать поток и какие при этом должны соблюдаться условия?](#38-когда-имеет-смысл-распараллеливать-поток-и-какие-при-этом-должны-соблюдаться-условия)

[39. Расскажите про Java NIO и её главные составляющие.](#39-расскажите-про-java-nio-и-её-главные-составляющие)

[40. Что такое канал?](#40-что-такое-канал)

[41. Что такое буфер?](#41-что-такое-буфер)

[42. Что такое селектор?](#42-что-такое-селектор)

[43. Когда есть смысл использовать Java NIO?](#43-когда-есть-смысл-использовать-java-nio)

[44. Что такое PipedStreams? Как они устроены?](#44-что-такое-pipedstreams-как-они-устроены)

# 1. Чем отличается процесс от потока?

Процесс и поток — это два ключевых понятия в многозадачности, но они отличаются по своему "масштабу" и организации
работы в операционной системе.

`Процесс` — это изолированная единица выполнения. Каждый процесс имеет свой собственный адрес в памяти, свои ресурсы (
например, файлы, переменные окружения) и свою собственную память. Процессы могут работать параллельно, но они не могут
напрямую взаимодействовать друг с другом без использования специальных механизмов (например, межпроцессного
взаимодействия — IPC). Если процесс завершится, то все ресурсы, связанные с ним, освобождаются.

`Поток` (или тред) — это более легковесная единица исполнения, которая существует внутри процесса. Потоки в рамках
одного процесса разделяют общую память и ресурсы процесса. Это позволяет потокам работать быстрее, поскольку им не нужно
создавать отдельные ресурсы для каждого потока. Однако это также создает некоторые риски, например, проблемы с
синхронизацией при доступе к общей памяти.

#### Важные различия:

+ Процесс имеет свою собственную память и ресурсы, а потоки внутри процесса делят общую память и ресурсы.
+ Процесс может содержать несколько потоков, а поток не существует без процесса.
+ Создание и управление процессами более ресурсоемко, чем создание и управление потоками.

Простой пример: представь себе, что процесс — это целый офис с множеством рабочих мест, а потоки — это сотрудники,
которые работают в этом офисе. Все сотрудники используют общие ресурсы офиса (столы, компьютеры), но каждый сотрудник
выполняет свою задачу.

[К оглавлению](#Multithreading)

# 2. Каким образом можно создать поток?

1. Реализовать интерфейс Runnable

Это более гибкий способ, так как позволяет наследовать другие классы (например, от Thread), если это необходимо.

#### Вот как это работает:

+ Создаешь класс, который реализует интерфейс Runnable.
+ Переопределяешь метод run(), который будет содержать код, выполняемый потоком.
+ Создаешь объект типа Thread, передавая ему экземпляр класса, реализующего Runnable.
+ Запускаешь поток с помощью метода start().
```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
    System.out.println("Поток работает!");
 }
}

public class Main {
public static void main(String[] args) {
    MyRunnable myRunnable = new MyRunnable();
    Thread thread = new Thread(myRunnable); // Создаем поток
    thread.start(); // Запускаем поток
 }
}
```
2. Наследовать от класса Thread

Другой способ — это создать класс, который наследует Thread и переопределить метод run(). Это работает так же, как и с
Runnable, но с некоторыми ограничениями, например, нельзя наследовать от других классов, потому что Java поддерживает
только одно наследование.

```java
class MyThread extends Thread {
    @Override
    public void run() {
    System.out.println("Поток работает!");
 }
}

public class Main {
    public static void main(String[] args) {
    MyThread thread = new MyThread(); // Создаем поток
    thread.start(); // Запускаем поток
 }
}
```

3. С помощью лямбда - выражений, передается в конструктор Thread и реализует интерфейс Runnable. Это более современный и
   компактный способ создания потоков в Java, особенно с появлением лямбда-выражений в Java 8.

```java
public class ConcurrentOutput {
    public static void main(String[] args) {
        Thread another = new Thread(
                () -> System.out.println(Thread.currentThread().getName())
        );
        another.start();
        System.out.println(Thread.currentThread().getName());
    }
}
```

#### Главное отличие:

+ Runnable: позволяет создавать потоки, не ограничивая возможность наследовать другие классы.
+ Thread: удобен, если нужно сразу работать с потоками, но не позволяет наследовать другие классы.

#### Как работает поток?

Когда ты вызываешь start(), система вызывает метод run() в новом потоке. Важно помнить, что если ты вызовешь просто
run(), то код выполнится в текущем потоке, а не в новом.

[К оглавлению](#Multithreading)

# 3. Как работают методы sleep, yield, wait, notify и notifyAll?

1. Thread.sleep()

Этот метод временно приостанавливает выполнение текущего потока на заданное количество времени. После завершения паузы
поток продолжает работу.

+ Где применяется: для создания задержек в выполнении программы.
+ Особенности:
    + Поток, вызвавший sleep, переходит в состояние TIMED_WAITING.
    + Метод бросает InterruptedException, если поток будет прерван во время сна.

```java
try {
Thread.sleep(1000); // Поток "засыпает" на 1 секунду
} catch (InterruptedException e) {
e.printStackTrace();
}
```

2. Thread.yield()

Этот метод сигнализирует планировщику потоков, что текущий поток готов уступить место другим потокам с таким же или
более высоким приоритетом.

+ Где применяется: редко, обычно для оптимизации многопоточных программ.
+ Особенности:
    + Это всего лишь рекомендация, и планировщик потоков может проигнорировать ее.
    + Поток остается в состоянии RUNNABLE.
```java
Thread.yield(); // Текущий поток может уступить место другим потокам
```

3. wait()

Метод используется для временной приостановки потока до тех пор, пока другой поток не вызовет notify() или notifyAll()
на том же объекте.

+ Где применяется: при реализации межпоточного взаимодействия (например, Producer-Consumer паттерн).
+ Особенности:
  + Вызывается только на мониторе объекта, т.е. внутри синхронизированного блока или метода.
    + Поток переходит в состояние WAITING до вызова notify() или notifyAll().

```java
synchronized (lock) {
lock.wait(); // Текущий поток ждет сигнала
}
```
4. notify()

Этот метод пробуждает один поток, который ждет на мониторе данного объекта.

+ Где применяется: для пробуждения потоков, ожидающих на wait().
+ Особенности:
  + Какой именно поток будет пробужден, определяется системой (нет гарантии).
  + Вызывается внутри синхронизированного блока или метода.
```java
synchronized (lock) {
lock.notify(); // Будет пробужден один ожидающий поток
}
```
5. notifyAll()

Этот метод пробуждает все потоки, которые ожидают на мониторе данного объекта.

+ Где применяется: когда нужно пробудить все ожидающие потоки.
+ Особенности:
    + Все пробужденные потоки начинают конкурировать за монитор.
```java
synchronized (lock) {
lock.notifyAll(); // Все ожидающие потоки будут пробуждены
}
```

| Метод     | Контекст использования	             | Поток           | Требует synchronized |
|-----------|-------------------------------------|-----------------|----------------------|
| sleep     | Задержка выполнения                 | Текущий поток   | Нет                  |
| yield     | Уступка другим потокам              | Текущий поток   | Нет                  |
| wait      | Ожидание сигнала                    | Ожидающий поток | Да                   |
| notify    | Пробуждение одного потока           | Ждущие потоки   | Да                   |
| notifyAll | Пробуждение всех ожидающих потоков	 | Ждущие потоки   | Да                   |

```java
Пример взаимодействия wait и notify:

class SharedResource {
    private boolean isReady = false;

    public synchronized void waitForReady() {
        while (!isReady) {
            try {
                wait(); // Ожидание сигнала
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("Готово к работе!");
    }

    public synchronized void setReady() {
        isReady = true;
        notify(); // Сигнал одному ожидающему потоку
    }
}

public class Main {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();

        new Thread(resource::waitForReady).start();

        try {
            Thread.sleep(1000); // Имитация задержки
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        resource.setReady(); // Уведомление о готовности
    }
}

```

[К оглавлению](#Multithreading)

# 4. Объясните следующие термины: монитор, мьютекс, критическая секция.

[К оглавлению](#Multithreading)

# 5. Как работает join()?

[К оглавлению](#Multithreading)

# 6. Что такое DeadLock? Приведите примеры.

[К оглавлению](#Multithreading)

# 7. Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.

[К оглавлению](#Multithreading)

# 8. Различия в интерфейсах Runnable и Callable.

[К оглавлению](#Multithreading)

# 9. Различия между isInterrupted(), interrupted(), interrupt().

[К оглавлению](#Multithreading)

# 10. Что происходит при вызове Thread.interrupt()?

[К оглавлению](#Multithreading)

# 11. Перечислите ВСЕ причины по которым может быть выброшено InterruptedException.

[К оглавлению](#Multithreading)

# 12. Назовите отличия synchronized{} и ReentrantLock.

[К оглавлению](#Multithreading)

# 13. Приведите наиболее существенное отличие между CountDownLatch и CyclicBarrier.

[К оглавлению](#Multithreading)

# 14. Приведите наиболее существенное отличие между CyclicBarrier и Phaser.

[К оглавлению](#Multithreading)

# 15. Расскажите про Exchanger.

[К оглавлению](#Multithreading)

# 16. Отличие Thread.start() и Thread.run()?

[К оглавлению](#Multithreading)

# 17. Объясните ключевое слово volatile.

[К оглавлению](#Multithreading)

# 18. Расскажите про приоритеты потока

[К оглавлению](#Multithreading)

# 19. Что такое потоки-демоны?

[К оглавлению](#Multithreading)

# 20. Назовите все возможные состояния потока.

[К оглавлению](#Multithreading)

# 21. Что такое race condition?

[К оглавлению](#Multithreading)

# 22. Что такое Thread Local переменная?

[К оглавлению](#Multithreading)

# 23. Что такое FutureTask?

[К оглавлению](#Multithreading)

# 24. Что такое Thread Pool?

[К оглавлению](#Multithreading)

# 25. Что такое Semaphore?

[К оглавлению](#Multithreading)

# 26. Чем отличается submit от execute у ExecutorService?

[К оглавлению](#Multithreading)

# 27. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?

[К оглавлению](#Multithreading)

# 28. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.

[К оглавлению](#Multithreading)

# 29. Что такое ReadWriteLock?

[К оглавлению](#Multithreading)

# 30. В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt() и FutureTask.cancel().

[К оглавлению](#Multithreading)

# 31. Расскажите про шаблон проектирования Producer Consumer.

[К оглавлению](#Multithreading)

# 32. Как можно запустить параллельный поток (parallelStream)?

[К оглавлению](#Multithreading)

# 33. Что делают методы parallel и sequential?

[К оглавлению](#Multithreading)

# 34. Расскажите про порядок следования элементов в параллельном потоке и его особенностях.

[К оглавлению](#Multithreading)

# 35. В чем разница между методами forEach и forEachOrdered?

[К оглавлению](#Multithreading)

# 36. В чем разница между применением метода peek() в последовательном и параллельном потоках?

[К оглавлению](#Multithreading)

# 37. Что делает метод unordered?

[К оглавлению](#Multithreading)

# 38. Когда имеет смысл распараллеливать поток и какие при этом должны соблюдаться условия?

[К оглавлению](#Multithreading)

# 39. Расскажите про Java NIO и её главные составляющие.

[К оглавлению](#Multithreading)

# 40. Что такое канал?

[К оглавлению](#Multithreading)

# 41. Что такое буфер?

[К оглавлению](#Multithreading)

# 42. Что такое селектор?

[К оглавлению](#Multithreading)

# 43. Когда есть смысл использовать Java NIO?

[К оглавлению](#Multithreading)

# 44. Что такое PipedStreams? Как они устроены?

[К оглавлению](#Multithreading)